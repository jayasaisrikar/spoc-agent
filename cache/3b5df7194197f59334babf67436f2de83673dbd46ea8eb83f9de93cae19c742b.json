{
  "prompt": "\nBased on the previously analyzed repository 'modelcontextprotocol-python-sdk', please answer this question:\n\n\n\n\n\n**Current Question:** can you integrate this in flockshop rep?\n\n**COMPLETE FILE STRUCTURE AND CONTENTS:**\n\n**File Tree:**\n- .github/ISSUE_TEMPLATE/bug.yaml\n- .github/ISSUE_TEMPLATE/config.yaml\n- .github/ISSUE_TEMPLATE/feature-request.yaml\n- .github/ISSUE_TEMPLATE/question.yaml\n- .github/workflows/main-checks.yml\n- .github/workflows/publish-docs-manually.yml\n- .github/workflows/publish-pypi.yml\n- .github/workflows/pull-request-checks.yml\n- .github/workflows/shared.yml\n- .gitignore\n- .pre-commit-config.yaml\n- CLAUDE.md\n- CODE_OF_CONDUCT.md\n- CONTRIBUTING.md\n- LICENSE\n- README.md\n- RELEASE.md\n- SECURITY.md\n- docs/api.md\n- docs/index.md\n- examples/README.md\n- examples/clients/simple-auth-client/README.md\n- examples/clients/simple-auth-client/mcp_simple_auth_client/__init__.py\n- examples/clients/simple-auth-client/mcp_simple_auth_client/main.py\n- examples/clients/simple-auth-client/pyproject.toml\n- examples/clients/simple-chatbot/README.MD\n- examples/clients/simple-chatbot/mcp_simple_chatbot/.env.example\n- examples/clients/simple-chatbot/mcp_simple_chatbot/main.py\n- examples/clients/simple-chatbot/mcp_simple_chatbot/requirements.txt\n- examples/clients/simple-chatbot/mcp_simple_chatbot/servers_config.json\n- examples/clients/simple-chatbot/pyproject.toml\n- examples/fastmcp/complex_inputs.py\n- examples/fastmcp/desktop.py\n- examples/fastmcp/echo.py\n- examples/fastmcp/memory.py\n- examples/fastmcp/parameter_descriptions.py\n- examples/fastmcp/readme-quickstart.py\n- examples/fastmcp/screenshot.py\n- examples/fastmcp/simple_echo.py\n- examples/fastmcp/text_me.py\n- examples/fastmcp/unicode_example.py\n- examples/fastmcp/weather_structured.py\n- examples/servers/simple-auth/README.md\n- examples/servers/simple-auth/mcp_simple_auth/__init__.py\n- examples/servers/simple-auth/mcp_simple_auth/__main__.py\n- examples/servers/simple-auth/mcp_simple_auth/auth_server.py\n- examples/servers/simple-auth/mcp_simple_auth/legacy_as_server.py\n- examples/servers/simple-auth/mcp_simple_auth/server.py\n- examples/servers/simple-auth/mcp_simple_auth/simple_auth_provider.py\n- examples/servers/simple-auth/mcp_simple_auth/token_verifier.py\n- examples/servers/simple-auth/pyproject.toml\n- examples/servers/simple-prompt/README.md\n- examples/servers/simple-prompt/mcp_simple_prompt/__init__.py\n- examples/servers/simple-prompt/mcp_simple_prompt/__main__.py\n- examples/servers/simple-prompt/mcp_simple_prompt/server.py\n- examples/servers/simple-prompt/pyproject.toml\n- examples/servers/simple-resource/README.md\n- examples/servers/simple-resource/mcp_simple_resource/__init__.py\n- examples/servers/simple-resource/mcp_simple_resource/__main__.py\n- examples/servers/simple-resource/mcp_simple_resource/server.py\n- examples/servers/simple-resource/pyproject.toml\n- examples/servers/simple-streamablehttp-stateless/README.md\n- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/__init__.py\n- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/__main__.py\n- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/server.py\n- examples/servers/simple-streamablehttp-stateless/pyproject.toml\n- examples/servers/simple-streamablehttp/README.md\n- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/__init__.py\n- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/__main__.py\n- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/event_store.py\n- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/server.py\n- examples/servers/simple-streamablehttp/pyproject.toml\n- examples/servers/simple-tool/README.md\n- examples/servers/simple-tool/mcp_simple_tool/__init__.py\n- examples/servers/simple-tool/mcp_simple_tool/__main__.py\n- examples/servers/simple-tool/mcp_simple_tool/server.py\n- examples/servers/simple-tool/pyproject.toml\n- examples/servers/structured_output_lowlevel.py\n- examples/snippets/clients/__init__.py\n- examples/snippets/clients/completion_client.py\n- examples/snippets/clients/display_utilities.py\n- examples/snippets/clients/oauth_client.py\n- examples/snippets/clients/parsing_tool_results.py\n- examples/snippets/clients/stdio_client.py\n- examples/snippets/clients/streamable_basic.py\n- examples/snippets/pyproject.toml\n- examples/snippets/servers/__init__.py\n- examples/snippets/servers/basic_prompt.py\n- examples/snippets/servers/basic_resource.py\n- examples/snippets/servers/basic_tool.py\n- examples/snippets/servers/completion.py\n- examples/snippets/servers/direct_execution.py\n- examples/snippets/servers/elicitation.py\n- examples/snippets/servers/fastmcp_quickstart.py\n- examples/snippets/servers/images.py\n- examples/snippets/servers/lifespan_example.py\n- examples/snippets/servers/lowlevel/__init__.py\n- examples/snippets/servers/lowlevel/basic.py\n- examples/snippets/servers/lowlevel/lifespan.py\n- examples/snippets/servers/lowlevel/structured_output.py\n- examples/snippets/servers/notifications.py\n- examples/snippets/servers/oauth_server.py\n- examples/snippets/servers/sampling.py\n- examples/snippets/servers/streamable_config.py\n- examples/snippets/servers/streamable_starlette_mount.py\n- examples/snippets/servers/structured_output.py\n- examples/snippets/servers/tool_progress.py\n- mkdocs.yml\n- pyproject.toml\n- scripts/update_readme_snippets.py\n- src/mcp/__init__.py\n- src/mcp/cli/__init__.py\n- src/mcp/cli/claude.py\n- src/mcp/cli/cli.py\n- src/mcp/client/__init__.py\n- src/mcp/client/__main__.py\n- src/mcp/client/auth.py\n- src/mcp/client/session.py\n- src/mcp/client/session_group.py\n- src/mcp/client/sse.py\n- src/mcp/client/stdio/__init__.py\n- src/mcp/client/streamable_http.py\n- src/mcp/client/websocket.py\n- src/mcp/os/__init__.py\n- src/mcp/os/posix/__init__.py\n- src/mcp/os/posix/utilities.py\n- src/mcp/os/win32/__init__.py\n- src/mcp/os/win32/utilities.py\n- src/mcp/server/__init__.py\n- src/mcp/server/__main__.py\n- src/mcp/server/auth/__init__.py\n- src/mcp/server/auth/errors.py\n- src/mcp/server/auth/handlers/__init__.py\n- src/mcp/server/auth/handlers/authorize.py\n- src/mcp/server/auth/handlers/metadata.py\n- src/mcp/server/auth/handlers/register.py\n- src/mcp/server/auth/handlers/revoke.py\n- src/mcp/server/auth/handlers/token.py\n- src/mcp/server/auth/json_response.py\n- src/mcp/server/auth/middleware/__init__.py\n- src/mcp/server/auth/middleware/auth_context.py\n- src/mcp/server/auth/middleware/bearer_auth.py\n- src/mcp/server/auth/middleware/client_auth.py\n- src/mcp/server/auth/provider.py\n- src/mcp/server/auth/routes.py\n- src/mcp/server/auth/settings.py\n- src/mcp/server/elicitation.py\n- src/mcp/server/fastmcp/__init__.py\n- src/mcp/server/fastmcp/exceptions.py\n- src/mcp/server/fastmcp/prompts/__init__.py\n- src/mcp/server/fastmcp/prompts/base.py\n- src/mcp/server/fastmcp/prompts/manager.py\n- src/mcp/server/fastmcp/prompts/prompt_manager.py\n- src/mcp/server/fastmcp/resources/__init__.py\n- src/mcp/server/fastmcp/resources/base.py\n- src/mcp/server/fastmcp/resources/resource_manager.py\n- src/mcp/server/fastmcp/resources/templates.py\n- src/mcp/server/fastmcp/resources/types.py\n- src/mcp/server/fastmcp/server.py\n- src/mcp/server/fastmcp/tools/__init__.py\n- src/mcp/server/fastmcp/tools/base.py\n- src/mcp/server/fastmcp/tools/tool_manager.py\n- src/mcp/server/fastmcp/utilities/__init__.py\n- src/mcp/server/fastmcp/utilities/func_metadata.py\n- src/mcp/server/fastmcp/utilities/logging.py\n- src/mcp/server/fastmcp/utilities/types.py\n- src/mcp/server/lowlevel/__init__.py\n- src/mcp/server/lowlevel/helper_types.py\n- src/mcp/server/lowlevel/server.py\n- src/mcp/server/models.py\n- src/mcp/server/session.py\n- src/mcp/server/sse.py\n- src/mcp/server/stdio.py\n- src/mcp/server/streamable_http.py\n- src/mcp/server/streamable_http_manager.py\n- src/mcp/server/streaming_asgi_transport.py\n- src/mcp/server/transport_security.py\n- src/mcp/server/websocket.py\n- src/mcp/shared/__init__.py\n- src/mcp/shared/_httpx_utils.py\n- src/mcp/shared/auth.py\n- src/mcp/shared/auth_utils.py\n- src/mcp/shared/context.py\n- src/mcp/shared/exceptions.py\n- src/mcp/shared/memory.py\n- src/mcp/shared/message.py\n- src/mcp/shared/metadata_utils.py\n- src/mcp/shared/progress.py\n- src/mcp/shared/session.py\n- src/mcp/shared/version.py\n- src/mcp/types.py\n- tests/__init__.py\n- tests/cli/__init__.py\n- tests/cli/test_utils.py\n- tests/client/__init__.py\n- tests/client/conftest.py\n- tests/client/test_auth.py\n- tests/client/test_config.py\n- tests/client/test_list_methods_cursor.py\n- tests/client/test_list_roots_callback.py\n- tests/client/test_logging_callback.py\n- tests/client/test_output_schema_validation.py\n- tests/client/test_resource_cleanup.py\n- tests/client/test_sampling_callback.py\n- tests/client/test_session.py\n- tests/client/test_session_group.py\n- tests/client/test_stdio.py\n- tests/conftest.py\n- tests/issues/test_100_tool_listing.py\n- tests/issues/test_1027_win_unreachable_cleanup.py\n- tests/issues/test_129_resource_templates.py\n- tests/issues/test_141_resource_templates.py\n- tests/issues/test_152_resource_mime_type.py\n- tests/issues/test_176_progress_token.py\n- tests/issues/test_188_concurrency.py\n- tests/issues/test_192_request_id.py\n- tests/issues/test_342_base64_encoding.py\n- tests/issues/test_355_type_error.py\n- tests/issues/test_552_windows_hang.py\n- tests/issues/test_88_random_error.py\n- tests/issues/test_malformed_input.py\n- tests/server/__init__.py\n- tests/server/auth/middleware/test_auth_context.py\n- tests/server/auth/middleware/test_bearer_auth.py\n- tests/server/auth/test_error_handling.py\n- tests/server/fastmcp/__init__.py\n- tests/server/fastmcp/auth/__init__.py\n- tests/server/fastmcp/auth/test_auth_integration.py\n- tests/server/fastmcp/prompts/__init__.py\n- tests/server/fastmcp/prompts/test_base.py\n- tests/server/fastmcp/prompts/test_manager.py\n- tests/server/fastmcp/resources/__init__.py\n- tests/server/fastmcp/resources/test_file_resources.py\n- tests/server/fastmcp/resources/test_function_resources.py\n- tests/server/fastmcp/resources/test_resource_manager.py\n- tests/server/fastmcp/resources/test_resource_template.py\n- tests/server/fastmcp/resources/test_resources.py\n- tests/server/fastmcp/servers/__init__.py\n- tests/server/fastmcp/servers/test_file_server.py\n- tests/server/fastmcp/test_elicitation.py\n- tests/server/fastmcp/test_func_metadata.py\n- tests/server/fastmcp/test_integration.py\n- tests/server/fastmcp/test_parameter_descriptions.py\n- tests/server/fastmcp/test_server.py\n- tests/server/fastmcp/test_title.py\n- tests/server/fastmcp/test_tool_manager.py\n- tests/server/test_completion_with_context.py\n- tests/server/test_lifespan.py\n- tests/server/test_lowlevel_input_validation.py\n- tests/server/test_lowlevel_output_validation.py\n- tests/server/test_lowlevel_tool_annotations.py\n- tests/server/test_read_resource.py\n- tests/server/test_session.py\n- tests/server/test_sse_security.py\n- tests/server/test_stdio.py\n- tests/server/test_streamable_http_manager.py\n- tests/server/test_streamable_http_security.py\n- tests/shared/test_auth.py\n- tests/shared/test_auth_utils.py\n- tests/shared/test_httpx_utils.py\n- tests/shared/test_memory.py\n- tests/shared/test_progress_notifications.py\n- tests/shared/test_session.py\n- tests/shared/test_sse.py\n- tests/shared/test_streamable_http.py\n- tests/shared/test_win32_utils.py\n- tests/shared/test_ws.py\n- tests/test_examples.py\n- tests/test_types.py\n\n**File Contents:**\n\n--- .github/ISSUE_TEMPLATE/bug.yaml (yaml) ---\nname: ðŸ› MCP Python SDK Bug\ndescription: Report a bug or unexpected behavior in the MCP Python SDK\nlabels: [\"need confirmation\"]\n\nbody:\n  - type: markdown\n    attributes:\n      value: Thank you for contributing to the MCP Python SDK! âœŠ\n\n  - type: checkboxes\n    id: checks\n    attributes:\n      label: Initial Checks\n      description: Just making sure you're using the latest version of MCP Python SDK.\n      options:\n        - label: I confirm that I'm using the latest version of MCP Python SDK\n          required: true\n        - label: I confirm that I searched for my issue in https://github.com/modelcontextprotocol/python-sdk/issues before opening this issue\n          required: true\n\n  - type: textarea\n    id: description\n    attributes:\n      label: Description\n      description: |\n        Please explain what you're seeing and what you would expect to see.\n\n        Please provide as much detail as possible to make understanding and solving your problem as quick as possible. ðŸ™\n    validations:\n      required: true\n\n  - type: textarea\n    id: example\n    attributes:\n      label: Example Code\n      description: >\n        If applicable, please add a self-contained,\n        [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example)\n        demonstrating the bug.\n\n      placeholder: |\n        from mcp.server.fastmcp import FastMCP\n\n        ...\n      render: Python\n\n  - type: textarea\n    id: version\n    attributes:\n      label: Python & MCP Python SDK\n      description: |\n        Which version of Python and MCP Python SDK are you using?\n      render: Text\n    validations:\n      required: true\n\n\n--- .github/ISSUE_TEMPLATE/config.yaml (yaml) ---\nblank_issues_enabled: false\n\n\n--- .github/ISSUE_TEMPLATE/feature-request.yaml (yaml) ---\nname: ðŸš€ MCP Python SDK Feature Request\ndescription: \"Suggest a new feature for the MCP Python SDK\"\nlabels: [\"feature request\"]\n\nbody:\n  - type: markdown\n    attributes:\n      value: Thank you for contributing to the MCP Python SDK! âœŠ\n\n  - type: textarea\n    id: description\n    attributes:\n      label: Description\n      description: |\n        Please give as much detail as possible about the feature you would like to suggest. ðŸ™\n\n        You might like to add:\n        * A demo of how code might look when using the feature\n        * Your use case(s) for the feature\n        * Reference to other projects that have a similar feature\n    validations:\n      required: true\n\n  - type: textarea\n    id: references\n    attributes:\n      label: References\n      description: |\n        Please add any links or references that might help us understand your feature request better. ðŸ“š\n\n\n--- .github/ISSUE_TEMPLATE/question.yaml (yaml) ---\nname: â“ MCP Python SDK Question\ndescription: \"Ask a question about the MCP Python SDK\"\nlabels: [\"question\"]\n\nbody:\n  - type: markdown\n    attributes:\n      value: Thank you for reaching out to the MCP Python SDK community! We're here to help! ðŸ¤\n\n  - type: textarea\n    id: question\n    attributes:\n      label: Question\n      description: |\n        Please provide as much detail as possible about your question. ðŸ™\n\n        You might like to include:\n        * Code snippets showing what you've tried\n        * Error messages you're encountering (if any)\n        * Expected vs actual behavior\n        * Your use case and what you're trying to achieve\n    validations:\n      required: true\n\n  - type: textarea\n    id: context\n    attributes:\n      label: Additional Context\n      description: |\n        Please provide any additional context that might help us better understand your question, such as:\n        * Your MCP Python SDK version\n        * Your Python version\n        * Relevant configuration or environment details ðŸ“\n\n\n--- .github/workflows/main-checks.yml (yml) ---\nname: Main branch checks\n\non:\n  push:\n    branches:\n      - main\n      - \"v*.*.*\"\n    tags:\n      - \"v*.*.*\"\n\njobs:\n  checks:\n    uses: ./.github/workflows/shared.yml\n\n\n--- .github/workflows/publish-docs-manually.yml (yml) ---\nname: Publish Docs manually\n\non:\n  workflow_dispatch:\n\njobs:\n  docs-publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - run: echo \"cache_id=$(date --utc '+%V')\" >> $GITHUB_ENV\n      - uses: actions/cache@v4\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n\n      - run: uv sync --frozen --group docs\n      - run: uv run --frozen --no-sync mkdocs gh-deploy --force\n\n\n--- .github/workflows/publish-pypi.yml (yml) ---\nname: Publishing\n\non:\n  release:\n    types: [published]\n\njobs:\n  release-build:\n    name: Build distribution\n    runs-on: ubuntu-latest\n    needs: [checks]\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - name: Set up Python 3.12\n        run: uv python install 3.12\n\n      - name: Build\n        run: uv build\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  checks:\n    uses: ./.github/workflows/shared.yml\n\n  pypi-publish:\n    name: Upload release to PyPI\n    runs-on: ubuntu-latest\n    environment: release\n    needs:\n      - release-build\n    permissions:\n      id-token: write # IMPORTANT: this permission is mandatory for trusted publishing\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish package distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n\n  docs-publish:\n    runs-on: ubuntu-latest\n    needs: [\"pypi-publish\"]\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - run: echo \"cache_id=$(date --utc '+%V')\" >> $GITHUB_ENV\n      - uses: actions/cache@v4\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n\n      - run: uv sync --frozen --group docs\n      - run: uv run --frozen --no-sync mkdocs gh-deploy --force\n\n\n--- .github/workflows/pull-request-checks.yml (yml) ---\nname: Pull request checks\n\non:\n  pull_request:\n\njobs:\n  checks:\n    uses: ./.github/workflows/shared.yml\n\n\n--- .github/workflows/shared.yml (yml) ---\nname: Shared Checks\n\non:\n  workflow_call:\n\npermissions:\n  contents: read\n\njobs:\n  pre-commit:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: astral-sh/setup-uv@v5\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - name: Install dependencies\n        run: uv sync --frozen --all-extras --python 3.10\n\n      - uses: pre-commit/action@v3.0.0\n        with:\n          extra_args: --all-files --verbose\n        env:\n          SKIP: no-commit-to-branch\n\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    continue-on-error: true\n    strategy:\n      matrix:\n        python-version: [\"3.10\", \"3.11\", \"3.12\", \"3.13\"]\n        os: [ubuntu-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - name: Install the project\n        run: uv sync --frozen --all-extras --python ${{ matrix.python-version }}\n\n      - name: Run pytest\n        run: uv run --frozen --no-sync pytest\n\n      # This must run last as it modifies the environment!\n      - name: Run pytest with lowest versions\n        run: |\n          uv sync --all-extras --upgrade\n          uv run --no-sync pytest\n        env:\n          UV_RESOLUTION: lowest-direct\n  readme-snippets:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: astral-sh/setup-uv@v5\n        with:\n          enable-cache: true\n          version: 0.7.2\n\n      - name: Install dependencies\n        run: uv sync --frozen --all-extras --python 3.10\n\n      - name: Check README snippets are up to date\n        run: uv run --frozen scripts/update_readme_snippets.py --check\n\n\n--- .pre-commit-config.yaml (yaml) ---\nfail_fast: true\n\nrepos:\n  - repo: https://github.com/pre-commit/mirrors-prettier\n    rev: v3.1.0\n    hooks:\n      - id: prettier\n        types_or: [yaml, json5]\n\n  - repo: https://github.com/igorshubovych/markdownlint-cli\n    rev: v0.45.0\n    hooks:\n      - id: markdownlint\n        args:\n          [\n            \"--fix\",\n            \"--config\",\n            \"pyproject.toml\",\n            \"--configPointer\",\n            \"/tool/markdown/lint\",\n          ]\n        types: [markdown]\n\n  - repo: local\n    hooks:\n      - id: ruff-format\n        name: Ruff Format\n        entry: uv run ruff\n        args: [format]\n        language: system\n        types: [python]\n        pass_filenames: false\n      - id: ruff\n        name: Ruff\n        entry: uv run ruff\n        args: [\"check\", \"--fix\", \"--exit-non-zero-on-fix\"]\n        types: [python]\n        language: system\n        pass_filenames: false\n        exclude: ^README\\.md$\n      - id: pyright\n        name: pyright\n        entry: uv run pyright\n        language: system\n        types: [python]\n        pass_filenames: false\n      - id: uv-lock-check\n        name: Check uv.lock is up to date\n        entry: uv lock --check\n        language: system\n        files: ^(pyproject\\.toml|uv\\.lock)$\n        pass_filenames: false\n      - id: readme-snippets\n        name: Check README snippets are up to date\n        entry: uv run scripts/update_readme_snippets.py --check\n        language: system\n        files: ^(README\\.md|examples/.*\\.py|scripts/update_readme_snippets\\.py)$\n        pass_filenames: false\n\n\n--- CLAUDE.md (md) ---\n# Development Guidelines\n\nThis document contains critical information about working with this codebase. Follow these guidelines precisely.\n\n## Core Development Rules\n\n1. Package Management\n   - ONLY use uv, NEVER pip\n   - Installation: `uv add package`\n   - Running tools: `uv run tool`\n   - Upgrading: `uv add --dev package --upgrade-package package`\n   - FORBIDDEN: `uv pip install`, `@latest` syntax\n\n2. Code Quality\n   - Type hints required for all code\n   - Public APIs must have docstrings\n   - Functions must be focused and small\n   - Follow existing patterns exactly\n   - Line length: 120 chars maximum\n\n3. Testing Requirements\n   - Framework: `uv run --frozen pytest`\n   - Async testing: use anyio, not asyncio\n   - Coverage: test edge cases and errors\n   - New features require tests\n   - Bug fixes require regression tests\n\n- For commits fixing bugs or adding features based on user reports add:\n\n  ```bash\n  git commit --trailer \"Reported-by:<name>\"\n  ```\n\n  Where `<name>` is the name of the user.\n\n- For commits related to a Github issue, add\n\n  ```bash\n  git commit --trailer \"Github-Issue:#<number>\"\n  ```\n\n- NEVER ever mention a `co-authored-by` or similar aspects. In particular, never\n  mention the tool used to create the commit message or PR.\n\n## Pull Requests\n\n- Create a detailed message of what changed. Focus on the high level description of\n  the problem it tries to solve, and how it is solved. Don't go into the specifics of the\n  code unless it adds clarity.\n\n- Always add `jerome3o-anthropic` and `jspahrsummers` as reviewer.\n\n- NEVER ever mention a `co-authored-by` or similar aspects. In particular, never\n  mention the tool used to create the commit message or PR.\n\n## Python Tools\n\n## Code Formatting\n\n1. Ruff\n   - Format: `uv run --frozen ruff format .`\n   - Check: `uv run --frozen ruff check .`\n   - Fix: `uv run --frozen ruff check . --fix`\n   - Critical issues:\n     - Line length (88 chars)\n     - Import sorting (I001)\n     - Unused imports\n   - Line wrapping\n... (content truncated)\n\n--- CODE_OF_CONDUCT.md (md) ---\n# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Con\n... (content truncated)\n\n--- CONTRIBUTING.md (md) ---\n# Contributing\n\nThank you for your interest in contributing to the MCP Python SDK! This document provides guidelines and instructions for contributing.\n\n## Development Setup\n\n1. Make sure you have Python 3.10+ installed\n2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)\n3. Fork the repository\n4. Clone your fork: `git clone https://github.com/YOUR-USERNAME/python-sdk.git`\n5. Install dependencies:\n\n```bash\nuv sync --frozen --all-extras --dev\n```\n\n6. Set up pre-commit hooks:\n\n```bash\nuv tool install pre-commit --with pre-commit-uv --force-reinstall\n```\n\n## Development Workflow\n\n1. Choose the correct branch for your changes:\n   - For bug fixes to a released version: use the latest release branch (e.g. v1.1.x for 1.1.3)\n   - For new features: use the main branch (which will become the next minor/major version)\n   - If unsure, ask in an issue first\n\n2. Create a new branch from your chosen base branch\n\n3. Make your changes\n\n4. Ensure tests pass:\n\n```bash\nuv run pytest\n```\n\n5. Run type checking:\n\n```bash\nuv run pyright\n```\n\n6. Run linting:\n\n```bash\nuv run ruff check .\nuv run ruff format .\n```\n\n7. Update README snippets if you modified example code:\n\n```bash\nuv run scripts/update_readme_snippets.py\n```\n\n8. (Optional) Run pre-commit hooks on all files:\n\n```bash\npre-commit run --all-files\n```\n\n9. Submit a pull request to the same branch you branched from\n\n## Code Style\n\n- We use `ruff` for linting and formatting\n- Follow PEP 8 style guidelines\n- Add type hints to all functions\n- Include docstrings for public APIs\n\n## Pull Request Process\n\n1. Update documentation as needed\n2. Add tests for new functionality\n3. Ensure CI passes\n4. Maintainers will review your code\n5. Address review feedback\n\n## Code of Conduct\n\nPlease note that this project is released with a [Code of Conduct](CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.\n\n## License\n\nBy contributing, you agree that your contributions will be licensed under the MIT L\n... (content truncated)\n\n--- LICENSE (unknown) ---\nMIT License\n\nCopyright (c) 2024 Anthropic, PBC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n--- README.md (md) ---\n# MCP Python SDK\n\n<div align=\"center\">\n\n<strong>Python implementation of the Model Context Protocol (MCP)</strong>\n\n[![PyPI][pypi-badge]][pypi-url]\n[![MIT licensed][mit-badge]][mit-url]\n[![Python Version][python-badge]][python-url]\n[![Documentation][docs-badge]][docs-url]\n[![Specification][spec-badge]][spec-url]\n[![GitHub Discussions][discussions-badge]][discussions-url]\n\n</div>\n\n<!-- omit in toc -->\n## Table of Contents\n\n- [MCP Python SDK](#mcp-python-sdk)\n  - [Overview](#overview)\n  - [Installation](#installation)\n    - [Adding MCP to your python project](#adding-mcp-to-your-python-project)\n    - [Running the standalone MCP development tools](#running-the-standalone-mcp-development-tools)\n  - [Quickstart](#quickstart)\n  - [What is MCP?](#what-is-mcp)\n  - [Core Concepts](#core-concepts)\n    - [Server](#server)\n    - [Resources](#resources)\n    - [Tools](#tools)\n      - [Structured Output](#structured-output)\n    - [Prompts](#prompts)\n    - [Images](#images)\n    - [Context](#context)\n    - [Completions](#completions)\n    - [Elicitation](#elicitation)\n    - [Sampling](#sampling)\n    - [Logging and Notifications](#logging-and-notifications)\n    - [Authentication](#authentication)\n  - [Running Your Server](#running-your-server)\n    - [Development Mode](#development-mode)\n    - [Claude Desktop Integration](#claude-desktop-integration)\n    - [Direct Execution](#direct-execution)\n    - [Mounting to an Existing ASGI Server](#mounting-to-an-existing-asgi-server)\n  - [Advanced Usage](#advanced-usage)\n    - [Low-Level Server](#low-level-server)\n    - [Writing MCP Clients](#writing-mcp-clients)\n    - [Parsing Tool Results](#parsing-tool-results)\n    - [MCP Primitives](#mcp-primitives)\n    - [Server Capabilities](#server-capabilities)\n  - [Documentation](#documentation)\n  - [Contributing](#contributing)\n  - [License](#license)\n\n[pypi-badge]: https://img.shields.io/pypi/v/mcp.svg\n[pypi-url]: https://pypi.org/project/mcp/\n[mit-badge]: https://img.shields.io/pypi/l/mcp.svg\n[mit-ur\n... (content truncated)\n\n--- RELEASE.md (md) ---\n# Release Process\n\n## Bumping Dependencies\n\n1. Change dependency version in `pyproject.toml`\n2. Upgrade lock with `uv lock --resolution lowest-direct`\n\n## Major or Minor Release\n\nCreate a GitHub release via UI with the tag being `vX.Y.Z` where `X.Y.Z` is the version,\nand the release title being the same. Then ask someone to review the release.\n\nThe package version will be set automatically from the tag.\n\n\n--- SECURITY.md (md) ---\n# Security Policy\n\nThank you for helping us keep the SDKs and systems they interact with secure.\n\n## Reporting Security Issues\n\nThis SDK is maintained by [Anthropic](https://www.anthropic.com/) as part of the Model Context Protocol project.\n\nThe security of our systems and user data is Anthropicâ€™s top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.\n\nOur security program is managed on HackerOne and we ask that any validated vulnerability in this functionality be reported through their [submission form](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\n## Vulnerability Disclosure Program\n\nOur Vulnerability Program Guidelines are defined on our [HackerOne program page](https://hackerone.com/anthropic-vdp).\n\n\n--- docs/api.md (md) ---\n::: mcp\n\n\n--- docs/index.md (md) ---\n# MCP Server\n\nThis is the MCP Server implementation in Python.\n\nIt only contains the [API Reference](api.md) for the time being.\n\n\n--- examples/README.md (md) ---\n# Python SDK Examples\n\nThis folders aims to provide simple examples of using the Python SDK. Please refer to the\n[servers repository](https://github.com/modelcontextprotocol/servers)\nfor real-world servers.\n\n\n--- examples/clients/simple-auth-client/README.md (md) ---\n# Simple Auth Client Example\n\nA demonstration of how to use the MCP Python SDK with OAuth authentication over streamable HTTP or SSE transport.\n\n## Features\n\n- OAuth 2.0 authentication with PKCE\n- Support for both StreamableHTTP and SSE transports\n- Interactive command-line interface\n\n## Installation\n\n```bash\ncd examples/clients/simple-auth-client\nuv sync --reinstall \n```\n\n## Usage\n\n### 1. Start an MCP server with OAuth support\n\n```bash\n# Example with mcp-simple-auth\ncd path/to/mcp-simple-auth\nuv run mcp-simple-auth --transport streamable-http --port 3001\n```\n\n### 2. Run the client\n\n```bash\nuv run mcp-simple-auth-client\n\n# Or with custom server URL\nMCP_SERVER_PORT=3001 uv run mcp-simple-auth-client\n\n# Use SSE transport\nMCP_TRANSPORT_TYPE=sse uv run mcp-simple-auth-client\n```\n\n### 3. Complete OAuth flow\n\nThe client will open your browser for authentication. After completing OAuth, you can use commands:\n\n- `list` - List available tools\n- `call <tool_name> [args]` - Call a tool with optional JSON arguments  \n- `quit` - Exit\n\n## Example\n\n```markdown\nðŸ” Simple MCP Auth Client\nConnecting to: http://localhost:3001\n\nPlease visit the following URL to authorize the application:\nhttp://localhost:3001/authorize?response_type=code&client_id=...\n\nâœ… Connected to MCP server at http://localhost:3001\n\nmcp> list\nðŸ“‹ Available tools:\n1. echo - Echo back the input text\n\nmcp> call echo {\"text\": \"Hello, world!\"}\nðŸ”§ Tool 'echo' result:\nHello, world!\n\nmcp> quit\nðŸ‘‹ Goodbye!\n```\n\n## Configuration\n\n- `MCP_SERVER_PORT` - Server URL (default: 8000)\n- `MCP_TRANSPORT_TYPE` - Transport type: `streamable_http` (default) or `sse`\n\n\n--- examples/clients/simple-auth-client/mcp_simple_auth_client/__init__.py (py) ---\n\"\"\"Simple OAuth client for MCP simple-auth server.\"\"\"\n\n\n--- examples/clients/simple-auth-client/mcp_simple_auth_client/main.py (py) ---\n#!/usr/bin/env python3\n\"\"\"\nSimple MCP client example with OAuth authentication support.\n\nThis client connects to an MCP server using streamable HTTP transport with OAuth.\n\n\"\"\"\n\nimport asyncio\nimport os\nimport threading\nimport time\nimport webbrowser\nfrom datetime import timedelta\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom typing import Any\nfrom urllib.parse import parse_qs, urlparse\n\nfrom mcp.client.auth import OAuthClientProvider, TokenStorage\nfrom mcp.client.session import ClientSession\nfrom mcp.client.sse import sse_client\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata, OAuthToken\n\n\nclass InMemoryTokenStorage(TokenStorage):\n    \"\"\"Simple in-memory token storage implementation.\"\"\"\n\n    def __init__(self):\n        self._tokens: OAuthToken | None = None\n        self._client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -> OAuthToken | None:\n        return self._tokens\n\n    async def set_tokens(self, tokens: OAuthToken) -> None:\n        self._tokens = tokens\n\n    async def get_client_info(self) -> OAuthClientInformationFull | None:\n        return self._client_info\n\n    async def set_client_info(self, client_info: OAuthClientInformationFull) -> None:\n        self._client_info = client_info\n\n\nclass CallbackHandler(BaseHTTPRequestHandler):\n    \"\"\"Simple HTTP handler to capture OAuth callback.\"\"\"\n\n    def __init__(self, request, client_address, server, callback_data):\n        \"\"\"Initialize with callback data storage.\"\"\"\n        self.callback_data = callback_data\n        super().__init__(request, client_address, server)\n\n    def do_GET(self):\n        \"\"\"Handle GET request from OAuth redirect.\"\"\"\n        parsed = urlparse(self.path)\n        query_params = parse_qs(parsed.query)\n\n        if \"code\" in query_params:\n            self.callback_data[\"authorization_code\"] = query_params[\"code\"][0]\n            self.callback_data[\"state\"] = \n... (content truncated)\n\n--- examples/clients/simple-auth-client/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-auth-client\"\nversion = \"0.1.0\"\ndescription = \"A simple OAuth client for the MCP simple-auth server\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic\" }]\nkeywords = [\"mcp\", \"oauth\", \"client\", \"auth\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\n    \"click>=8.0.0\",\n    \"mcp>=1.0.0\",\n]\n\n[project.scripts]\nmcp-simple-auth-client = \"mcp_simple_auth_client.main:cli\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_auth_client\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_auth_client\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.379\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n[tool.uv.sources]\nmcp = { path = \"../../../\" }\n\n[[tool.uv.index]]\nurl = \"https://pypi.org/simple\"\n\n\n--- examples/clients/simple-chatbot/README.MD (MD) ---\n# MCP Simple Chatbot\n\nThis example demonstrates how to integrate the Model Context Protocol (MCP) into a simple CLI chatbot. The implementation showcases MCP's flexibility by supporting multiple tools through MCP servers and is compatible with any LLM provider that follows OpenAI API standards.\n\n## Requirements\n\n- Python 3.10\n- `python-dotenv`\n- `requests`\n- `mcp`\n- `uvicorn`\n\n## Installation\n\n1. **Install the dependencies:**\n\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n2. **Set up environment variables:**\n\n   Create a `.env` file in the root directory and add your API key:\n\n   ```plaintext\n   LLM_API_KEY=your_api_key_here\n   ```\n\n   **Note:** The current implementation is configured to use the Groq API endpoint (`https://api.groq.com/openai/v1/chat/completions`) with the `llama-3.2-90b-vision-preview` model. If you plan to use a different LLM provider, you'll need to modify the `LLMClient` class in `main.py` to use the appropriate endpoint URL and model parameters.\n\n3. **Configure servers:**\n\n   The `servers_config.json` follows the same structure as Claude Desktop, allowing for easy integration of multiple servers.\n   Here's an example:\n\n   ```json\n   {\n     \"mcpServers\": {\n       \"sqlite\": {\n         \"command\": \"uvx\",\n         \"args\": [\"mcp-server-sqlite\", \"--db-path\", \"./test.db\"]\n       },\n       \"puppeteer\": {\n         \"command\": \"npx\",\n         \"args\": [\"-y\", \"@modelcontextprotocol/server-puppeteer\"]\n       }\n     }\n   }\n   ```\n\n   Environment variables are supported as well. Pass them as you would with the Claude Desktop App.\n\n   Example:\n\n   ```json\n   {\n     \"mcpServers\": {\n       \"server_name\": {\n         \"command\": \"uvx\",\n         \"args\": [\"mcp-server-name\", \"--additional-args\"],\n         \"env\": {\n           \"API_KEY\": \"your_api_key_here\"\n         }\n       }\n     }\n   }\n   ```\n\n## Usage\n\n1. **Run the client:**\n\n   ```bash\n   python main.py\n   ```\n\n2. **Interact with the assistant:**\n\n   The assistant will automatically detect available tools an\n... (content truncated)\n\n--- examples/clients/simple-chatbot/mcp_simple_chatbot/.env.example (example) ---\nLLM_API_KEY=gsk_1234567890\n\n\n--- examples/clients/simple-chatbot/mcp_simple_chatbot/main.py (py) ---\nimport asyncio\nimport json\nimport logging\nimport os\nimport shutil\nfrom contextlib import AsyncExitStack\nfrom typing import Any\n\nimport httpx\nfrom dotenv import load_dotenv\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\n\n\nclass Configuration:\n    \"\"\"Manages configuration and environment variables for the MCP client.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize configuration with environment variables.\"\"\"\n        self.load_env()\n        self.api_key = os.getenv(\"LLM_API_KEY\")\n\n    @staticmethod\n    def load_env() -> None:\n        \"\"\"Load environment variables from .env file.\"\"\"\n        load_dotenv()\n\n    @staticmethod\n    def load_config(file_path: str) -> dict[str, Any]:\n        \"\"\"Load server configuration from JSON file.\n\n        Args:\n            file_path: Path to the JSON configuration file.\n\n        Returns:\n            Dict containing server configuration.\n\n        Raises:\n            FileNotFoundError: If configuration file doesn't exist.\n            JSONDecodeError: If configuration file is invalid JSON.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            return json.load(f)\n\n    @property\n    def llm_api_key(self) -> str:\n        \"\"\"Get the LLM API key.\n\n        Returns:\n            The API key as a string.\n\n        Raises:\n            ValueError: If the API key is not found in environment variables.\n        \"\"\"\n        if not self.api_key:\n            raise ValueError(\"LLM_API_KEY not found in environment variables\")\n        return self.api_key\n\n\nclass Server:\n    \"\"\"Manages MCP server connections and tool execution.\"\"\"\n\n    def __init__(self, name: str, config: dict[str, Any]) -> None:\n        self.name: str = name\n        self.config: dict[str, Any] = config\n        self.stdio_context: Any | None = None\n        self.session: ClientSession | None = None\n        self.\n... (content truncated)\n\n--- examples/clients/simple-chatbot/mcp_simple_chatbot/requirements.txt (txt) ---\npython-dotenv>=1.0.0\nrequests>=2.31.0\nmcp>=1.0.0\nuvicorn>=0.32.1\n\n--- examples/clients/simple-chatbot/mcp_simple_chatbot/servers_config.json (json) ---\n{\n  \"mcpServers\": {\n    \"sqlite\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-sqlite\", \"--db-path\", \"./test.db\"]\n    },\n    \"puppeteer\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-puppeteer\"]\n    }\n  }\n}\n\n--- examples/clients/simple-chatbot/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-chatbot\"\nversion = \"0.1.0\"\ndescription = \"A simple CLI chatbot using the Model Context Protocol (MCP)\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Edoardo Cilia\" }]\nkeywords = [\"mcp\", \"llm\", \"chatbot\", \"cli\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\n    \"python-dotenv>=1.0.0\",\n    \"requests>=2.31.0\",\n    \"mcp>=1.0.0\",\n    \"uvicorn>=0.32.1\"\n]\n\n[project.scripts]\nmcp-simple-chatbot = \"mcp_simple_chatbot.client:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_chatbot\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_chatbot\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.379\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n\n--- examples/fastmcp/complex_inputs.py (py) ---\n\"\"\"\nFastMCP Complex inputs Example\n\nDemonstrates validation via pydantic with complex models.\n\"\"\"\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"Shrimp Tank\")\n\n\nclass ShrimpTank(BaseModel):\n    class Shrimp(BaseModel):\n        name: Annotated[str, Field(max_length=10)]\n\n    shrimp: list[Shrimp]\n\n\n@mcp.tool()\ndef name_shrimp(\n    tank: ShrimpTank,\n    # You can use pydantic Field in function signatures for validation.\n    extra_names: Annotated[list[str], Field(max_length=10)],\n) -> list[str]:\n    \"\"\"List all shrimp names in the tank\"\"\"\n    return [shrimp.name for shrimp in tank.shrimp] + extra_names\n\n\n--- examples/fastmcp/desktop.py (py) ---\n\"\"\"\nFastMCP Desktop Example\n\nA simple example that exposes the desktop directory as a resource.\n\"\"\"\n\nfrom pathlib import Path\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Demo\")\n\n\n@mcp.resource(\"dir://desktop\")\ndef desktop() -> list[str]:\n    \"\"\"List the files in the user's desktop\"\"\"\n    desktop = Path.home() / \"Desktop\"\n    return [str(f) for f in desktop.iterdir()]\n\n\n@mcp.tool()\ndef sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n--- examples/fastmcp/echo.py (py) ---\n\"\"\"\nFastMCP Echo Server\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo_tool(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return text\n\n\n@mcp.resource(\"echo://static\")\ndef echo_resource() -> str:\n    return \"Echo!\"\n\n\n@mcp.resource(\"echo://{text}\")\ndef echo_template(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return f\"Echo: {text}\"\n\n\n@mcp.prompt(\"echo\")\ndef echo_prompt(text: str) -> str:\n    return text\n\n\n--- examples/fastmcp/memory.py (py) ---\n# /// script\n# dependencies = [\"pydantic-ai-slim[openai]\", \"asyncpg\", \"numpy\", \"pgvector\"]\n# ///\n\n# uv pip install 'pydantic-ai-slim[openai]' asyncpg numpy pgvector\n\n\"\"\"\nRecursive memory system inspired by the human brain's clustering of memories.\nUses OpenAI's 'text-embedding-3-small' model and pgvector for efficient\nsimilarity search.\n\"\"\"\n\nimport asyncio\nimport math\nimport os\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Annotated, Self, TypeVar\n\nimport asyncpg\nimport numpy as np\nfrom openai import AsyncOpenAI\nfrom pgvector.asyncpg import register_vector  # Import register_vector\nfrom pydantic import BaseModel, Field\nfrom pydantic_ai import Agent\n\nfrom mcp.server.fastmcp import FastMCP\n\nMAX_DEPTH = 5\nSIMILARITY_THRESHOLD = 0.7\nDECAY_FACTOR = 0.99\nREINFORCEMENT_FACTOR = 1.1\n\nDEFAULT_LLM_MODEL = \"openai:gpt-4o\"\nDEFAULT_EMBEDDING_MODEL = \"text-embedding-3-small\"\n\nT = TypeVar(\"T\")\n\nmcp = FastMCP(\n    \"memory\",\n    dependencies=[\n        \"pydantic-ai-slim[openai]\",\n        \"asyncpg\",\n        \"numpy\",\n        \"pgvector\",\n    ],\n)\n\nDB_DSN = \"postgresql://postgres:postgres@localhost:54320/memory_db\"\n# reset memory with rm ~/.fastmcp/{USER}/memory/*\nPROFILE_DIR = (Path.home() / \".fastmcp\" / os.environ.get(\"USER\", \"anon\") / \"memory\").resolve()\nPROFILE_DIR.mkdir(parents=True, exist_ok=True)\n\n\ndef cosine_similarity(a: list[float], b: list[float]) -> float:\n    a_array = np.array(a, dtype=np.float64)\n    b_array = np.array(b, dtype=np.float64)\n    return np.dot(a_array, b_array) / (np.linalg.norm(a_array) * np.linalg.norm(b_array))\n\n\nasync def do_ai(\n    user_prompt: str,\n    system_prompt: str,\n    result_type: type[T] | Annotated,\n    deps=None,\n) -> T:\n    agent = Agent(\n        DEFAULT_LLM_MODEL,\n        system_prompt=system_prompt,\n        result_type=result_type,\n    )\n    result = await agent.run(user_prompt, deps=deps)\n    return result.data\n\n\n@dataclass\nclass Deps:\n    openai: AsyncOpenAI\n    pool\n... (content truncated)\n\n--- examples/fastmcp/parameter_descriptions.py (py) ---\n\"\"\"\nFastMCP Example showing parameter descriptions\n\"\"\"\n\nfrom pydantic import Field\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Parameter Descriptions Server\")\n\n\n@mcp.tool()\ndef greet_user(\n    name: str = Field(description=\"The name of the person to greet\"),\n    title: str = Field(description=\"Optional title like Mr/Ms/Dr\", default=\"\"),\n    times: int = Field(description=\"Number of times to repeat the greeting\", default=1),\n) -> str:\n    \"\"\"Greet a user with optional title and repetition\"\"\"\n    greeting = f\"Hello {title + ' ' if title else ''}{name}!\"\n    return \"\\n\".join([greeting] * times)\n\n\n--- examples/fastmcp/readme-quickstart.py (py) ---\nfrom mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n\n# Add an addition tool\n@mcp.tool()\ndef sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n# Add a dynamic greeting resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -> str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n\n\n--- examples/fastmcp/screenshot.py (py) ---\n\"\"\"\nFastMCP Screenshot Example\n\nGive Claude a tool to capture and view screenshots.\n\"\"\"\n\nimport io\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.server.fastmcp.utilities.types import Image\n\n# Create server\nmcp = FastMCP(\"Screenshot Demo\", dependencies=[\"pyautogui\", \"Pillow\"])\n\n\n@mcp.tool()\ndef take_screenshot() -> Image:\n    \"\"\"\n    Take a screenshot of the user's screen and return it as an image. Use\n    this tool anytime the user wants you to look at something they're doing.\n    \"\"\"\n    import pyautogui\n\n    buffer = io.BytesIO()\n\n    # if the file exceeds ~1MB, it will be rejected by Claude\n    screenshot = pyautogui.screenshot()\n    screenshot.convert(\"RGB\").save(buffer, format=\"JPEG\", quality=60, optimize=True)\n    return Image(data=buffer.getvalue(), format=\"jpeg\")\n\n\n--- examples/fastmcp/simple_echo.py (py) ---\n\"\"\"\nFastMCP Echo Server\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return text\n\n\n--- examples/fastmcp/text_me.py (py) ---\n# /// script\n# dependencies = []\n# ///\n\n\"\"\"\nFastMCP Text Me Server\n--------------------------------\nThis defines a simple FastMCP server that sends a text message to a phone number via https://surgemsg.com/.\n\nTo run this example, create a `.env` file with the following values:\n\nSURGE_API_KEY=...\nSURGE_ACCOUNT_ID=...\nSURGE_MY_PHONE_NUMBER=...\nSURGE_MY_FIRST_NAME=...\nSURGE_MY_LAST_NAME=...\n\nVisit https://surgemsg.com/ and click \"Get Started\" to obtain these values.\n\"\"\"\n\nfrom typing import Annotated\n\nimport httpx\nfrom pydantic import BeforeValidator\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nfrom mcp.server.fastmcp import FastMCP\n\n\nclass SurgeSettings(BaseSettings):\n    model_config: SettingsConfigDict = SettingsConfigDict(env_prefix=\"SURGE_\", env_file=\".env\")\n\n    api_key: str\n    account_id: str\n    my_phone_number: Annotated[str, BeforeValidator(lambda v: \"+\" + v if not v.startswith(\"+\") else v)]\n    my_first_name: str\n    my_last_name: str\n\n\n# Create server\nmcp = FastMCP(\"Text me\")\nsurge_settings = SurgeSettings()  # type: ignore\n\n\n@mcp.tool(name=\"textme\", description=\"Send a text message to me\")\ndef text_me(text_content: str) -> str:\n    \"\"\"Send a text message to a phone number via https://surgemsg.com/\"\"\"\n    with httpx.Client() as client:\n        response = client.post(\n            \"https://api.surgemsg.com/messages\",\n            headers={\n                \"Authorization\": f\"Bearer {surge_settings.api_key}\",\n                \"Surge-Account\": surge_settings.account_id,\n                \"Content-Type\": \"application/json\",\n            },\n            json={\n                \"body\": text_content,\n                \"conversation\": {\n                    \"contact\": {\n                        \"first_name\": surge_settings.my_first_name,\n                        \"last_name\": surge_settings.my_last_name,\n                        \"phone_number\": surge_settings.my_phone_number,\n                    }\n                },\n            },\n        )\n        response.rais\n... (content truncated)\n\n--- examples/fastmcp/unicode_example.py (py) ---\n\"\"\"\nExample FastMCP server that uses Unicode characters in various places to help test\nUnicode handling in tools and inspectors.\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP()\n\n\n@mcp.tool(description=\"ðŸŒŸ A tool that uses various Unicode characters in its description: Ã¡ Ã© Ã­ Ã³ Ãº Ã± æ¼¢å­— ðŸŽ‰\")\ndef hello_unicode(name: str = \"ä¸–ç•Œ\", greeting: str = \"Â¡Hola\") -> str:\n    \"\"\"\n    A simple tool that demonstrates Unicode handling in:\n    - Tool description (emojis, accents, CJK characters)\n    - Parameter defaults (CJK characters)\n    - Return values (Spanish punctuation, emojis)\n    \"\"\"\n    return f\"{greeting}, {name}! ðŸ‘‹\"\n\n\n@mcp.tool(description=\"ðŸŽ¨ Tool that returns a list of emoji categories\")\ndef list_emoji_categories() -> list[str]:\n    \"\"\"Returns a list of emoji categories with emoji examples.\"\"\"\n    return [\n        \"ðŸ˜€ Smileys & Emotion\",\n        \"ðŸ‘‹ People & Body\",\n        \"ðŸ¶ Animals & Nature\",\n        \"ðŸŽ Food & Drink\",\n        \"âš½ Activities\",\n        \"ðŸŒ Travel & Places\",\n        \"ðŸ’¡ Objects\",\n        \"â¤ï¸ Symbols\",\n        \"ðŸš© Flags\",\n    ]\n\n\n@mcp.tool(description=\"ðŸ”¤ Tool that returns text in different scripts\")\ndef multilingual_hello() -> str:\n    \"\"\"Returns hello in different scripts and writing systems.\"\"\"\n    return \"\\n\".join(\n        [\n            \"English: Hello!\",\n            \"Spanish: Â¡Hola!\",\n            \"French: Bonjour!\",\n            \"German: GrÃ¼ÃŸ Gott!\",\n            \"Russian: ÐŸÑ€Ð¸Ð²ÐµÑ‚!\",\n            \"Greek: Î“ÎµÎ¹Î± ÏƒÎ±Ï‚!\",\n            \"Hebrew: !×©Ö¸××œ×•Ö¹×\",\n            \"Arabic: !Ù…Ø±Ø­Ø¨Ø§\",\n            \"Hindi: à¤¨à¤®à¤¸à¥à¤¤à¥‡!\",\n            \"Chinese: ä½ å¥½!\",\n            \"Japanese: ã“ã‚“ã«ã¡ã¯!\",\n            \"Korean: ì•ˆë…•í•˜ì„¸ìš”!\",\n            \"Thai: à¸ªà¸§à¸±à¸ªà¸”à¸µ!\",\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    mcp.run()\n\n\n--- examples/fastmcp/weather_structured.py (py) ---\n\"\"\"\nFastMCP Weather Example with Structured Output\n\nDemonstrates how to use structured output with tools to return\nwell-typed, validated data that clients can easily process.\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TypedDict\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import create_connected_server_and_client_session as client_session\n\n# Create server\nmcp = FastMCP(\"Weather Service\")\n\n\n# Example 1: Using a Pydantic model for structured output\nclass WeatherData(BaseModel):\n    \"\"\"Structured weather data response\"\"\"\n\n    temperature: float = Field(description=\"Temperature in Celsius\")\n    humidity: float = Field(description=\"Humidity percentage (0-100)\")\n    condition: str = Field(description=\"Weather condition (sunny, cloudy, rainy, etc.)\")\n    wind_speed: float = Field(description=\"Wind speed in km/h\")\n    location: str = Field(description=\"Location name\")\n    timestamp: datetime = Field(default_factory=datetime.now, description=\"Observation time\")\n\n\n@mcp.tool()\ndef get_weather(city: str) -> WeatherData:\n    \"\"\"Get current weather for a city with full structured data\"\"\"\n    # In a real implementation, this would fetch from a weather API\n    return WeatherData(temperature=22.5, humidity=65.0, condition=\"partly cloudy\", wind_speed=12.3, location=city)\n\n\n# Example 2: Using TypedDict for a simpler structure\nclass WeatherSummary(TypedDict):\n    \"\"\"Simple weather summary\"\"\"\n\n    city: str\n    temp_c: float\n    description: str\n\n\n@mcp.tool()\ndef get_weather_summary(city: str) -> WeatherSummary:\n    \"\"\"Get a brief weather summary for a city\"\"\"\n    return WeatherSummary(city=city, temp_c=22.5, description=\"Partly cloudy with light breeze\")\n\n\n# Example 3: Using dict[str, Any] for flexible schemas\n@mcp.tool()\ndef get_weather_metrics(cities: list[str]) -> dict[str, dict[str, float]]:\n    \"\"\"Get weather metrics for multiple cities\n\n    R\n... (content truncated)\n\n--- examples/servers/simple-auth/README.md (md) ---\n# MCP OAuth Authentication Demo\n\nThis example demonstrates OAuth 2.0 authentication with the Model Context Protocol using **separate Authorization Server (AS) and Resource Server (RS)** to comply with the new RFC 9728 specification.\n\n---\n\n## Running the Servers\n\n### Step 1: Start Authorization Server\n\n```bash\n# Navigate to the simple-auth directory\ncd examples/servers/simple-auth\n\n# Start Authorization Server on port 9000\nuv run mcp-simple-auth-as --port=9000\n```\n\n**What it provides:**\n\n- OAuth 2.0 flows (registration, authorization, token exchange)\n- Simple credential-based authentication (no external provider needed)  \n- Token introspection endpoint for Resource Servers (`/introspect`)\n\n---\n\n### Step 2: Start Resource Server (MCP Server)\n\n```bash\n# In another terminal, navigate to the simple-auth directory\ncd examples/servers/simple-auth\n\n# Start Resource Server on port 8001, connected to Authorization Server\nuv run mcp-simple-auth-rs --port=8001 --auth-server=http://localhost:9000  --transport=streamable-http\n\n# With RFC 8707 strict resource validation (recommended for production)\nuv run mcp-simple-auth-rs --port=8001 --auth-server=http://localhost:9000  --transport=streamable-http --oauth-strict\n\n```\n\n### Step 3: Test with Client\n\n```bash\ncd examples/clients/simple-auth-client\n# Start client with streamable HTTP\nMCP_SERVER_PORT=8001 MCP_TRANSPORT_TYPE=streamable_http uv run mcp-simple-auth-client\n```\n\n## How It Works\n\n### RFC 9728 Discovery\n\n**Client â†’ Resource Server:**\n\n```bash\ncurl http://localhost:8001/.well-known/oauth-protected-resource\n```\n\n```json\n{\n  \"resource\": \"http://localhost:8001\",\n  \"authorization_servers\": [\"http://localhost:9000\"]\n}\n```\n\n**Client â†’ Authorization Server:**\n\n```bash\ncurl http://localhost:9000/.well-known/oauth-authorization-server\n```\n\n```json\n{\n  \"issuer\": \"http://localhost:9000\",\n  \"authorization_endpoint\": \"http://localhost:9000/authorize\",\n  \"token_endpoint\": \"http://localhost:9000/token\"\n}\n```\n\n## Legacy MCP Server as Authori\n... (content truncated)\n\n--- examples/servers/simple-auth/mcp_simple_auth/__init__.py (py) ---\n\"\"\"Simple MCP server with GitHub OAuth authentication.\"\"\"\n\n\n--- examples/servers/simple-auth/mcp_simple_auth/__main__.py (py) ---\n\"\"\"Main entry point for simple MCP server with GitHub OAuth authentication.\"\"\"\n\nimport sys\n\nfrom mcp_simple_auth.server import main\n\nsys.exit(main())  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-auth/mcp_simple_auth/auth_server.py (py) ---\n\"\"\"\nAuthorization Server for MCP Split Demo.\n\nThis server handles OAuth flows, client registration, and token issuance.\nCan be replaced with enterprise authorization servers like Auth0, Entra ID, etc.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\n\nimport click\nfrom pydantic import AnyHttpUrl, BaseModel\nfrom starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import Route\nfrom uvicorn import Config, Server\n\nfrom mcp.server.auth.routes import cors_middleware, create_auth_routes\nfrom mcp.server.auth.settings import AuthSettings, ClientRegistrationOptions\n\nfrom .simple_auth_provider import SimpleAuthSettings, SimpleOAuthProvider\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuthServerSettings(BaseModel):\n    \"\"\"Settings for the Authorization Server.\"\"\"\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 9000\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:9000\")\n    auth_callback_path: str = \"http://localhost:9000/login/callback\"\n\n\nclass SimpleAuthProvider(SimpleOAuthProvider):\n    \"\"\"\n    Authorization Server provider with simple demo authentication.\n\n    This provider:\n    1. Issues MCP tokens after simple credential authentication\n    2. Stores token state for introspection by Resource Servers\n    \"\"\"\n\n    def __init__(self, auth_settings: SimpleAuthSettings, auth_callback_path: str, server_url: str):\n        super().__init__(auth_settings, auth_callback_path, server_url)\n\n\ndef create_authorization_server(server_settings: AuthServerSettings, auth_settings: SimpleAuthSettings) -> Starlette:\n    \"\"\"Create the Authorization Server application.\"\"\"\n    oauth_provider = SimpleAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n  \n... (content truncated)\n\n--- examples/servers/simple-auth/mcp_simple_auth/legacy_as_server.py (py) ---\n\"\"\"\nLegacy Combined Authorization Server + Resource Server for MCP.\n\nThis server implements the old spec where MCP servers could act as both AS and RS.\nUsed for backwards compatibility testing with the new split AS/RS architecture.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport datetime\nimport logging\nfrom typing import Any, Literal\n\nimport click\nfrom pydantic import AnyHttpUrl, BaseModel\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom mcp.server.auth.settings import AuthSettings, ClientRegistrationOptions\nfrom mcp.server.fastmcp.server import FastMCP\n\nfrom .simple_auth_provider import SimpleAuthSettings, SimpleOAuthProvider\n\nlogger = logging.getLogger(__name__)\n\n\nclass ServerSettings(BaseModel):\n    \"\"\"Settings for the simple auth MCP server.\"\"\"\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 8000\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:8000\")\n    auth_callback_path: str = \"http://localhost:8000/login/callback\"\n\n\nclass LegacySimpleOAuthProvider(SimpleOAuthProvider):\n    \"\"\"Simple OAuth provider for legacy MCP server.\"\"\"\n\n    def __init__(self, auth_settings: SimpleAuthSettings, auth_callback_path: str, server_url: str):\n        super().__init__(auth_settings, auth_callback_path, server_url)\n\n\ndef create_simple_mcp_server(server_settings: ServerSettings, auth_settings: SimpleAuthSettings) -> FastMCP:\n    \"\"\"Create a simple FastMCP server with simple authentication.\"\"\"\n    oauth_provider = LegacySimpleOAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n    mcp_auth_settings = AuthSettings(\n        issuer_url=server_settings.server_url,\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[auth_settings.mcp_scope],\n            default_scopes=[auth_setti\n... (content truncated)\n\n--- examples/servers/simple-auth/mcp_simple_auth/server.py (py) ---\n\"\"\"\nMCP Resource Server with Token Introspection.\n\nThis server validates tokens via Authorization Server introspection and serves MCP resources.\nDemonstrates RFC 9728 Protected Resource Metadata for AS/RS separation.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\"\"\"\n\nimport datetime\nimport logging\nfrom typing import Any, Literal\n\nimport click\nfrom pydantic import AnyHttpUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nfrom mcp.server.auth.settings import AuthSettings\nfrom mcp.server.fastmcp.server import FastMCP\n\nfrom .token_verifier import IntrospectionTokenVerifier\n\nlogger = logging.getLogger(__name__)\n\n\nclass ResourceServerSettings(BaseSettings):\n    \"\"\"Settings for the MCP Resource Server.\"\"\"\n\n    model_config = SettingsConfigDict(env_prefix=\"MCP_RESOURCE_\")\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 8001\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:8001\")\n\n    # Authorization Server settings\n    auth_server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:9000\")\n    auth_server_introspection_endpoint: str = \"http://localhost:9000/introspect\"\n    # No user endpoint needed - we get user data from token introspection\n\n    # MCP settings\n    mcp_scope: str = \"user\"\n\n    # RFC 8707 resource validation\n    oauth_strict: bool = False\n\n    def __init__(self, **data):\n        \"\"\"Initialize settings with values from environment variables.\"\"\"\n        super().__init__(**data)\n\n\ndef create_resource_server(settings: ResourceServerSettings) -> FastMCP:\n    \"\"\"\n    Create MCP Resource Server with token introspection.\n\n    This server:\n    1. Provides protected resource metadata (RFC 9728)\n    2. Validates tokens via Authorization Server introspection\n    3. Serves MCP tools and resources\n    \"\"\"\n    # Create token verifier for introspection with RFC 8707 resource validation\n    token_verifier = IntrospectionTokenVerifier(\n        introspection_endpoint=setting\n... (content truncated)\n\n--- examples/servers/simple-auth/mcp_simple_auth/simple_auth_provider.py (py) ---\n\"\"\"\nSimple OAuth provider for MCP servers.\n\nThis module contains a basic OAuth implementation using hardcoded user credentials\nfor demonstration purposes. No external authentication provider is required.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport logging\nimport secrets\nimport time\nfrom typing import Any\n\nfrom pydantic import AnyHttpUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, RedirectResponse, Response\n\nfrom mcp.server.auth.provider import (\n    AccessToken,\n    AuthorizationCode,\n    AuthorizationParams,\n    OAuthAuthorizationServerProvider,\n    RefreshToken,\n    construct_redirect_uri,\n)\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthToken\n\nlogger = logging.getLogger(__name__)\n\n\nclass SimpleAuthSettings(BaseSettings):\n    \"\"\"Simple OAuth settings for demo purposes.\"\"\"\n\n    model_config = SettingsConfigDict(env_prefix=\"MCP_\")\n\n    # Demo user credentials\n    demo_username: str = \"demo_user\"\n    demo_password: str = \"demo_password\"\n\n    # MCP OAuth scope\n    mcp_scope: str = \"user\"\n\n\nclass SimpleOAuthProvider(OAuthAuthorizationServerProvider):\n    \"\"\"\n    Simple OAuth provider for demo purposes.\n\n    This provider handles the OAuth flow by:\n    1. Providing a simple login form for demo credentials\n    2. Issuing MCP tokens after successful authentication\n    3. Maintaining token state for introspection\n    \"\"\"\n\n    def __init__(self, settings: SimpleAuthSettings, auth_callback_url: str, server_url: str):\n        self.settings = settings\n        self.auth_callback_url = auth_callback_url\n        self.server_url = server_url\n        self.clients: dict[str, OAuthClientInformationFull] = {}\n        self.auth_codes: dict[str, AuthorizationCode] = {}\n        self.tokens: dict[str, AccessToken] = {}\n        self.state_mapping: d\n... (content truncated)\n\n--- examples/servers/simple-auth/mcp_simple_auth/token_verifier.py (py) ---\n\"\"\"Example token verifier implementation using OAuth 2.0 Token Introspection (RFC 7662).\"\"\"\n\nimport logging\n\nfrom mcp.server.auth.provider import AccessToken, TokenVerifier\nfrom mcp.shared.auth_utils import check_resource_allowed, resource_url_from_server_url\n\nlogger = logging.getLogger(__name__)\n\n\nclass IntrospectionTokenVerifier(TokenVerifier):\n    \"\"\"Example token verifier that uses OAuth 2.0 Token Introspection (RFC 7662).\n\n    This is a simple example implementation for demonstration purposes.\n    Production implementations should consider:\n    - Connection pooling and reuse\n    - More sophisticated error handling\n    - Rate limiting and retry logic\n    - Comprehensive configuration options\n    \"\"\"\n\n    def __init__(\n        self,\n        introspection_endpoint: str,\n        server_url: str,\n        validate_resource: bool = False,\n    ):\n        self.introspection_endpoint = introspection_endpoint\n        self.server_url = server_url\n        self.validate_resource = validate_resource\n        self.resource_url = resource_url_from_server_url(server_url)\n\n    async def verify_token(self, token: str) -> AccessToken | None:\n        \"\"\"Verify token via introspection endpoint.\"\"\"\n        import httpx\n\n        # Validate URL to prevent SSRF attacks\n        if not self.introspection_endpoint.startswith((\"https://\", \"http://localhost\", \"http://127.0.0.1\")):\n            logger.warning(f\"Rejecting introspection endpoint with unsafe scheme: {self.introspection_endpoint}\")\n            return None\n\n        # Configure secure HTTP client\n        timeout = httpx.Timeout(10.0, connect=5.0)\n        limits = httpx.Limits(max_connections=10, max_keepalive_connections=5)\n\n        async with httpx.AsyncClient(\n            timeout=timeout,\n            limits=limits,\n            verify=True,  # Enforce SSL verification\n        ) as client:\n            try:\n                response = await client.post(\n                    self.introspection_endpoint,\n                    data={\"token\": \n... (content truncated)\n\n--- examples/servers/simple-auth/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-auth\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server demonstrating OAuth authentication\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nlicense = { text = \"MIT\" }\ndependencies = [\n    \"anyio>=4.5\",\n    \"click>=8.1.0\",\n    \"httpx>=0.27\",\n    \"mcp\",\n    \"pydantic>=2.0\",\n    \"pydantic-settings>=2.5.2\",\n    \"sse-starlette>=1.6.1\",\n    \"uvicorn>=0.23.1; sys_platform != 'emscripten'\",\n]\n\n[project.scripts]\nmcp-simple-auth-rs = \"mcp_simple_auth.server:main\"\nmcp-simple-auth-as = \"mcp_simple_auth.auth_server:main\"\nmcp-simple-auth-legacy = \"mcp_simple_auth.legacy_as_server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_auth\"]\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.391\", \"pytest>=8.3.4\", \"ruff>=0.8.5\"]\n\n\n--- examples/servers/simple-prompt/README.md (md) ---\n# MCP Simple Prompt\n\nA simple MCP server that exposes a customizable prompt template with optional context and topic parameters.\n\n## Usage\n\nStart the server using either stdio (default) or SSE transport:\n\n```bash\n# Using stdio transport (default)\nuv run mcp-simple-prompt\n\n# Using SSE transport on custom port\nuv run mcp-simple-prompt --transport sse --port 8000\n```\n\nThe server exposes a prompt named \"simple\" that accepts two optional arguments:\n\n- `context`: Additional context to consider\n- `topic`: Specific topic to focus on\n\n## Example\n\nUsing the MCP client, you can retrieve the prompt like this using the STDIO transport:\n\n```python\nimport asyncio\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import StdioServerParameters, stdio_client\n\n\nasync def main():\n    async with stdio_client(\n        StdioServerParameters(command=\"uv\", args=[\"run\", \"mcp-simple-prompt\"])\n    ) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # List available prompts\n            prompts = await session.list_prompts()\n            print(prompts)\n\n            # Get the prompt with arguments\n            prompt = await session.get_prompt(\n                \"simple\",\n                {\n                    \"context\": \"User is a software developer\",\n                    \"topic\": \"Python async programming\",\n                },\n            )\n            print(prompt)\n\n\nasyncio.run(main())\n```\n\n\n--- examples/servers/simple-prompt/mcp_simple_prompt/__init__.py (py) ---\n\n\n\n--- examples/servers/simple-prompt/mcp_simple_prompt/__main__.py (py) ---\nimport sys\n\nfrom .server import main\n\nsys.exit(main())  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-prompt/mcp_simple_prompt/server.py (py) ---\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\n\n\ndef create_messages(\n    context: str | None = None, topic: str | None = None\n) -> list[types.PromptMessage]:\n    \"\"\"Create the messages for the prompt.\"\"\"\n    messages = []\n\n    # Add context if provided\n    if context:\n        messages.append(\n            types.PromptMessage(\n                role=\"user\",\n                content=types.TextContent(\n                    type=\"text\", text=f\"Here is some relevant context: {context}\"\n                ),\n            )\n        )\n\n    # Add the main prompt\n    prompt = \"Please help me with \"\n    if topic:\n        prompt += f\"the following topic: {topic}\"\n    else:\n        prompt += \"whatever questions I may have.\"\n\n    messages.append(\n        types.PromptMessage(\n            role=\"user\", content=types.TextContent(type=\"text\", text=prompt)\n        )\n    )\n\n    return messages\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -> int:\n    app = Server(\"mcp-simple-prompt\")\n\n    @app.list_prompts()\n    async def list_prompts() -> list[types.Prompt]:\n        return [\n            types.Prompt(\n                name=\"simple\",\n                title=\"Simple Assistant Prompt\",\n                description=\"A simple prompt that can take optional context and topic \"\n                \"arguments\",\n                arguments=[\n                    types.PromptArgument(\n                        name=\"context\",\n                        description=\"Additional context to consider\",\n                        required=False,\n                    ),\n                    types.PromptArgument(\n                        name=\"topic\",\n                        description=\"Specific topic to focus on\",\n                        required=False,\n                    ),\n           \n... (content truncated)\n\n--- examples/servers/simple-prompt/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-prompt\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server exposing a customizable prompt\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nmaintainers = [\n    { name = \"David Soria Parra\", email = \"davidsp@anthropic.com\" },\n    { name = \"Justin Spahr-Summers\", email = \"justin@anthropic.com\" },\n]\nkeywords = [\"mcp\", \"llm\", \"automation\", \"web\", \"fetch\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\"anyio>=4.5\", \"click>=8.1.0\", \"httpx>=0.27\", \"mcp\"]\n\n[project.scripts]\nmcp-simple-prompt = \"mcp_simple_prompt.server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_prompt\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_prompt\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.378\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n\n--- examples/servers/simple-resource/README.md (md) ---\n# MCP Simple Resource\n\nA simple MCP server that exposes sample text files as resources.\n\n## Usage\n\nStart the server using either stdio (default) or SSE transport:\n\n```bash\n# Using stdio transport (default)\nuv run mcp-simple-resource\n\n# Using SSE transport on custom port\nuv run mcp-simple-resource --transport sse --port 8000\n```\n\nThe server exposes some basic text file resources that can be read by clients.\n\n## Example\n\nUsing the MCP client, you can retrieve resources like this using the STDIO transport:\n\n```python\nimport asyncio\nfrom mcp.types import AnyUrl\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import StdioServerParameters, stdio_client\n\n\nasync def main():\n    async with stdio_client(\n        StdioServerParameters(command=\"uv\", args=[\"run\", \"mcp-simple-resource\"])\n    ) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # List available resources\n            resources = await session.list_resources()\n            print(resources)\n\n            # Get a specific resource\n            resource = await session.read_resource(AnyUrl(\"file:///greeting.txt\"))\n            print(resource)\n\n\nasyncio.run(main())\n\n```\n\n\n--- examples/servers/simple-resource/mcp_simple_resource/__init__.py (py) ---\n\n\n\n--- examples/servers/simple-resource/mcp_simple_resource/__main__.py (py) ---\nimport sys\n\nfrom .server import main\n\nsys.exit(main())  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-resource/mcp_simple_resource/server.py (py) ---\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom pydantic import AnyUrl, FileUrl\n\nSAMPLE_RESOURCES = {\n    \"greeting\": {\n        \"content\": \"Hello! This is a sample text resource.\",\n        \"title\": \"Welcome Message\",\n    },\n    \"help\": {\n        \"content\": \"This server provides a few sample text resources for testing.\",\n        \"title\": \"Help Documentation\",\n    },\n    \"about\": {\n        \"content\": \"This is the simple-resource MCP server implementation.\",\n        \"title\": \"About This Server\",\n    },\n}\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -> int:\n    app = Server(\"mcp-simple-resource\")\n\n    @app.list_resources()\n    async def list_resources() -> list[types.Resource]:\n        return [\n            types.Resource(\n                uri=FileUrl(f\"file:///{name}.txt\"),\n                name=name,\n                title=SAMPLE_RESOURCES[name][\"title\"],\n                description=f\"A sample text resource named {name}\",\n                mimeType=\"text/plain\",\n            )\n            for name in SAMPLE_RESOURCES.keys()\n        ]\n\n    @app.read_resource()\n    async def read_resource(uri: AnyUrl) -> str | bytes:\n        if uri.path is None:\n            raise ValueError(f\"Invalid resource path: {uri}\")\n        name = uri.path.replace(\".txt\", \"\").lstrip(\"/\")\n\n        if name not in SAMPLE_RESOURCES:\n            raise ValueError(f\"Unknown resource: {uri}\")\n\n        return SAMPLE_RESOURCES[name][\"content\"]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request):\n  \n... (content truncated)\n\n--- examples/servers/simple-resource/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-resource\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server exposing sample text resources\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nmaintainers = [\n    { name = \"David Soria Parra\", email = \"davidsp@anthropic.com\" },\n    { name = \"Justin Spahr-Summers\", email = \"justin@anthropic.com\" },\n]\nkeywords = [\"mcp\", \"llm\", \"automation\", \"web\", \"fetch\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\"anyio>=4.5\", \"click>=8.1.0\", \"httpx>=0.27\", \"mcp\"]\n\n[project.scripts]\nmcp-simple-resource = \"mcp_simple_resource.server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_resource\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_resource\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.378\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n\n--- examples/servers/simple-streamablehttp-stateless/README.md (md) ---\n# MCP Simple StreamableHttp Stateless Server Example\n\nA stateless MCP server example demonstrating the StreamableHttp transport without maintaining session state. This example is ideal for understanding how to deploy MCP servers in multi-node environments where requests can be routed to any instance.\n\n## Features\n\n- Uses the StreamableHTTP transport in stateless mode (mcp_session_id=None)\n- Each request creates a new ephemeral connection\n- No session state maintained between requests\n- Task lifecycle scoped to individual requests\n- Suitable for deployment in multi-node environments\n\n## Usage\n\nStart the server:\n\n```bash\n# Using default port 3000\nuv run mcp-simple-streamablehttp-stateless\n\n# Using custom port\nuv run mcp-simple-streamablehttp-stateless --port 3000\n\n# Custom logging level\nuv run mcp-simple-streamablehttp-stateless --log-level DEBUG\n\n# Enable JSON responses instead of SSE streams\nuv run mcp-simple-streamablehttp-stateless --json-response\n```\n\nThe server exposes a tool named \"start-notification-stream\" that accepts three arguments:\n\n- `interval`: Time between notifications in seconds (e.g., 1.0)\n- `count`: Number of notifications to send (e.g., 5)\n- `caller`: Identifier string for the caller\n\n## Client\n\nYou can connect to this server using an HTTP client. For now, only the TypeScript SDK has streamable HTTP client examples, or you can use [Inspector](https://github.com/modelcontextprotocol/inspector) for testing.\n\n\n--- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/__init__.py (py) ---\n\n\n--- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/__main__.py (py) ---\nfrom .server import main\n\nif __name__ == \"__main__\":\n    # Click will handle CLI arguments\n    import sys\n\n    sys.exit(main())  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-streamablehttp-stateless/mcp_simple_streamablehttp_stateless/server.py (py) ---\nimport contextlib\nimport logging\nfrom collections.abc import AsyncIterator\n\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.types import Receive, Scope, Send\n\nlogger = logging.getLogger(__name__)\n\n\n@click.command()\n@click.option(\"--port\", default=3000, help=\"Port to listen on for HTTP\")\n@click.option(\n    \"--log-level\",\n    default=\"INFO\",\n    help=\"Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n)\n@click.option(\n    \"--json-response\",\n    is_flag=True,\n    default=False,\n    help=\"Enable JSON responses instead of SSE streams\",\n)\ndef main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -> int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-stateless-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict) -> list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=f\"Notification {i + 1}/{count} from caller: {caller}\",\n                logger=\"notification_stream\",\n                related_request_id=ctx.request_id,\n            )\n            if i < count - 1:  # Don't wait after the last notification\n                await anyio.sleep(interval)\n\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=(\n                    f\"Sent {count} notifications with {i\n... (content truncated)\n\n--- examples/servers/simple-streamablehttp-stateless/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-streamablehttp-stateless\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server exposing a StreamableHttp transport in stateless mode\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nkeywords = [\"mcp\", \"llm\", \"automation\", \"web\", \"fetch\", \"http\", \"streamable\", \"stateless\"]\nlicense = { text = \"MIT\" }\ndependencies = [\"anyio>=4.5\", \"click>=8.1.0\", \"httpx>=0.27\", \"mcp\", \"starlette\", \"uvicorn\"]\n\n[project.scripts]\nmcp-simple-streamablehttp-stateless = \"mcp_simple_streamablehttp_stateless.server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_streamablehttp_stateless\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_streamablehttp_stateless\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.378\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n--- examples/servers/simple-streamablehttp/README.md (md) ---\n# MCP Simple StreamableHttp Server Example\n\nA simple MCP server example demonstrating the StreamableHttp transport, which enables HTTP-based communication with MCP servers using streaming.\n\n## Features\n\n- Uses the StreamableHTTP transport for server-client communication\n- Supports REST API operations (POST, GET, DELETE) for `/mcp` endpoint\n- Task management with anyio task groups\n- Ability to send multiple notifications over time to the client\n- Proper resource cleanup and lifespan management\n- Resumability support via InMemoryEventStore\n\n## Usage\n\nStart the server on the default or custom port:\n\n```bash\n\n# Using custom port\nuv run mcp-simple-streamablehttp --port 3000\n\n# Custom logging level\nuv run mcp-simple-streamablehttp --log-level DEBUG\n\n# Enable JSON responses instead of SSE streams\nuv run mcp-simple-streamablehttp --json-response\n```\n\nThe server exposes a tool named \"start-notification-stream\" that accepts three arguments:\n\n- `interval`: Time between notifications in seconds (e.g., 1.0)\n- `count`: Number of notifications to send (e.g., 5)\n- `caller`: Identifier string for the caller\n\n## Resumability Support\n\nThis server includes resumability support through the InMemoryEventStore. This enables clients to:\n\n- Reconnect to the server after a disconnection\n- Resume event streaming from where they left off using the Last-Event-ID header\n\nThe server will:\n\n- Generate unique event IDs for each SSE message\n- Store events in memory for later replay\n- Replay missed events when a client reconnects with a Last-Event-ID header\n\nNote: The InMemoryEventStore is designed for demonstration purposes only. For production use, consider implementing a persistent storage solution.\n\n## Client\n\nYou can connect to this server using an HTTP client, for now only Typescript SDK has streamable HTTP client examples or you can use [Inspector](https://github.com/modelcontextprotocol/inspector)\n\n\n--- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/__init__.py (py) ---\n\n\n--- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/__main__.py (py) ---\nfrom .server import main\n\nif __name__ == \"__main__\":\n    main()  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/event_store.py (py) ---\n\"\"\"\nIn-memory event store for demonstrating resumability functionality.\n\nThis is a simple implementation intended for examples and testing,\nnot for production use where a persistent storage solution would be more appropriate.\n\"\"\"\n\nimport logging\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom uuid import uuid4\n\nfrom mcp.server.streamable_http import (\n    EventCallback,\n    EventId,\n    EventMessage,\n    EventStore,\n    StreamId,\n)\nfrom mcp.types import JSONRPCMessage\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass EventEntry:\n    \"\"\"\n    Represents an event entry in the event store.\n    \"\"\"\n\n    event_id: EventId\n    stream_id: StreamId\n    message: JSONRPCMessage\n\n\nclass InMemoryEventStore(EventStore):\n    \"\"\"\n    Simple in-memory implementation of the EventStore interface for resumability.\n    This is primarily intended for examples and testing, not for production use\n    where a persistent storage solution would be more appropriate.\n\n    This implementation keeps only the last N events per stream for memory efficiency.\n    \"\"\"\n\n    def __init__(self, max_events_per_stream: int = 100):\n        \"\"\"Initialize the event store.\n\n        Args:\n            max_events_per_stream: Maximum number of events to keep per stream\n        \"\"\"\n        self.max_events_per_stream = max_events_per_stream\n        # for maintaining last N events per stream\n        self.streams: dict[StreamId, deque[EventEntry]] = {}\n        # event_id -> EventEntry for quick lookup\n        self.event_index: dict[EventId, EventEntry] = {}\n\n    async def store_event(\n        self, stream_id: StreamId, message: JSONRPCMessage\n    ) -> EventId:\n        \"\"\"Stores an event with a generated event ID.\"\"\"\n        event_id = str(uuid4())\n        event_entry = EventEntry(\n            event_id=event_id, stream_id=stream_id, message=message\n        )\n\n        # Get or create deque for this stream\n        if stream_id not in self.streams:\n            self.streams[stream_id] = deque(ma\n... (content truncated)\n\n--- examples/servers/simple-streamablehttp/mcp_simple_streamablehttp/server.py (py) ---\nimport contextlib\nimport logging\nfrom collections.abc import AsyncIterator\n\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom pydantic import AnyUrl\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.types import Receive, Scope, Send\n\nfrom .event_store import InMemoryEventStore\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\n@click.command()\n@click.option(\"--port\", default=3000, help=\"Port to listen on for HTTP\")\n@click.option(\n    \"--log-level\",\n    default=\"INFO\",\n    help=\"Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n)\n@click.option(\n    \"--json-response\",\n    is_flag=True,\n    default=False,\n    help=\"Enable JSON responses instead of SSE streams\",\n)\ndef main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -> int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict) -> list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            # Include more detailed message for resumability demonstration\n            notification_msg = (\n                f\"[{i + 1}/{count}] Event from '{caller}' - \"\n                f\"Use Last-Event-ID to resume if disconnected\"\n            )\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=notification_msg,\n                logger=\"notification_stream\",\n                # Associates this notificatio\n... (content truncated)\n\n--- examples/servers/simple-streamablehttp/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-streamablehttp\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server exposing a StreamableHttp transport for testing\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nkeywords = [\"mcp\", \"llm\", \"automation\", \"web\", \"fetch\", \"http\", \"streamable\"]\nlicense = { text = \"MIT\" }\ndependencies = [\"anyio>=4.5\", \"click>=8.1.0\", \"httpx>=0.27\", \"mcp\", \"starlette\", \"uvicorn\"]\n\n[project.scripts]\nmcp-simple-streamablehttp = \"mcp_simple_streamablehttp.server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_streamablehttp\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_streamablehttp\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.378\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n--- examples/servers/simple-tool/README.md (md) ---\n\nA simple MCP server that exposes a website fetching tool.\n\n## Usage\n\nStart the server using either stdio (default) or SSE transport:\n\n```bash\n# Using stdio transport (default)\nuv run mcp-simple-tool\n\n# Using SSE transport on custom port\nuv run mcp-simple-tool --transport sse --port 8000\n```\n\nThe server exposes a tool named \"fetch\" that accepts one required argument:\n\n- `url`: The URL of the website to fetch\n\n## Example\n\nUsing the MCP client, you can use the tool like this using the STDIO transport:\n\n```python\nimport asyncio\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import StdioServerParameters, stdio_client\n\n\nasync def main():\n    async with stdio_client(\n        StdioServerParameters(command=\"uv\", args=[\"run\", \"mcp-simple-tool\"])\n    ) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # List available tools\n            tools = await session.list_tools()\n            print(tools)\n\n            # Call the fetch tool\n            result = await session.call_tool(\"fetch\", {\"url\": \"https://example.com\"})\n            print(result)\n\n\nasyncio.run(main())\n\n```\n\n\n--- examples/servers/simple-tool/mcp_simple_tool/__init__.py (py) ---\n\n\n\n--- examples/servers/simple-tool/mcp_simple_tool/__main__.py (py) ---\nimport sys\n\nfrom .server import main\n\nsys.exit(main())  # type: ignore[call-arg]\n\n\n--- examples/servers/simple-tool/mcp_simple_tool/server.py (py) ---\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.shared._httpx_utils import create_mcp_http_client\n\n\nasync def fetch_website(\n    url: str,\n) -> list[types.ContentBlock]:\n    headers = {\n        \"User-Agent\": \"MCP Test Server (github.com/modelcontextprotocol/python-sdk)\"\n    }\n    async with create_mcp_http_client(headers=headers) as client:\n        response = await client.get(url)\n        response.raise_for_status()\n        return [types.TextContent(type=\"text\", text=response.text)]\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -> int:\n    app = Server(\"mcp-website-fetcher\")\n\n    @app.call_tool()\n    async def fetch_tool(name: str, arguments: dict) -> list[types.ContentBlock]:\n        if name != \"fetch\":\n            raise ValueError(f\"Unknown tool: {name}\")\n        if \"url\" not in arguments:\n            raise ValueError(\"Missing required argument 'url'\")\n        return await fetch_website(arguments[\"url\"])\n\n    @app.list_tools()\n    async def list_tools() -> list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"fetch\",\n                title=\"Website Fetcher\",\n                description=\"Fetches a website and returns its content\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"url\"],\n                    \"properties\": {\n                        \"url\": {\n                            \"type\": \"string\",\n                            \"description\": \"URL to fetch\",\n                        }\n                    },\n                },\n            )\n        ]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n       \n... (content truncated)\n\n--- examples/servers/simple-tool/pyproject.toml (toml) ---\n[project]\nname = \"mcp-simple-tool\"\nversion = \"0.1.0\"\ndescription = \"A simple MCP server exposing a website fetching tool\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nmaintainers = [\n    { name = \"David Soria Parra\", email = \"davidsp@anthropic.com\" },\n    { name = \"Justin Spahr-Summers\", email = \"justin@anthropic.com\" },\n]\nkeywords = [\"mcp\", \"llm\", \"automation\", \"web\", \"fetch\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\"anyio>=4.5\", \"click>=8.1.0\", \"httpx>=0.27\", \"mcp\"]\n\n[project.scripts]\nmcp-simple-tool = \"mcp_simple_tool.server:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_tool\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_tool\"]\nvenvPath = \".\"\nvenv = \".venv\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\"]\nignore = []\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py310\"\n\n[tool.uv]\ndev-dependencies = [\"pyright>=1.1.378\", \"pytest>=8.3.3\", \"ruff>=0.6.9\"]\n\n\n--- examples/servers/structured_output_lowlevel.py (py) ---\n#!/usr/bin/env python3\n\"\"\"\nExample low-level MCP server demonstrating structured output support.\n\nThis example shows how to use the low-level server API to return\nstructured data from tools, with automatic validation against output\nschemas.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n# Create low-level server instance\nserver = Server(\"structured-output-lowlevel-example\")\n\n\n@server.list_tools()\nasync def list_tools() -> list[types.Tool]:\n    \"\"\"List available tools with their schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get weather information (simulated)\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\"},\n                    \"conditions\": {\"type\": \"string\"},\n                    \"humidity\": {\"type\": \"integer\", \"minimum\": 0, \"maximum\": 100},\n                    \"wind_speed\": {\"type\": \"number\"},\n                    \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"},\n                },\n                \"required\": [\"temperature\", \"conditions\", \"humidity\", \"wind_speed\", \"timestamp\"],\n            },\n        ),\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -> Any:\n    \"\"\"\n    Handle tool call with structured output.\n    \"\"\"\n\n    if name == \"get_weather\":\n        # city = arguments[\"city\"]  # Would be used with real weather API\n\n        # Simulate weather data (in production, call a real weather API)\n        import random\n\n        weather_conditions = [\"sunny\", \"cloudy\", \"rainy\", \"partly cloud\n... (content truncated)\n\n--- examples/snippets/clients/__init__.py (py) ---\n\n\n--- examples/snippets/clients/completion_client.py (py) ---\n\"\"\"\ncd to the `examples/snippets` directory and run:\n    uv run completion-client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom mcp.types import PromptReference, ResourceTemplateReference\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"completion\", \"stdio\"],  # Server with completion support\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\nasync def run():\n    \"\"\"Run the completion client example.\"\"\"\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            # List available resource templates\n            templates = await session.list_resource_templates()\n            print(\"Available resource templates:\")\n            for template in templates.resourceTemplates:\n                print(f\"  - {template.uriTemplate}\")\n\n            # List available prompts\n            prompts = await session.list_prompts()\n            print(\"\\nAvailable prompts:\")\n            for prompt in prompts.prompts:\n                print(f\"  - {prompt.name}\")\n\n            # Complete resource template arguments\n            if templates.resourceTemplates:\n                template = templates.resourceTemplates[0]\n                print(f\"\\nCompleting arguments for resource template: {template.uriTemplate}\")\n\n                # Complete without context\n                result = await session.complete(\n                    ref=ResourceTemplateReference(type=\"ref/resource\", uri=template.uriTemplate),\n                    argument={\"name\": \"owner\", \"value\": \"model\"},\n                )\n                print(f\"Completions for 'owner' starting with 'model': {result.completion.values}\")\n\n                # Complete with context - repo suggestions based on own\n... (content truncated)\n\n--- examples/snippets/clients/display_utilities.py (py) ---\n\"\"\"\ncd to the `examples/snippets` directory and run:\n    uv run display-utilities-client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom mcp.shared.metadata_utils import get_display_name\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"fastmcp_quickstart\", \"stdio\"],\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\nasync def display_tools(session: ClientSession):\n    \"\"\"Display available tools with human-readable names\"\"\"\n    tools_response = await session.list_tools()\n\n    for tool in tools_response.tools:\n        # get_display_name() returns the title if available, otherwise the name\n        display_name = get_display_name(tool)\n        print(f\"Tool: {display_name}\")\n        if tool.description:\n            print(f\"   {tool.description}\")\n\n\nasync def display_resources(session: ClientSession):\n    \"\"\"Display available resources with human-readable names\"\"\"\n    resources_response = await session.list_resources()\n\n    for resource in resources_response.resources:\n        display_name = get_display_name(resource)\n        print(f\"Resource: {display_name} ({resource.uri})\")\n\n    templates_response = await session.list_resource_templates()\n    for template in templates_response.resourceTemplates:\n        display_name = get_display_name(template)\n        print(f\"Resource Template: {display_name}\")\n\n\nasync def run():\n    \"\"\"Run the display utilities example.\"\"\"\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            print(\"=== Available Tools ===\")\n            await display_tools(session)\n\n            print(\"\\n=== Available Resources ===\")\n            await display_resources(session)\n\n\ndef main():\n    \"\"\"Entry point fo\n... (content truncated)\n\n--- examples/snippets/clients/oauth_client.py (py) ---\n\"\"\"\nBefore running, specify running MCP RS server URL.\nTo spin up RS server locally, see\n    examples/servers/simple-auth/README.md\n\ncd to the `examples/snippets` directory and run:\n    uv run oauth-client\n\"\"\"\n\nimport asyncio\nfrom urllib.parse import parse_qs, urlparse\n\nfrom pydantic import AnyUrl\n\nfrom mcp import ClientSession\nfrom mcp.client.auth import OAuthClientProvider, TokenStorage\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata, OAuthToken\n\n\nclass InMemoryTokenStorage(TokenStorage):\n    \"\"\"Demo In-memory token storage implementation.\"\"\"\n\n    def __init__(self):\n        self.tokens: OAuthToken | None = None\n        self.client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -> OAuthToken | None:\n        \"\"\"Get stored tokens.\"\"\"\n        return self.tokens\n\n    async def set_tokens(self, tokens: OAuthToken) -> None:\n        \"\"\"Store tokens.\"\"\"\n        self.tokens = tokens\n\n    async def get_client_info(self) -> OAuthClientInformationFull | None:\n        \"\"\"Get stored client information.\"\"\"\n        return self.client_info\n\n    async def set_client_info(self, client_info: OAuthClientInformationFull) -> None:\n        \"\"\"Store client information.\"\"\"\n        self.client_info = client_info\n\n\nasync def handle_redirect(auth_url: str) -> None:\n    print(f\"Visit: {auth_url}\")\n\n\nasync def handle_callback() -> tuple[str, str | None]:\n    callback_url = input(\"Paste callback URL: \")\n    params = parse_qs(urlparse(callback_url).query)\n    return params[\"code\"][0], params.get(\"state\", [None])[0]\n\n\nasync def main():\n    \"\"\"Run the OAuth client example.\"\"\"\n    oauth_auth = OAuthClientProvider(\n        server_url=\"http://localhost:8001\",\n        client_metadata=OAuthClientMetadata(\n            client_name=\"Example MCP Client\",\n            redirect_uris=[AnyUrl(\"http://localhost:3000/callback\")],\n            grant_types=[\"authorization_code\", \"refresh_token\"],\n \n... (content truncated)\n\n--- examples/snippets/clients/parsing_tool_results.py (py) ---\n\"\"\"examples/snippets/clients/parsing_tool_results.py\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\n\n\nasync def parse_tool_results():\n    \"\"\"Demonstrates how to parse different types of content in CallToolResult.\"\"\"\n    server_params = StdioServerParameters(command=\"python\", args=[\"path/to/mcp_server.py\"])\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Example 1: Parsing text content\n            result = await session.call_tool(\"get_data\", {\"format\": \"text\"})\n            for content in result.content:\n                if isinstance(content, types.TextContent):\n                    print(f\"Text: {content.text}\")\n\n            # Example 2: Parsing structured content from JSON tools\n            result = await session.call_tool(\"get_user\", {\"id\": \"123\"})\n            if hasattr(result, \"structuredContent\") and result.structuredContent:\n                # Access structured data directly\n                user_data = result.structuredContent\n                print(f\"User: {user_data.get('name')}, Age: {user_data.get('age')}\")\n\n            # Example 3: Parsing embedded resources\n            result = await session.call_tool(\"read_config\", {})\n            for content in result.content:\n                if isinstance(content, types.EmbeddedResource):\n                    resource = content.resource\n                    if isinstance(resource, types.TextResourceContents):\n                        print(f\"Config from {resource.uri}: {resource.text}\")\n                    elif isinstance(resource, types.BlobResourceContents):\n                        print(f\"Binary data from {resource.uri}\")\n\n            # Example 4: Parsing image content\n            result = await session.call_tool(\"generate_chart\", {\"data\": [1, 2, 3]})\n            for content in result.content:\n                if isinstance(c\n... (content truncated)\n\n--- examples/snippets/clients/stdio_client.py (py) ---\n\"\"\"\ncd to the `examples/snippets/clients` directory and run:\n    uv run client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom pydantic import AnyUrl\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\nfrom mcp.shared.context import RequestContext\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"fastmcp_quickstart\", \"stdio\"],  # We're already in snippets dir\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\n# Optional: create a sampling callback\nasync def handle_sampling_message(\n    context: RequestContext, params: types.CreateMessageRequestParams\n) -> types.CreateMessageResult:\n    print(f\"Sampling request: {params.messages}\")\n    return types.CreateMessageResult(\n        role=\"assistant\",\n        content=types.TextContent(\n            type=\"text\",\n            text=\"Hello, world! from model\",\n        ),\n        model=\"gpt-3.5-turbo\",\n        stopReason=\"endTurn\",\n    )\n\n\nasync def run():\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write, sampling_callback=handle_sampling_message) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            # List available prompts\n            prompts = await session.list_prompts()\n            print(f\"Available prompts: {[p.name for p in prompts.prompts]}\")\n\n            # Get a prompt (greet_user prompt from fastmcp_quickstart)\n            if prompts.prompts:\n                prompt = await session.get_prompt(\"greet_user\", arguments={\"name\": \"Alice\", \"style\": \"friendly\"})\n                print(f\"Prompt result: {prompt.messages[0].content}\")\n\n            # List available resources\n            resources = await session.list_resources()\n            print(f\"Available resources: {[r.uri for r in resources.resources]}\")\n\n            # List available tools\n            tools = await s\n... (content truncated)\n\n--- examples/snippets/clients/streamable_basic.py (py) ---\n\"\"\"\nRun from the repository root:\n    uv run examples/snippets/clients/streamable_basic.py\n\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\n\n\nasync def main():\n    # Connect to a streamable HTTP server\n    async with streamablehttp_client(\"http://localhost:8000/mcp\") as (\n        read_stream,\n        write_stream,\n        _,\n    ):\n        # Create a session using the client streams\n        async with ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools = await session.list_tools()\n            print(f\"Available tools: {[tool.name for tool in tools.tools]}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n\n--- examples/snippets/pyproject.toml (toml) ---\n[project]\nname = \"mcp-snippets\"\nversion = \"0.1.0\"\ndescription = \"MCP Example Snippets\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"mcp\",\n]\n\n[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools]\npackages = [\"servers\", \"clients\"]\n\n[project.scripts]\nserver = \"servers:run_server\"\nclient = \"clients.stdio_client:main\"\ncompletion-client = \"clients.completion_client:main\"\ndirect-execution-server = \"servers.direct_execution:main\"\ndisplay-utilities-client = \"clients.display_utilities:main\"\noauth-client = \"clients.oauth_client:run\"\n\n\n--- examples/snippets/servers/__init__.py (py) ---\n\"\"\"MCP Snippets.\n\nThis package contains simple examples of MCP server features.\nEach server demonstrates a single feature and can be run as a standalone server.\n\nTo run a server, use the command:\n    uv run server basic_tool sse\n\"\"\"\n\nimport importlib\nimport sys\nfrom typing import Literal, cast\n\n\ndef run_server():\n    \"\"\"Run a server by name with optional transport.\n\n    Usage: server <server-name> [transport]\n    Example: server basic_tool sse\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: server <server-name> [transport]\")\n        print(\"Available servers: basic_tool, basic_resource, basic_prompt, tool_progress,\")\n        print(\"                   sampling, elicitation, completion, notifications,\")\n        print(\"                   fastmcp_quickstart, structured_output, images\")\n        print(\"Available transports: stdio (default), sse, streamable-http\")\n        sys.exit(1)\n\n    server_name = sys.argv[1]\n    transport = sys.argv[2] if len(sys.argv) > 2 else \"stdio\"\n\n    try:\n        module = importlib.import_module(f\".{server_name}\", package=__name__)\n        module.mcp.run(cast(Literal[\"stdio\", \"sse\", \"streamable-http\"], transport))\n    except ImportError:\n        print(f\"Error: Server '{server_name}' not found\")\n        sys.exit(1)\n\n\n--- examples/snippets/servers/basic_prompt.py (py) ---\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.server.fastmcp.prompts import base\n\nmcp = FastMCP(name=\"Prompt Example\")\n\n\n@mcp.prompt(title=\"Code Review\")\ndef review_code(code: str) -> str:\n    return f\"Please review this code:\\n\\n{code}\"\n\n\n@mcp.prompt(title=\"Debug Assistant\")\ndef debug_error(error: str) -> list[base.Message]:\n    return [\n        base.UserMessage(\"I'm seeing this error:\"),\n        base.UserMessage(error),\n        base.AssistantMessage(\"I'll help debug that. What have you tried so far?\"),\n    ]\n\n\n--- examples/snippets/servers/basic_resource.py (py) ---\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(name=\"Resource Example\")\n\n\n@mcp.resource(\"file://documents/{name}\")\ndef read_document(name: str) -> str:\n    \"\"\"Read a document by name.\"\"\"\n    # This would normally read from disk\n    return f\"Content of {name}\"\n\n\n@mcp.resource(\"config://settings\")\ndef get_settings() -> str:\n    \"\"\"Get application settings.\"\"\"\n    return \"\"\"{\n  \"theme\": \"dark\",\n  \"language\": \"en\",\n  \"debug\": false\n}\"\"\"\n\n\n--- examples/snippets/servers/basic_tool.py (py) ---\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(name=\"Tool Example\")\n\n\n@mcp.tool()\ndef sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n\n@mcp.tool()\ndef get_weather(city: str, unit: str = \"celsius\") -> str:\n    \"\"\"Get weather for a city.\"\"\"\n    # This would normally call a weather API\n    return f\"Weather in {city}: 22degrees{unit[0].upper()}\"\n\n\n--- examples/snippets/servers/completion.py (py) ---\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.types import (\n    Completion,\n    CompletionArgument,\n    CompletionContext,\n    PromptReference,\n    ResourceTemplateReference,\n)\n\nmcp = FastMCP(name=\"Example\")\n\n\n@mcp.resource(\"github://repos/{owner}/{repo}\")\ndef github_repo(owner: str, repo: str) -> str:\n    \"\"\"GitHub repository resource.\"\"\"\n    return f\"Repository: {owner}/{repo}\"\n\n\n@mcp.prompt(description=\"Code review prompt\")\ndef review_code(language: str, code: str) -> str:\n    \"\"\"Generate a code review.\"\"\"\n    return f\"Review this {language} code:\\n{code}\"\n\n\n@mcp.completion()\nasync def handle_completion(\n    ref: PromptReference | ResourceTemplateReference,\n    argument: CompletionArgument,\n    context: CompletionContext | None,\n) -> Completion | None:\n    \"\"\"Provide completions for prompts and resources.\"\"\"\n\n    # Complete programming languages for the prompt\n    if isinstance(ref, PromptReference):\n        if ref.name == \"review_code\" and argument.name == \"language\":\n            languages = [\"python\", \"javascript\", \"typescript\", \"go\", \"rust\"]\n            return Completion(\n                values=[lang for lang in languages if lang.startswith(argument.value)],\n                hasMore=False,\n            )\n\n    # Complete repository names for GitHub resources\n    if isinstance(ref, ResourceTemplateReference):\n        if ref.uri == \"github://repos/{owner}/{repo}\" and argument.name == \"repo\":\n            if context and context.arguments and context.arguments.get(\"owner\") == \"modelcontextprotocol\":\n                repos = [\"python-sdk\", \"typescript-sdk\", \"specification\"]\n                return Completion(values=repos, hasMore=False)\n\n    return None\n\n\n--- examples/snippets/servers/direct_execution.py (py) ---\n\"\"\"Example showing direct execution of an MCP server.\n\nThis is the simplest way to run an MCP server directly.\ncd to the `examples/snippets` directory and run:\n    uv run direct-execution-server\n    or\n    python servers/direct_execution.py\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"My App\")\n\n\n@mcp.tool()\ndef hello(name: str = \"World\") -> str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"\n\n\ndef main():\n    \"\"\"Entry point for the direct execution server.\"\"\"\n    mcp.run()\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n--- examples/snippets/servers/elicitation.py (py) ---\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import Context, FastMCP\n\nmcp = FastMCP(name=\"Elicitation Example\")\n\n\nclass BookingPreferences(BaseModel):\n    \"\"\"Schema for collecting user preferences.\"\"\"\n\n    checkAlternative: bool = Field(description=\"Would you like to check another date?\")\n    alternativeDate: str = Field(\n        default=\"2024-12-26\",\n        description=\"Alternative date (YYYY-MM-DD)\",\n    )\n\n\n@mcp.tool()\nasync def book_table(\n    date: str,\n    time: str,\n    party_size: int,\n    ctx: Context,\n) -> str:\n    \"\"\"Book a table with date availability check.\"\"\"\n    # Check if date is available\n    if date == \"2024-12-25\":\n        # Date unavailable - ask user for alternative\n        result = await ctx.elicit(\n            message=(f\"No tables available for {party_size} on {date}. Would you like to try another date?\"),\n            schema=BookingPreferences,\n        )\n\n        if result.action == \"accept\" and result.data:\n            if result.data.checkAlternative:\n                return f\"[SUCCESS] Booked for {result.data.alternativeDate}\"\n            return \"[CANCELLED] No booking made\"\n        return \"[CANCELLED] Booking cancelled\"\n\n    # Date available\n    return f\"[SUCCESS] Booked for {date} at {time}\"\n\n\n--- examples/snippets/servers/fastmcp_quickstart.py (py) ---\n\"\"\"\nFastMCP quickstart example.\n\ncd to the `examples/snippets/clients` directory and run:\n    uv run server fastmcp_quickstart stdio\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n\n# Add an addition tool\n@mcp.tool()\ndef add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n# Add a dynamic greeting resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -> str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n\n\n# Add a prompt\n@mcp.prompt()\ndef greet_user(name: str, style: str = \"friendly\") -> str:\n    \"\"\"Generate a greeting prompt\"\"\"\n    styles = {\n        \"friendly\": \"Please write a warm, friendly greeting\",\n        \"formal\": \"Please write a formal, professional greeting\",\n        \"casual\": \"Please write a casual, relaxed greeting\",\n    }\n\n    return f\"{styles.get(style, styles['friendly'])} for someone named {name}.\"\n\n\n--- examples/snippets/servers/images.py (py) ---\n\"\"\"Example showing image handling with FastMCP.\"\"\"\n\nfrom PIL import Image as PILImage\n\nfrom mcp.server.fastmcp import FastMCP, Image\n\nmcp = FastMCP(\"Image Example\")\n\n\n@mcp.tool()\ndef create_thumbnail(image_path: str) -> Image:\n    \"\"\"Create a thumbnail from an image\"\"\"\n    img = PILImage.open(image_path)\n    img.thumbnail((100, 100))\n    return Image(data=img.tobytes(), format=\"png\")\n\n\n--- examples/snippets/servers/lifespan_example.py (py) ---\n\"\"\"Example showing lifespan support for startup/shutdown with strong typing.\"\"\"\n\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\n\nfrom mcp.server.fastmcp import Context, FastMCP\n\n\n# Mock database class for example\nclass Database:\n    \"\"\"Mock database class for example.\"\"\"\n\n    @classmethod\n    async def connect(cls) -> \"Database\":\n        \"\"\"Connect to database.\"\"\"\n        return cls()\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from database.\"\"\"\n        pass\n\n    def query(self) -> str:\n        \"\"\"Execute a query.\"\"\"\n        return \"Query result\"\n\n\n@dataclass\nclass AppContext:\n    \"\"\"Application context with typed dependencies.\"\"\"\n\n    db: Database\n\n\n@asynccontextmanager\nasync def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:\n    \"\"\"Manage application lifecycle with type-safe context.\"\"\"\n    # Initialize on startup\n    db = await Database.connect()\n    try:\n        yield AppContext(db=db)\n    finally:\n        # Cleanup on shutdown\n        await db.disconnect()\n\n\n# Pass lifespan to server\nmcp = FastMCP(\"My App\", lifespan=app_lifespan)\n\n\n# Access type-safe lifespan context in tools\n@mcp.tool()\ndef query_db(ctx: Context) -> str:\n    \"\"\"Tool that uses initialized resources.\"\"\"\n    db = ctx.request_context.lifespan_context.db\n    return db.query()\n\n\n--- examples/snippets/servers/lowlevel/__init__.py (py) ---\n\"\"\"Low-level server examples for MCP Python SDK.\"\"\"\n\n\n--- examples/snippets/servers/lowlevel/basic.py (py) ---\n\"\"\"\nRun from the repository root:\nuv run examples/snippets/servers/lowlevel/basic.py\n\"\"\"\n\nimport asyncio\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n# Create a server instance\nserver = Server(\"example-server\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -> list[types.Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        types.Prompt(\n            name=\"example-prompt\",\n            description=\"An example prompt template\",\n            arguments=[types.PromptArgument(name=\"arg1\", description=\"Example argument\", required=True)],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:\n    \"\"\"Get a specific prompt by name.\"\"\"\n    if name != \"example-prompt\":\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n    arg1_value = (arguments or {}).get(\"arg1\", \"default\")\n\n    return types.GetPromptResult(\n        description=\"Example prompt\",\n        messages=[\n            types.PromptMessage(\n                role=\"user\",\n                content=types.TextContent(type=\"text\", text=f\"Example prompt text with argument: {arg1_value}\"),\n            )\n        ],\n    )\n\n\nasync def run():\n    \"\"\"Run the basic low-level server.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n\n\n--- examples/snippets/servers/lowlevel/lifespan.py (py) ---\n\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/lowlevel/lifespan.py\n\"\"\"\n\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n\n# Mock database class for example\nclass Database:\n    \"\"\"Mock database class for example.\"\"\"\n\n    @classmethod\n    async def connect(cls) -> \"Database\":\n        \"\"\"Connect to database.\"\"\"\n        print(\"Database connected\")\n        return cls()\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from database.\"\"\"\n        print(\"Database disconnected\")\n\n    async def query(self, query_str: str) -> list[dict[str, str]]:\n        \"\"\"Execute a query.\"\"\"\n        # Simulate database query\n        return [{\"id\": \"1\", \"name\": \"Example\", \"query\": query_str}]\n\n\n@asynccontextmanager\nasync def server_lifespan(_server: Server) -> AsyncIterator[dict]:\n    \"\"\"Manage server startup and shutdown lifecycle.\"\"\"\n    # Initialize resources on startup\n    db = await Database.connect()\n    try:\n        yield {\"db\": db}\n    finally:\n        # Clean up on shutdown\n        await db.disconnect()\n\n\n# Pass lifespan to server\nserver = Server(\"example-server\", lifespan=server_lifespan)\n\n\n@server.list_tools()\nasync def handle_list_tools() -> list[types.Tool]:\n    \"\"\"List available tools.\"\"\"\n    return [\n        types.Tool(\n            name=\"query_db\",\n            description=\"Query the database\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"query\": {\"type\": \"string\", \"description\": \"SQL query to execute\"}},\n                \"required\": [\"query\"],\n            },\n        )\n    ]\n\n\n@server.call_tool()\nasync def query_db(name: str, arguments: dict) -> list[types.TextContent]:\n    \"\"\"Handle database query tool call.\"\"\"\n    if name != \"query_db\":\n        raise ValueError(f\"Unknown tool: {name}\")\n\n    # Acces\n... (content truncated)\n\n--- examples/snippets/servers/lowlevel/structured_output.py (py) ---\n\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/lowlevel/structured_output.py\n\"\"\"\n\nimport asyncio\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\nserver = Server(\"example-server\")\n\n\n@server.list_tools()\nasync def list_tools() -> list[types.Tool]:\n    \"\"\"List available tools with structured output schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\", \"description\": \"Temperature in Celsius\"},\n                    \"condition\": {\"type\": \"string\", \"description\": \"Weather condition\"},\n                    \"humidity\": {\"type\": \"number\", \"description\": \"Humidity percentage\"},\n                    \"city\": {\"type\": \"string\", \"description\": \"City name\"},\n                },\n                \"required\": [\"temperature\", \"condition\", \"humidity\", \"city\"],\n            },\n        )\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Handle tool calls with structured output.\"\"\"\n    if name == \"get_weather\":\n        city = arguments[\"city\"]\n\n        # Simulated weather data - in production, call a weather API\n        weather_data = {\n            \"temperature\": 22.5,\n            \"condition\": \"partly cloudy\",\n            \"humidity\": 65,\n            \"city\": city,  # Include the requested city\n        }\n\n        # low-level server will validate structured output against the tool's\n        # output schema, and additionally serialize it into a TextContent b\n... (content truncated)\n\n--- examples/snippets/servers/notifications.py (py) ---\nfrom mcp.server.fastmcp import Context, FastMCP\n\nmcp = FastMCP(name=\"Notifications Example\")\n\n\n@mcp.tool()\nasync def process_data(data: str, ctx: Context) -> str:\n    \"\"\"Process data with logging.\"\"\"\n    # Different log levels\n    await ctx.debug(f\"Debug: Processing '{data}'\")\n    await ctx.info(\"Info: Starting processing\")\n    await ctx.warning(\"Warning: This is experimental\")\n    await ctx.error(\"Error: (This is just a demo)\")\n\n    # Notify about resource changes\n    await ctx.session.send_resource_list_changed()\n\n    return f\"Processed: {data}\"\n\n\n--- examples/snippets/servers/oauth_server.py (py) ---\n\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/oauth_server.py\n\"\"\"\n\nfrom pydantic import AnyHttpUrl\n\nfrom mcp.server.auth.provider import AccessToken, TokenVerifier\nfrom mcp.server.auth.settings import AuthSettings\nfrom mcp.server.fastmcp import FastMCP\n\n\nclass SimpleTokenVerifier(TokenVerifier):\n    \"\"\"Simple token verifier for demonstration.\"\"\"\n\n    async def verify_token(self, token: str) -> AccessToken | None:\n        pass  # This is where you would implement actual token validation\n\n\n# Create FastMCP instance as a Resource Server\nmcp = FastMCP(\n    \"Weather Service\",\n    # Token verifier for authentication\n    token_verifier=SimpleTokenVerifier(),\n    # Auth settings for RFC 9728 Protected Resource Metadata\n    auth=AuthSettings(\n        issuer_url=AnyHttpUrl(\"https://auth.example.com\"),  # Authorization Server URL\n        resource_server_url=AnyHttpUrl(\"http://localhost:3001\"),  # This server's URL\n        required_scopes=[\"user\"],\n    ),\n)\n\n\n@mcp.tool()\nasync def get_weather(city: str = \"London\") -> dict[str, str]:\n    \"\"\"Get weather data for a city\"\"\"\n    return {\n        \"city\": city,\n        \"temperature\": \"22\",\n        \"condition\": \"Partly cloudy\",\n        \"humidity\": \"65%\",\n    }\n\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n\n\n--- examples/snippets/servers/sampling.py (py) ---\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.types import SamplingMessage, TextContent\n\nmcp = FastMCP(name=\"Sampling Example\")\n\n\n@mcp.tool()\nasync def generate_poem(topic: str, ctx: Context) -> str:\n    \"\"\"Generate a poem using LLM sampling.\"\"\"\n    prompt = f\"Write a short poem about {topic}\"\n\n    result = await ctx.session.create_message(\n        messages=[\n            SamplingMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=prompt),\n            )\n        ],\n        max_tokens=100,\n    )\n\n    if result.content.type == \"text\":\n        return result.content.text\n    return str(result.content)\n\n\n--- examples/snippets/servers/streamable_config.py (py) ---\n\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/streamable_config.py\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Stateful server (maintains session state)\nmcp = FastMCP(\"StatefulServer\")\n\n# Other configuration options:\n# Stateless server (no session persistence)\n# mcp = FastMCP(\"StatelessServer\", stateless_http=True)\n\n# Stateless server (no session persistence, no sse stream with supported client)\n# mcp = FastMCP(\"StatelessServer\", stateless_http=True, json_response=True)\n\n\n# Add a simple tool to demonstrate the server\n@mcp.tool()\ndef greet(name: str = \"World\") -> str:\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"\n\n\n# Run server with streamable_http transport\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n\n\n--- examples/snippets/servers/streamable_starlette_mount.py (py) ---\n\"\"\"\nRun from the repository root:\n    uvicorn examples.snippets.servers.streamable_starlette_mount:app --reload\n\"\"\"\n\nimport contextlib\n\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create the Echo server\necho_mcp = FastMCP(name=\"EchoServer\", stateless_http=True)\n\n\n@echo_mcp.tool()\ndef echo(message: str) -> str:\n    \"\"\"A simple echo tool\"\"\"\n    return f\"Echo: {message}\"\n\n\n# Create the Math server\nmath_mcp = FastMCP(name=\"MathServer\", stateless_http=True)\n\n\n@math_mcp.tool()\ndef add_two(n: int) -> int:\n    \"\"\"Tool to add two to the input\"\"\"\n    return n + 2\n\n\n# Create a combined lifespan to manage both session managers\n@contextlib.asynccontextmanager\nasync def lifespan(app: Starlette):\n    async with contextlib.AsyncExitStack() as stack:\n        await stack.enter_async_context(echo_mcp.session_manager.run())\n        await stack.enter_async_context(math_mcp.session_manager.run())\n        yield\n\n\n# Create the Starlette app and mount the MCP servers\napp = Starlette(\n    routes=[\n        Mount(\"/echo\", echo_mcp.streamable_http_app()),\n        Mount(\"/math\", math_mcp.streamable_http_app()),\n    ],\n    lifespan=lifespan,\n)\n\n\n--- examples/snippets/servers/structured_output.py (py) ---\n\"\"\"Example showing structured output with tools.\"\"\"\n\nfrom typing import TypedDict\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"Structured Output Example\")\n\n\n# Using Pydantic models for rich structured data\nclass WeatherData(BaseModel):\n    \"\"\"Weather information structure.\"\"\"\n\n    temperature: float = Field(description=\"Temperature in Celsius\")\n    humidity: float = Field(description=\"Humidity percentage\")\n    condition: str\n    wind_speed: float\n\n\n@mcp.tool()\ndef get_weather(city: str) -> WeatherData:\n    \"\"\"Get weather for a city - returns structured data.\"\"\"\n    # Simulated weather data\n    return WeatherData(\n        temperature=72.5,\n        humidity=45.0,\n        condition=\"sunny\",\n        wind_speed=5.2,\n    )\n\n\n# Using TypedDict for simpler structures\nclass LocationInfo(TypedDict):\n    latitude: float\n    longitude: float\n    name: str\n\n\n@mcp.tool()\ndef get_location(address: str) -> LocationInfo:\n    \"\"\"Get location coordinates\"\"\"\n    return LocationInfo(latitude=51.5074, longitude=-0.1278, name=\"London, UK\")\n\n\n# Using dict[str, Any] for flexible schemas\n@mcp.tool()\ndef get_statistics(data_type: str) -> dict[str, float]:\n    \"\"\"Get various statistics\"\"\"\n    return {\"mean\": 42.5, \"median\": 40.0, \"std_dev\": 5.2}\n\n\n# Ordinary classes with type hints work for structured output\nclass UserProfile:\n    name: str\n    age: int\n    email: str | None = None\n\n    def __init__(self, name: str, age: int, email: str | None = None):\n        self.name = name\n        self.age = age\n        self.email = email\n\n\n@mcp.tool()\ndef get_user(user_id: str) -> UserProfile:\n    \"\"\"Get user profile - returns structured data\"\"\"\n    return UserProfile(name=\"Alice\", age=30, email=\"alice@example.com\")\n\n\n# Classes WITHOUT type hints cannot be used for structured output\nclass UntypedConfig:\n    def __init__(self, setting1, setting2):\n        self.setting1 = setting1\n        self.setting2 = setting2\n\n\n@mcp.tool()\ndef get_config() -> UntypedConf\n... (content truncated)\n\n--- examples/snippets/servers/tool_progress.py (py) ---\nfrom mcp.server.fastmcp import Context, FastMCP\n\nmcp = FastMCP(name=\"Progress Example\")\n\n\n@mcp.tool()\nasync def long_running_task(task_name: str, ctx: Context, steps: int = 5) -> str:\n    \"\"\"Execute a task with progress updates.\"\"\"\n    await ctx.info(f\"Starting: {task_name}\")\n\n    for i in range(steps):\n        progress = (i + 1) / steps\n        await ctx.report_progress(\n            progress=progress,\n            total=1.0,\n            message=f\"Step {i + 1}/{steps}\",\n        )\n        await ctx.debug(f\"Completed step {i + 1}\")\n\n    return f\"Task '{task_name}' completed\"\n\n\n--- mkdocs.yml (yml) ---\nsite_name: MCP Server\nsite_description: MCP Server\nstrict: true\n\nrepo_name: modelcontextprotocol/python-sdk\nrepo_url: https://github.com/modelcontextprotocol/python-sdk\nedit_uri: edit/main/docs/\nsite_url: https://modelcontextprotocol.github.io/python-sdk\n\n# TODO(Marcelo): Add Anthropic copyright?\n# copyright: Â© Model Context Protocol 2025 to present\n\nnav:\n  - Home: index.md\n  - API Reference: api.md\n\ntheme:\n  name: \"material\"\n  palette:\n    - media: \"(prefers-color-scheme)\"\n      scheme: default\n      primary: black\n      accent: black\n      toggle:\n        icon: material/lightbulb\n        name: \"Switch to light mode\"\n    - media: \"(prefers-color-scheme: light)\"\n      scheme: default\n      primary: black\n      accent: black\n      toggle:\n        icon: material/lightbulb-outline\n        name: \"Switch to dark mode\"\n    - media: \"(prefers-color-scheme: dark)\"\n      scheme: slate\n      primary: white\n      accent: white\n      toggle:\n        icon: material/lightbulb-auto-outline\n        name: \"Switch to system preference\"\n  features:\n    - search.suggest\n    - search.highlight\n    - content.tabs.link\n    - content.code.annotate\n    - content.code.copy\n    - content.code.select\n    - navigation.path\n    - navigation.indexes\n    - navigation.sections\n    - navigation.tracking\n    - toc.follow\n  # logo: \"img/logo-white.svg\"\n  # TODO(Marcelo): Add a favicon.\n  # favicon: \"favicon.ico\"\n\n# https://www.mkdocs.org/user-guide/configuration/#validation\nvalidation:\n  omitted_files: warn\n  absolute_links: warn\n  unrecognized_links: warn\n  anchors: warn\n\nmarkdown_extensions:\n  - tables\n  - admonition\n  - attr_list\n  - md_in_html\n  - pymdownx.details\n  - pymdownx.caret\n  - pymdownx.critic\n  - pymdownx.mark\n  - pymdownx.superfences\n  - pymdownx.snippets\n  - pymdownx.tilde\n  - pymdownx.inlinehilite\n  - pymdownx.highlight:\n      pygments_lang_class: true\n  - pymdownx.extra:\n      pymdownx.superfences:\n        custom_fences:\n          - name: mermaid\n            class: mermaid\n          \n... (content truncated)\n\n--- pyproject.toml (toml) ---\n[project]\nname = \"mcp\"\ndynamic = [\"version\"]\ndescription = \"Model Context Protocol SDK\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic, PBC.\" }]\nmaintainers = [\n    { name = \"David Soria Parra\", email = \"davidsp@anthropic.com\" },\n    { name = \"Justin Spahr-Summers\", email = \"justin@anthropic.com\" },\n]\nkeywords = [\"git\", \"mcp\", \"llm\", \"automation\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.13\",\n]\ndependencies = [\n    \"anyio>=4.5\",\n    \"httpx>=0.27\",\n    \"httpx-sse>=0.4\",\n    \"pydantic>=2.8.0,<3.0.0\",\n    \"starlette>=0.27\",\n    \"python-multipart>=0.0.9\",\n    \"sse-starlette>=1.6.1\",\n    \"pydantic-settings>=2.5.2\",\n    \"uvicorn>=0.23.1; sys_platform != 'emscripten'\",\n    \"jsonschema>=4.20.0\",\n    \"pywin32>=310; sys_platform == 'win32'\",\n]\n\n[project.optional-dependencies]\nrich = [\"rich>=13.9.4\"]\ncli = [\"typer>=0.16.0\", \"python-dotenv>=1.0.0\"]\nws = [\"websockets>=15.0.1\"]\n\n[project.scripts]\nmcp = \"mcp.cli:app [cli]\"\n\n[tool.uv]\ndefault-groups = [\"dev\", \"docs\"]\nrequired-version = \">=0.7.2\"\n\n[dependency-groups]\ndev = [\n    \"pyright>=1.1.391\",\n    \"pytest>=8.3.4\",\n    \"ruff>=0.8.5\",\n    \"trio>=0.26.2\",\n    \"pytest-flakefinder>=1.1.0\",\n    \"pytest-xdist>=3.6.1\",\n    \"pytest-examples>=0.0.14\",\n    \"pytest-pretty>=1.2.0\",\n    \"inline-snapshot>=0.23.0\",\n    \"dirty-equals>=0.9.0\",\n]\ndocs = [\n    \"mkdocs>=1.6.1\",\n    \"mkdocs-glightbox>=0.4.0\",\n    \"mkdocs-material[imaging]>=9.5.45\",\n    \"mkdocstrings-python>=1.12.2\",\n]\n\n[build-system]\nrequires = [\"hatchling\", \"uv-dynamic-versioning\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.version]\nsource = \"uv-dynamic-versioning\"\n\n[tool.uv-dynamic-versioning]\nvcs = \"git\"\n... (content truncated)\n\n--- scripts/update_readme_snippets.py (py) ---\n#!/usr/bin/env python3\n\"\"\"\nUpdate README.md with live code snippets from example files.\n\nThis script finds specially marked code blocks in README.md and updates them\nwith the actual code from the referenced files.\n\nUsage:\n    python scripts/update_readme_snippets.py\n    python scripts/update_readme_snippets.py --check  # Check mode for CI\n\"\"\"\n\nimport argparse\nimport re\nimport sys\nfrom pathlib import Path\n\n\ndef get_github_url(file_path: str) -> str:\n    \"\"\"Generate a GitHub URL for the file.\n\n    Args:\n        file_path: Path to the file relative to repo root\n\n    Returns:\n        GitHub URL\n    \"\"\"\n    base_url = \"https://github.com/modelcontextprotocol/python-sdk/blob/main\"\n    return f\"{base_url}/{file_path}\"\n\n\ndef process_snippet_block(match: re.Match, check_mode: bool = False) -> str:\n    \"\"\"Process a single snippet-source block.\n\n    Args:\n        match: The regex match object\n        check_mode: If True, return original if no changes needed\n\n    Returns:\n        The updated block content\n    \"\"\"\n    full_match = match.group(0)\n    indent = match.group(1)\n    file_path = match.group(2)\n\n    try:\n        # Read the entire file\n        file = Path(file_path)\n        if not file.exists():\n            print(f\"Warning: File not found: {file_path}\")\n            return full_match\n\n        code = file.read_text().rstrip()\n        github_url = get_github_url(file_path)\n\n        # Build the replacement block\n        indented_code = code.replace(\"\\n\", f\"\\n{indent}\")\n        replacement = f\"\"\"{indent}<!-- snippet-source {file_path} -->\n{indent}```python\n{indent}{indented_code}\n{indent}```\n\n{indent}_Full example: [{file_path}]({github_url})_\n{indent}<!-- /snippet-source -->\"\"\"\n\n        # In check mode, only check if code has changed\n        if check_mode:\n            # Extract existing code from the match\n            existing_content = match.group(3)\n            if existing_content is not None:\n                existing_lines = existing_content.strip().split(\"\\n\")\n          \n... (content truncated)\n\n--- src/mcp/__init__.py (py) ---\nfrom .client.session import ClientSession\nfrom .client.session_group import ClientSessionGroup\nfrom .client.stdio import StdioServerParameters, stdio_client\nfrom .server.session import ServerSession\nfrom .server.stdio import stdio_server\nfrom .shared.exceptions import McpError\nfrom .types import (\n    CallToolRequest,\n    ClientCapabilities,\n    ClientNotification,\n    ClientRequest,\n    ClientResult,\n    CompleteRequest,\n    CreateMessageRequest,\n    CreateMessageResult,\n    ErrorData,\n    GetPromptRequest,\n    GetPromptResult,\n    Implementation,\n    IncludeContext,\n    InitializedNotification,\n    InitializeRequest,\n    InitializeResult,\n    JSONRPCError,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    ListPromptsRequest,\n    ListPromptsResult,\n    ListResourcesRequest,\n    ListResourcesResult,\n    ListToolsResult,\n    LoggingLevel,\n    LoggingMessageNotification,\n    Notification,\n    PingRequest,\n    ProgressNotification,\n    PromptsCapability,\n    ReadResourceRequest,\n    ReadResourceResult,\n    Resource,\n    ResourcesCapability,\n    ResourceUpdatedNotification,\n    RootsCapability,\n    SamplingMessage,\n    ServerCapabilities,\n    ServerNotification,\n    ServerRequest,\n    ServerResult,\n    SetLevelRequest,\n    StopReason,\n    SubscribeRequest,\n    Tool,\n    ToolsCapability,\n    UnsubscribeRequest,\n)\nfrom .types import (\n    Role as SamplingRole,\n)\n\n__all__ = [\n    \"CallToolRequest\",\n    \"ClientCapabilities\",\n    \"ClientNotification\",\n    \"ClientRequest\",\n    \"ClientResult\",\n    \"ClientSession\",\n    \"ClientSessionGroup\",\n    \"CreateMessageRequest\",\n    \"CreateMessageResult\",\n    \"ErrorData\",\n    \"GetPromptRequest\",\n    \"GetPromptResult\",\n    \"Implementation\",\n    \"IncludeContext\",\n    \"InitializeRequest\",\n    \"InitializeResult\",\n    \"InitializedNotification\",\n    \"JSONRPCError\",\n    \"JSONRPCRequest\",\n    \"ListPromptsRequest\",\n    \"ListPromptsResult\",\n    \"ListResourcesRequest\",\n    \"ListResourcesResult\",\n    \"ListToolsResult\",\n    \"LoggingLevel\",\n    \"LoggingMess\n... (content truncated)\n\n--- src/mcp/cli/__init__.py (py) ---\n\"\"\"FastMCP CLI package.\"\"\"\n\nfrom .cli import app\n\nif __name__ == \"__main__\":\n    app()\n\n\n--- src/mcp/cli/claude.py (py) ---\n\"\"\"Claude app integration utilities.\"\"\"\n\nimport json\nimport os\nimport shutil\nimport sys\nfrom pathlib import Path\nfrom typing import Any\n\nfrom mcp.server.fastmcp.utilities.logging import get_logger\n\nlogger = get_logger(__name__)\n\nMCP_PACKAGE = \"mcp[cli]\"\n\n\ndef get_claude_config_path() -> Path | None:\n    \"\"\"Get the Claude config directory based on platform.\"\"\"\n    if sys.platform == \"win32\":\n        path = Path(Path.home(), \"AppData\", \"Roaming\", \"Claude\")\n    elif sys.platform == \"darwin\":\n        path = Path(Path.home(), \"Library\", \"Application Support\", \"Claude\")\n    elif sys.platform.startswith(\"linux\"):\n        path = Path(os.environ.get(\"XDG_CONFIG_HOME\", Path.home() / \".config\"), \"Claude\")\n    else:\n        return None\n\n    if path.exists():\n        return path\n    return None\n\n\ndef get_uv_path() -> str:\n    \"\"\"Get the full path to the uv executable.\"\"\"\n    uv_path = shutil.which(\"uv\")\n    if not uv_path:\n        logger.error(\n            \"uv executable not found in PATH, falling back to 'uv'. Please ensure uv is installed and in your PATH\"\n        )\n        return \"uv\"  # Fall back to just \"uv\" if not found\n    return uv_path\n\n\ndef update_claude_config(\n    file_spec: str,\n    server_name: str,\n    *,\n    with_editable: Path | None = None,\n    with_packages: list[str] | None = None,\n    env_vars: dict[str, str] | None = None,\n) -> bool:\n    \"\"\"Add or update a FastMCP server in Claude's configuration.\n\n    Args:\n        file_spec: Path to the server file, optionally with :object suffix\n        server_name: Name for the server in Claude's config\n        with_editable: Optional directory to install in editable mode\n        with_packages: Optional list of additional packages to install\n        env_vars: Optional dictionary of environment variables. These are merged with\n            any existing variables, with new values taking precedence.\n\n    Raises:\n        RuntimeError: If Claude Desktop's config directory is not found, indicating\n            Claude Desktop ma\n... (content truncated)\n\n--- src/mcp/cli/cli.py (py) ---\n\"\"\"MCP CLI tools.\"\"\"\n\nimport importlib.metadata\nimport importlib.util\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import Annotated, Any\n\nfrom mcp.server import FastMCP\nfrom mcp.server import Server as LowLevelServer\n\ntry:\n    import typer\nexcept ImportError:\n    print(\"Error: typer is required. Install with 'pip install mcp[cli]'\")\n    sys.exit(1)\n\ntry:\n    from mcp.cli import claude\n    from mcp.server.fastmcp.utilities.logging import get_logger\nexcept ImportError:\n    print(\"Error: mcp.server.fastmcp is not installed or not in PYTHONPATH\")\n    sys.exit(1)\n\ntry:\n    import dotenv\nexcept ImportError:\n    dotenv = None\n\nlogger = get_logger(\"cli\")\n\napp = typer.Typer(\n    name=\"mcp\",\n    help=\"MCP development tools\",\n    add_completion=False,\n    no_args_is_help=True,  # Show help if no args provided\n)\n\n\ndef _get_npx_command():\n    \"\"\"Get the correct npx command for the current platform.\"\"\"\n    if sys.platform == \"win32\":\n        # Try both npx.cmd and npx.exe on Windows\n        for cmd in [\"npx.cmd\", \"npx.exe\", \"npx\"]:\n            try:\n                subprocess.run([cmd, \"--version\"], check=True, capture_output=True, shell=True)\n                return cmd\n            except subprocess.CalledProcessError:\n                continue\n        return None\n    return \"npx\"  # On Unix-like systems, just use npx\n\n\ndef _parse_env_var(env_var: str) -> tuple[str, str]:\n    \"\"\"Parse environment variable string in format KEY=VALUE.\"\"\"\n    if \"=\" not in env_var:\n        logger.error(f\"Invalid environment variable format: {env_var}. Must be KEY=VALUE\")\n        sys.exit(1)\n    key, value = env_var.split(\"=\", 1)\n    return key.strip(), value.strip()\n\n\ndef _build_uv_command(\n    file_spec: str,\n    with_editable: Path | None = None,\n    with_packages: list[str] | None = None,\n) -> list[str]:\n    \"\"\"Build the uv run command that runs a MCP server through mcp run.\"\"\"\n    cmd = [\"uv\"]\n\n    cmd.extend([\"run\", \"--with\", \"mcp\"])\n\n    if with_editable:\n        c\n... (content truncated)\n\n--- src/mcp/client/__init__.py (py) ---\n\n\n--- src/mcp/client/__main__.py (py) ---\nimport argparse\nimport logging\nimport sys\nfrom functools import partial\nfrom urllib.parse import urlparse\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.client.sse import sse_client\nfrom mcp.client.stdio import StdioServerParameters, stdio_client\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\n\nif not sys.warnoptions:\n    import warnings\n\n    warnings.simplefilter(\"ignore\")\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"client\")\n\n\nasync def message_handler(\n    message: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n) -> None:\n    if isinstance(message, Exception):\n        logger.error(\"Error: %s\", message)\n        return\n\n    logger.info(\"Received message from server: %s\", message)\n\n\nasync def run_session(\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n    write_stream: MemoryObjectSendStream[SessionMessage],\n    client_info: types.Implementation | None = None,\n):\n    async with ClientSession(\n        read_stream,\n        write_stream,\n        message_handler=message_handler,\n        client_info=client_info,\n    ) as session:\n        logger.info(\"Initializing session\")\n        await session.initialize()\n        logger.info(\"Initialized\")\n\n\nasync def main(command_or_url: str, args: list[str], env: list[tuple[str, str]]):\n    env_dict = dict(env)\n\n    if urlparse(command_or_url).scheme in (\"http\", \"https\"):\n        # Use SSE client for HTTP(S) URLs\n        async with sse_client(command_or_url) as streams:\n            await run_session(*streams)\n    else:\n        # Use stdio client for commands\n        server_parameters = StdioServerParameters(command=command_or_url, args=args, env=env_dict)\n        async with stdio_client(server_parameters) as streams:\n            await run_session(*streams)\n\n\ndef\n... (content truncated)\n\n--- src/mcp/client/auth.py (py) ---\n\"\"\"\nOAuth2 Authentication implementation for HTTPX.\n\nImplements authorization code flow with PKCE and automatic token refresh.\n\"\"\"\n\nimport base64\nimport hashlib\nimport logging\nimport re\nimport secrets\nimport string\nimport time\nfrom collections.abc import AsyncGenerator, Awaitable, Callable\nfrom dataclasses import dataclass, field\nfrom typing import Protocol\nfrom urllib.parse import urlencode, urljoin, urlparse\n\nimport anyio\nimport httpx\nfrom pydantic import BaseModel, Field, ValidationError\n\nfrom mcp.client.streamable_http import MCP_PROTOCOL_VERSION\nfrom mcp.shared.auth import (\n    OAuthClientInformationFull,\n    OAuthClientMetadata,\n    OAuthMetadata,\n    OAuthToken,\n    ProtectedResourceMetadata,\n)\nfrom mcp.shared.auth_utils import check_resource_allowed, resource_url_from_server_url\nfrom mcp.types import LATEST_PROTOCOL_VERSION\n\nlogger = logging.getLogger(__name__)\n\n\nclass OAuthFlowError(Exception):\n    \"\"\"Base exception for OAuth flow errors.\"\"\"\n\n\nclass OAuthTokenError(OAuthFlowError):\n    \"\"\"Raised when token operations fail.\"\"\"\n\n\nclass OAuthRegistrationError(OAuthFlowError):\n    \"\"\"Raised when client registration fails.\"\"\"\n\n\nclass PKCEParameters(BaseModel):\n    \"\"\"PKCE (Proof Key for Code Exchange) parameters.\"\"\"\n\n    code_verifier: str = Field(..., min_length=43, max_length=128)\n    code_challenge: str = Field(..., min_length=43, max_length=128)\n\n    @classmethod\n    def generate(cls) -> \"PKCEParameters\":\n        \"\"\"Generate new PKCE parameters.\"\"\"\n        code_verifier = \"\".join(secrets.choice(string.ascii_letters + string.digits + \"-._~\") for _ in range(128))\n        digest = hashlib.sha256(code_verifier.encode()).digest()\n        code_challenge = base64.urlsafe_b64encode(digest).decode().rstrip(\"=\")\n        return cls(code_verifier=code_verifier, code_challenge=code_challenge)\n\n\nclass TokenStorage(Protocol):\n    \"\"\"Protocol for token storage implementations.\"\"\"\n\n    async def get_tokens(self) -> OAuthToken | None:\n        \"\"\"Get stored tokens.\"\"\"\n       \n... (content truncated)\n\n--- src/mcp/client/session.py (py) ---\nimport logging\nfrom datetime import timedelta\nfrom typing import Any, Protocol\n\nimport anyio.lowlevel\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom jsonschema import SchemaError, ValidationError, validate\nfrom pydantic import AnyUrl, TypeAdapter\n\nimport mcp.types as types\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import BaseSession, ProgressFnT, RequestResponder\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\n\nDEFAULT_CLIENT_INFO = types.Implementation(name=\"mcp\", version=\"0.1.0\")\n\nlogger = logging.getLogger(\"client\")\n\n\nclass SamplingFnT(Protocol):\n    async def __call__(\n        self,\n        context: RequestContext[\"ClientSession\", Any],\n        params: types.CreateMessageRequestParams,\n    ) -> types.CreateMessageResult | types.ErrorData: ...\n\n\nclass ElicitationFnT(Protocol):\n    async def __call__(\n        self,\n        context: RequestContext[\"ClientSession\", Any],\n        params: types.ElicitRequestParams,\n    ) -> types.ElicitResult | types.ErrorData: ...\n\n\nclass ListRootsFnT(Protocol):\n    async def __call__(\n        self, context: RequestContext[\"ClientSession\", Any]\n    ) -> types.ListRootsResult | types.ErrorData: ...\n\n\nclass LoggingFnT(Protocol):\n    async def __call__(\n        self,\n        params: types.LoggingMessageNotificationParams,\n    ) -> None: ...\n\n\nclass MessageHandlerFnT(Protocol):\n    async def __call__(\n        self,\n        message: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n    ) -> None: ...\n\n\nasync def _default_message_handler(\n    message: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n) -> None:\n    await anyio.lowlevel.checkpoint()\n\n\nasync def _default_sampling_callback(\n    context: RequestContext[\"ClientSession\", Any],\n    params: types.CreateMessageRequestParams,\n) -> types.CreateMessageResult | types.\n... (content truncated)\n\n--- src/mcp/client/session_group.py (py) ---\n\"\"\"\nSessionGroup concurrently manages multiple MCP session connections.\n\nTools, resources, and prompts are aggregated across servers. Servers may\nbe connected to or disconnected from at any point after initialization.\n\nThis abstractions can handle naming collisions using a custom user-provided\nhook.\n\"\"\"\n\nimport contextlib\nimport logging\nfrom collections.abc import Callable\nfrom datetime import timedelta\nfrom types import TracebackType\nfrom typing import Any, TypeAlias\n\nimport anyio\nfrom pydantic import BaseModel\nfrom typing_extensions import Self\n\nimport mcp\nfrom mcp import types\nfrom mcp.client.sse import sse_client\nfrom mcp.client.stdio import StdioServerParameters\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.exceptions import McpError\n\n\nclass SseServerParameters(BaseModel):\n    \"\"\"Parameters for intializing a sse_client.\"\"\"\n\n    # The endpoint URL.\n    url: str\n\n    # Optional headers to include in requests.\n    headers: dict[str, Any] | None = None\n\n    # HTTP timeout for regular operations.\n    timeout: float = 5\n\n    # Timeout for SSE read operations.\n    sse_read_timeout: float = 60 * 5\n\n\nclass StreamableHttpParameters(BaseModel):\n    \"\"\"Parameters for intializing a streamablehttp_client.\"\"\"\n\n    # The endpoint URL.\n    url: str\n\n    # Optional headers to include in requests.\n    headers: dict[str, Any] | None = None\n\n    # HTTP timeout for regular operations.\n    timeout: timedelta = timedelta(seconds=30)\n\n    # Timeout for SSE read operations.\n    sse_read_timeout: timedelta = timedelta(seconds=60 * 5)\n\n    # Close the client session when the transport closes.\n    terminate_on_close: bool = True\n\n\nServerParameters: TypeAlias = StdioServerParameters | SseServerParameters | StreamableHttpParameters\n\n\nclass ClientSessionGroup:\n    \"\"\"Client for managing connections to multiple MCP servers.\n\n    This class is responsible for encapsulating management of server connections.\n    It aggregates tools, resources, and prompts from all c\n... (content truncated)\n\n--- src/mcp/client/sse.py (py) ---\nimport logging\nfrom contextlib import asynccontextmanager\nfrom typing import Any\nfrom urllib.parse import urljoin, urlparse\n\nimport anyio\nimport httpx\nfrom anyio.abc import TaskStatus\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom httpx_sse import aconnect_sse\n\nimport mcp.types as types\nfrom mcp.shared._httpx_utils import McpHttpClientFactory, create_mcp_http_client\nfrom mcp.shared.message import SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n\ndef remove_request_params(url: str) -> str:\n    return urljoin(url, urlparse(url).path)\n\n\n@asynccontextmanager\nasync def sse_client(\n    url: str,\n    headers: dict[str, Any] | None = None,\n    timeout: float = 5,\n    sse_read_timeout: float = 60 * 5,\n    httpx_client_factory: McpHttpClientFactory = create_mcp_http_client,\n    auth: httpx.Auth | None = None,\n):\n    \"\"\"\n    Client transport for SSE.\n\n    `sse_read_timeout` determines how long (in seconds) the client will wait for a new\n    event before disconnecting. All other HTTP operations are controlled by `timeout`.\n\n    Args:\n        url: The SSE endpoint URL.\n        headers: Optional headers to include in requests.\n        timeout: HTTP timeout for regular operations.\n        sse_read_timeout: Timeout for SSE read operations.\n        auth: Optional HTTPX authentication handler.\n    \"\"\"\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async with anyio.create_task_group() as tg:\n        try:\n            logger.debug(f\"Connecting to SSE endpoint: {remove_request_params(url)}\")\n            async with httpx_client_factory(\n                headers=headers,\n... (content truncated)\n\n--- src/mcp/client/stdio/__init__.py (py) ---\nimport logging\nimport os\nimport sys\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\nfrom typing import Literal, TextIO\n\nimport anyio\nimport anyio.lowlevel\nfrom anyio.abc import Process\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom anyio.streams.text import TextReceiveStream\nfrom pydantic import BaseModel, Field\n\nimport mcp.types as types\nfrom mcp.os.posix.utilities import terminate_posix_process_tree\nfrom mcp.os.win32.utilities import (\n    FallbackProcess,\n    create_windows_process,\n    get_windows_executable_command,\n    terminate_windows_process_tree,\n)\nfrom mcp.shared.message import SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n# Environment variables to inherit by default\nDEFAULT_INHERITED_ENV_VARS = (\n    [\n        \"APPDATA\",\n        \"HOMEDRIVE\",\n        \"HOMEPATH\",\n        \"LOCALAPPDATA\",\n        \"PATH\",\n        \"PROCESSOR_ARCHITECTURE\",\n        \"SYSTEMDRIVE\",\n        \"SYSTEMROOT\",\n        \"TEMP\",\n        \"USERNAME\",\n        \"USERPROFILE\",\n    ]\n    if sys.platform == \"win32\"\n    else [\"HOME\", \"LOGNAME\", \"PATH\", \"SHELL\", \"TERM\", \"USER\"]\n)\n\n# Timeout for process termination before falling back to force kill\nPROCESS_TERMINATION_TIMEOUT = 2.0\n\n\ndef get_default_environment() -> dict[str, str]:\n    \"\"\"\n    Returns a default environment object including only environment variables deemed\n    safe to inherit.\n    \"\"\"\n    env: dict[str, str] = {}\n\n    for key in DEFAULT_INHERITED_ENV_VARS:\n        value = os.environ.get(key)\n        if value is None:\n            continue\n\n        if value.startswith(\"()\"):\n            # Skip functions, which are a security risk\n            continue\n\n        env[key] = value\n\n    return env\n\n\nclass StdioServerParameters(BaseModel):\n    command: str\n    \"\"\"The executable to run to start the server.\"\"\"\n\n    args: list[str] = Field(default_factory=list)\n    \"\"\"Command line arguments to pass to the executable.\"\"\"\n\n    env: dict[str, str] | None = None\n    \"\"\"\n    The en\n... (content truncated)\n\n--- src/mcp/client/streamable_http.py (py) ---\n\"\"\"\nStreamableHTTP Client Transport Module\n\nThis module implements the StreamableHTTP transport for MCP clients,\nproviding support for HTTP POST requests with optional SSE streaming responses\nand session management.\n\"\"\"\n\nimport logging\nfrom collections.abc import AsyncGenerator, Awaitable, Callable\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom datetime import timedelta\n\nimport anyio\nimport httpx\nfrom anyio.abc import TaskGroup\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom httpx_sse import EventSource, ServerSentEvent, aconnect_sse\n\nfrom mcp.shared._httpx_utils import McpHttpClientFactory, create_mcp_http_client\nfrom mcp.shared.message import ClientMessageMetadata, SessionMessage\nfrom mcp.types import (\n    ErrorData,\n    InitializeResult,\n    JSONRPCError,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    RequestId,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nSessionMessageOrError = SessionMessage | Exception\nStreamWriter = MemoryObjectSendStream[SessionMessageOrError]\nStreamReader = MemoryObjectReceiveStream[SessionMessage]\nGetSessionIdCallback = Callable[[], str | None]\n\nMCP_SESSION_ID = \"mcp-session-id\"\nMCP_PROTOCOL_VERSION = \"mcp-protocol-version\"\nLAST_EVENT_ID = \"last-event-id\"\nCONTENT_TYPE = \"content-type\"\nACCEPT = \"Accept\"\n\n\nJSON = \"application/json\"\nSSE = \"text/event-stream\"\n\n\nclass StreamableHTTPError(Exception):\n    \"\"\"Base exception for StreamableHTTP transport errors.\"\"\"\n\n\nclass ResumptionError(StreamableHTTPError):\n    \"\"\"Raised when resumption request is invalid.\"\"\"\n\n\n@dataclass\nclass RequestContext:\n    \"\"\"Context for a request operation.\"\"\"\n\n    client: httpx.AsyncClient\n    headers: dict[str, str]\n    session_id: str | None\n    session_message: SessionMessage\n    metadata: ClientMessageMetadata | None\n    read_stream_writer: StreamWriter\n    sse_read_timeout: float\n\n\nclass StreamableHTTPTransport:\n    \"\"\"StreamableHTTP client transport\n... (content truncated)\n\n--- src/mcp/client/websocket.py (py) ---\nimport json\nimport logging\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import ValidationError\nfrom websockets.asyncio.client import connect as ws_connect\nfrom websockets.typing import Subprotocol\n\nimport mcp.types as types\nfrom mcp.shared.message import SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def websocket_client(\n    url: str,\n) -> AsyncGenerator[\n    tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage]],\n    None,\n]:\n    \"\"\"\n    WebSocket client transport for MCP, symmetrical to the server version.\n\n    Connects to 'url' using the 'mcp' subprotocol, then yields:\n        (read_stream, write_stream)\n\n    - read_stream: As you read from this stream, you'll receive either valid\n      JSONRPCMessage objects or Exception objects (when validation fails).\n    - write_stream: Write JSONRPCMessage objects to this stream to send them\n      over the WebSocket to the server.\n    \"\"\"\n\n    # Create two in-memory streams:\n    # - One for incoming messages (read_stream, written by ws_reader)\n    # - One for outgoing messages (write_stream, read by ws_writer)\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    # Connect using websockets, requesting the \"mcp\" subprotocol\n    async with ws_connect(url, subprotocols=[Subprotocol(\"mcp\")]) as ws:\n\n        async def ws_reader():\n            \"\"\"\n            Reads text messages from the WebSocket, parses them as JSON-RPC messages,\n  \n... (content truncated)\n\n--- src/mcp/os/__init__.py (py) ---\n\"\"\"Platform-specific utilities for MCP.\"\"\"\n\n\n--- src/mcp/os/posix/__init__.py (py) ---\n\"\"\"POSIX-specific utilities for MCP.\"\"\"\n\n\n--- src/mcp/os/posix/utilities.py (py) ---\n\"\"\"\nPOSIX-specific functionality for stdio client operations.\n\"\"\"\n\nimport logging\nimport os\nimport signal\n\nimport anyio\nfrom anyio.abc import Process\n\nlogger = logging.getLogger(__name__)\n\n\nasync def terminate_posix_process_tree(process: Process, timeout_seconds: float = 2.0) -> None:\n    \"\"\"\n    Terminate a process and all its children on POSIX systems.\n\n    Uses os.killpg() for atomic process group termination.\n\n    Args:\n        process: The process to terminate\n        timeout_seconds: Timeout in seconds before force killing (default: 2.0)\n    \"\"\"\n    pid = getattr(process, \"pid\", None) or getattr(getattr(process, \"popen\", None), \"pid\", None)\n    if not pid:\n        # No PID means there's no process to terminate - it either never started,\n        # already exited, or we have an invalid process object\n        return\n\n    try:\n        pgid = os.getpgid(pid)\n        os.killpg(pgid, signal.SIGTERM)\n\n        with anyio.move_on_after(timeout_seconds):\n            while True:\n                try:\n                    # Check if process group still exists (signal 0 = check only)\n                    os.killpg(pgid, 0)\n                    await anyio.sleep(0.1)\n                except ProcessLookupError:\n                    return\n\n        try:\n            os.killpg(pgid, signal.SIGKILL)\n        except ProcessLookupError:\n            pass\n\n    except (ProcessLookupError, PermissionError, OSError) as e:\n        logger.warning(f\"Process group termination failed for PID {pid}: {e}, falling back to simple terminate\")\n        try:\n            process.terminate()\n            with anyio.fail_after(timeout_seconds):\n                await process.wait()\n        except Exception:\n            logger.warning(f\"Process termination failed for PID {pid}, attempting force kill\")\n            try:\n                process.kill()\n            except Exception:\n                logger.exception(f\"Failed to kill process {pid}\")\n\n\n--- src/mcp/os/win32/__init__.py (py) ---\n\"\"\"Windows-specific utilities for MCP.\"\"\"\n\n\n--- src/mcp/os/win32/utilities.py (py) ---\n\"\"\"\nWindows-specific functionality for stdio client operations.\n\"\"\"\n\nimport logging\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import BinaryIO, TextIO, cast\n\nimport anyio\nfrom anyio import to_thread\nfrom anyio.abc import Process\nfrom anyio.streams.file import FileReadStream, FileWriteStream\nfrom typing_extensions import deprecated\n\nlogger = logging.getLogger(\"client.stdio.win32\")\n\n# Windows-specific imports for Job Objects\nif sys.platform == \"win32\":\n    import pywintypes\n    import win32api\n    import win32con\n    import win32job\nelse:\n    # Type stubs for non-Windows platforms\n    win32api = None\n    win32con = None\n    win32job = None\n    pywintypes = None\n\nJobHandle = int\n\n\ndef get_windows_executable_command(command: str) -> str:\n    \"\"\"\n    Get the correct executable command normalized for Windows.\n\n    On Windows, commands might exist with specific extensions (.exe, .cmd, etc.)\n    that need to be located for proper execution.\n\n    Args:\n        command: Base command (e.g., 'uvx', 'npx')\n\n    Returns:\n        str: Windows-appropriate command path\n    \"\"\"\n    try:\n        # First check if command exists in PATH as-is\n        if command_path := shutil.which(command):\n            return command_path\n\n        # Check for Windows-specific extensions\n        for ext in [\".cmd\", \".bat\", \".exe\", \".ps1\"]:\n            ext_version = f\"{command}{ext}\"\n            if ext_path := shutil.which(ext_version):\n                return ext_path\n\n        # For regular commands or if we couldn't find special versions\n        return command\n    except OSError:\n        # Handle file system errors during path resolution\n        # (permissions, broken symlinks, etc.)\n        return command\n\n\nclass FallbackProcess:\n    \"\"\"\n    A fallback process wrapper for Windows to handle async I/O\n    when using subprocess.Popen, which provides sync-only FileIO objects.\n\n    This wraps stdin and stdout into async-compatible\n    streams (FileReadStream, FileWriteSt\n... (content truncated)\n\n--- src/mcp/server/__init__.py (py) ---\nfrom .fastmcp import FastMCP\nfrom .lowlevel import NotificationOptions, Server\nfrom .models import InitializationOptions\n\n__all__ = [\"Server\", \"FastMCP\", \"NotificationOptions\", \"InitializationOptions\"]\n\n\n--- src/mcp/server/__main__.py (py) ---\nimport importlib.metadata\nimport logging\nimport sys\n\nimport anyio\n\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import ServerCapabilities\n\nif not sys.warnoptions:\n    import warnings\n\n    warnings.simplefilter(\"ignore\")\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"server\")\n\n\nasync def receive_loop(session: ServerSession):\n    logger.info(\"Starting receive loop\")\n    async for message in session.incoming_messages:\n        if isinstance(message, Exception):\n            logger.error(\"Error: %s\", message)\n            continue\n\n        logger.info(\"Received message from client: %s\", message)\n\n\nasync def main():\n    version = importlib.metadata.version(\"mcp\")\n    async with stdio_server() as (read_stream, write_stream):\n        async with (\n            ServerSession(\n                read_stream,\n                write_stream,\n                InitializationOptions(\n                    server_name=\"mcp\",\n                    server_version=version,\n                    capabilities=ServerCapabilities(),\n                ),\n            ) as session,\n            write_stream,\n        ):\n            await receive_loop(session)\n\n\nif __name__ == \"__main__\":\n    anyio.run(main, backend=\"trio\")\n\n\n--- src/mcp/server/auth/__init__.py (py) ---\n\"\"\"\nMCP OAuth server authorization components.\n\"\"\"\n\n\n--- src/mcp/server/auth/errors.py (py) ---\nfrom pydantic import ValidationError\n\n\ndef stringify_pydantic_error(validation_error: ValidationError) -> str:\n    return \"\\n\".join(f\"{'.'.join(str(loc) for loc in e['loc'])}: {e['msg']}\" for e in validation_error.errors())\n\n\n--- src/mcp/server/auth/handlers/__init__.py (py) ---\n\"\"\"\nRequest handlers for MCP authorization endpoints.\n\"\"\"\n\n\n--- src/mcp/server/auth/handlers/authorize.py (py) ---\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Literal\n\nfrom pydantic import AnyUrl, BaseModel, Field, RootModel, ValidationError\nfrom starlette.datastructures import FormData, QueryParams\nfrom starlette.requests import Request\nfrom starlette.responses import RedirectResponse, Response\n\nfrom mcp.server.auth.errors import stringify_pydantic_error\nfrom mcp.server.auth.json_response import PydanticJSONResponse\nfrom mcp.server.auth.provider import (\n    AuthorizationErrorCode,\n    AuthorizationParams,\n    AuthorizeError,\n    OAuthAuthorizationServerProvider,\n    construct_redirect_uri,\n)\nfrom mcp.shared.auth import InvalidRedirectUriError, InvalidScopeError\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuthorizationRequest(BaseModel):\n    # See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1\n    client_id: str = Field(..., description=\"The client ID\")\n    redirect_uri: AnyUrl | None = Field(None, description=\"URL to redirect to after authorization\")\n\n    # see OAuthClientMetadata; we only support `code`\n    response_type: Literal[\"code\"] = Field(..., description=\"Must be 'code' for authorization code flow\")\n    code_challenge: str = Field(..., description=\"PKCE code challenge\")\n    code_challenge_method: Literal[\"S256\"] = Field(\"S256\", description=\"PKCE code challenge method, must be S256\")\n    state: str | None = Field(None, description=\"Optional state parameter\")\n    scope: str | None = Field(\n        None,\n        description=\"Optional scope; if specified, should be a space-separated list of scope strings\",\n    )\n    resource: str | None = Field(\n        None,\n        description=\"RFC 8707 resource indicator - the MCP server this token will be used with\",\n    )\n\n\nclass AuthorizationErrorResponse(BaseModel):\n    error: AuthorizationErrorCode\n    error_description: str | None\n    error_uri: AnyUrl | None = None\n    # must be set if provided in the request\n    state: str | None = None\n\n\ndef best_effort_extract_string(key: str, param\n... (content truncated)\n\n--- src/mcp/server/auth/handlers/metadata.py (py) ---\nfrom dataclasses import dataclass\n\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom mcp.server.auth.json_response import PydanticJSONResponse\nfrom mcp.shared.auth import OAuthMetadata, ProtectedResourceMetadata\n\n\n@dataclass\nclass MetadataHandler:\n    metadata: OAuthMetadata\n\n    async def handle(self, request: Request) -> Response:\n        return PydanticJSONResponse(\n            content=self.metadata,\n            headers={\"Cache-Control\": \"public, max-age=3600\"},  # Cache for 1 hour\n        )\n\n\n@dataclass\nclass ProtectedResourceMetadataHandler:\n    metadata: ProtectedResourceMetadata\n\n    async def handle(self, request: Request) -> Response:\n        return PydanticJSONResponse(\n            content=self.metadata,\n            headers={\"Cache-Control\": \"public, max-age=3600\"},  # Cache for 1 hour\n        )\n\n\n--- src/mcp/server/auth/handlers/register.py (py) ---\nimport secrets\nimport time\nfrom dataclasses import dataclass\nfrom typing import Any\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, RootModel, ValidationError\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom mcp.server.auth.errors import stringify_pydantic_error\nfrom mcp.server.auth.json_response import PydanticJSONResponse\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider, RegistrationError, RegistrationErrorCode\nfrom mcp.server.auth.settings import ClientRegistrationOptions\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata\n\n\nclass RegistrationRequest(RootModel[OAuthClientMetadata]):\n    # this wrapper is a no-op; it's just to separate out the types exposed to the\n    # provider from what we use in the HTTP handler\n    root: OAuthClientMetadata\n\n\nclass RegistrationErrorResponse(BaseModel):\n    error: RegistrationErrorCode\n    error_description: str | None\n\n\n@dataclass\nclass RegistrationHandler:\n    provider: OAuthAuthorizationServerProvider[Any, Any, Any]\n    options: ClientRegistrationOptions\n\n    async def handle(self, request: Request) -> Response:\n        # Implements dynamic client registration as defined in https://datatracker.ietf.org/doc/html/rfc7591#section-3.1\n        try:\n            # Parse request body as JSON\n            body = await request.json()\n            client_metadata = OAuthClientMetadata.model_validate(body)\n\n            # Scope validation is handled below\n        except ValidationError as validation_error:\n            return PydanticJSONResponse(\n                content=RegistrationErrorResponse(\n                    error=\"invalid_client_metadata\",\n                    error_description=stringify_pydantic_error(validation_error),\n                ),\n                status_code=400,\n            )\n\n        client_id = str(uuid4())\n        client_secret = None\n        if client_metadata.token_endpoint_auth_method != \"none\":\n            # cryptographically \n... (content truncated)\n\n--- src/mcp/server/auth/handlers/revoke.py (py) ---\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, ValidationError\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom mcp.server.auth.errors import (\n    stringify_pydantic_error,\n)\nfrom mcp.server.auth.json_response import PydanticJSONResponse\nfrom mcp.server.auth.middleware.client_auth import AuthenticationError, ClientAuthenticator\nfrom mcp.server.auth.provider import AccessToken, OAuthAuthorizationServerProvider, RefreshToken\n\n\nclass RevocationRequest(BaseModel):\n    \"\"\"\n    # See https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n    \"\"\"\n\n    token: str\n    token_type_hint: Literal[\"access_token\", \"refresh_token\"] | None = None\n    client_id: str\n    client_secret: str | None\n\n\nclass RevocationErrorResponse(BaseModel):\n    error: Literal[\"invalid_request\", \"unauthorized_client\"]\n    error_description: str | None = None\n\n\n@dataclass\nclass RevocationHandler:\n    provider: OAuthAuthorizationServerProvider[Any, Any, Any]\n    client_authenticator: ClientAuthenticator\n\n    async def handle(self, request: Request) -> Response:\n        \"\"\"\n        Handler for the OAuth 2.0 Token Revocation endpoint.\n        \"\"\"\n        try:\n            form_data = await request.form()\n            revocation_request = RevocationRequest.model_validate(dict(form_data))\n        except ValidationError as e:\n            return PydanticJSONResponse(\n                status_code=400,\n                content=RevocationErrorResponse(\n                    error=\"invalid_request\",\n                    error_description=stringify_pydantic_error(e),\n                ),\n            )\n\n        # Authenticate client\n        try:\n            client = await self.client_authenticator.authenticate(\n                revocation_request.client_id, revocation_request.client_secret\n            )\n        except AuthenticationError as e:\n            return PydanticJSONResponse(\n                status\n... (content truncated)\n\n--- src/mcp/server/auth/handlers/token.py (py) ---\nimport base64\nimport hashlib\nimport time\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Literal\n\nfrom pydantic import AnyHttpUrl, AnyUrl, BaseModel, Field, RootModel, ValidationError\nfrom starlette.requests import Request\n\nfrom mcp.server.auth.errors import stringify_pydantic_error\nfrom mcp.server.auth.json_response import PydanticJSONResponse\nfrom mcp.server.auth.middleware.client_auth import AuthenticationError, ClientAuthenticator\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider, TokenError, TokenErrorCode\nfrom mcp.shared.auth import OAuthToken\n\n\nclass AuthorizationCodeRequest(BaseModel):\n    # See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3\n    grant_type: Literal[\"authorization_code\"]\n    code: str = Field(..., description=\"The authorization code\")\n    redirect_uri: AnyUrl | None = Field(None, description=\"Must be the same as redirect URI provided in /authorize\")\n    client_id: str\n    # we use the client_secret param, per https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1\n    client_secret: str | None = None\n    # See https://datatracker.ietf.org/doc/html/rfc7636#section-4.5\n    code_verifier: str = Field(..., description=\"PKCE code verifier\")\n    # RFC 8707 resource indicator\n    resource: str | None = Field(None, description=\"Resource indicator for the token\")\n\n\nclass RefreshTokenRequest(BaseModel):\n    # See https://datatracker.ietf.org/doc/html/rfc6749#section-6\n    grant_type: Literal[\"refresh_token\"]\n    refresh_token: str = Field(..., description=\"The refresh token\")\n    scope: str | None = Field(None, description=\"Optional scope parameter\")\n    client_id: str\n    # we use the client_secret param, per https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1\n    client_secret: str | None = None\n    # RFC 8707 resource indicator\n    resource: str | None = Field(None, description=\"Resource indicator for the token\")\n\n\nclass TokenRequest(\n    RootModel[\n        Annotated[\n            Auth\n... (content truncated)\n\n--- src/mcp/server/auth/json_response.py (py) ---\nfrom typing import Any\n\nfrom starlette.responses import JSONResponse\n\n\nclass PydanticJSONResponse(JSONResponse):\n    # use pydantic json serialization instead of the stock `json.dumps`,\n    # so that we can handle serializing pydantic models like AnyHttpUrl\n    def render(self, content: Any) -> bytes:\n        return content.model_dump_json(exclude_none=True).encode(\"utf-8\")\n\n\n--- src/mcp/server/auth/middleware/__init__.py (py) ---\n\"\"\"\nMiddleware for MCP authorization.\n\"\"\"\n\n\n--- src/mcp/server/auth/middleware/auth_context.py (py) ---\nimport contextvars\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom mcp.server.auth.middleware.bearer_auth import AuthenticatedUser\nfrom mcp.server.auth.provider import AccessToken\n\n# Create a contextvar to store the authenticated user\n# The default is None, indicating no authenticated user is present\nauth_context_var = contextvars.ContextVar[AuthenticatedUser | None](\"auth_context\", default=None)\n\n\ndef get_access_token() -> AccessToken | None:\n    \"\"\"\n    Get the access token from the current context.\n\n    Returns:\n        The access token if an authenticated user is available, None otherwise.\n    \"\"\"\n    auth_user = auth_context_var.get()\n    return auth_user.access_token if auth_user else None\n\n\nclass AuthContextMiddleware:\n    \"\"\"\n    Middleware that extracts the authenticated user from the request\n    and sets it in a contextvar for easy access throughout the request lifecycle.\n\n    This middleware should be added after the AuthenticationMiddleware in the\n    middleware stack to ensure that the user is properly authenticated before\n    being stored in the context.\n    \"\"\"\n\n    def __init__(self, app: ASGIApp):\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        user = scope.get(\"user\")\n        if isinstance(user, AuthenticatedUser):\n            # Set the authenticated user in the contextvar\n            token = auth_context_var.set(user)\n            try:\n                await self.app(scope, receive, send)\n            finally:\n                auth_context_var.reset(token)\n        else:\n            # No authenticated user, just process the request\n            await self.app(scope, receive, send)\n\n\n--- src/mcp/server/auth/middleware/bearer_auth.py (py) ---\nimport json\nimport time\nfrom typing import Any\n\nfrom pydantic import AnyHttpUrl\nfrom starlette.authentication import AuthCredentials, AuthenticationBackend, SimpleUser\nfrom starlette.requests import HTTPConnection\nfrom starlette.types import Receive, Scope, Send\n\nfrom mcp.server.auth.provider import AccessToken, TokenVerifier\n\n\nclass AuthenticatedUser(SimpleUser):\n    \"\"\"User with authentication info.\"\"\"\n\n    def __init__(self, auth_info: AccessToken):\n        super().__init__(auth_info.client_id)\n        self.access_token = auth_info\n        self.scopes = auth_info.scopes\n\n\nclass BearerAuthBackend(AuthenticationBackend):\n    \"\"\"\n    Authentication backend that validates Bearer tokens using a TokenVerifier.\n    \"\"\"\n\n    def __init__(self, token_verifier: TokenVerifier):\n        self.token_verifier = token_verifier\n\n    async def authenticate(self, conn: HTTPConnection):\n        auth_header = next(\n            (conn.headers.get(key) for key in conn.headers if key.lower() == \"authorization\"),\n            None,\n        )\n        if not auth_header or not auth_header.lower().startswith(\"bearer \"):\n            return None\n\n        token = auth_header[7:]  # Remove \"Bearer \" prefix\n\n        # Validate the token with the verifier\n        auth_info = await self.token_verifier.verify_token(token)\n\n        if not auth_info:\n            return None\n\n        if auth_info.expires_at and auth_info.expires_at < int(time.time()):\n            return None\n\n        return AuthCredentials(auth_info.scopes), AuthenticatedUser(auth_info)\n\n\nclass RequireAuthMiddleware:\n    \"\"\"\n    Middleware that requires a valid Bearer token in the Authorization header.\n\n    This will validate the token with the auth provider and store the resulting\n    auth info in the request state.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Any,\n        required_scopes: list[str],\n        resource_metadata_url: AnyHttpUrl | None = None,\n    ):\n        \"\"\"\n        Initialize the middleware.\n\n        Args:\n  \n... (content truncated)\n\n--- src/mcp/server/auth/middleware/client_auth.py (py) ---\nimport time\nfrom typing import Any\n\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider\nfrom mcp.shared.auth import OAuthClientInformationFull\n\n\nclass AuthenticationError(Exception):\n    def __init__(self, message: str):\n        self.message = message\n\n\nclass ClientAuthenticator:\n    \"\"\"\n    ClientAuthenticator is a callable which validates requests from a client\n    application, used to verify /token calls.\n    If, during registration, the client requested to be issued a secret, the\n    authenticator asserts that /token calls must be authenticated with\n    that same token.\n    NOTE: clients can opt for no authentication during registration, in which case this\n    logic is skipped.\n    \"\"\"\n\n    def __init__(self, provider: OAuthAuthorizationServerProvider[Any, Any, Any]):\n        \"\"\"\n        Initialize the dependency.\n\n        Args:\n            provider: Provider to look up client information\n        \"\"\"\n        self.provider = provider\n\n    async def authenticate(self, client_id: str, client_secret: str | None) -> OAuthClientInformationFull:\n        # Look up client information\n        client = await self.provider.get_client(client_id)\n        if not client:\n            raise AuthenticationError(\"Invalid client_id\")\n\n        # If client from the store expects a secret, validate that the request provides\n        # that secret\n        if client.client_secret:\n            if not client_secret:\n                raise AuthenticationError(\"Client secret is required\")\n\n            if client.client_secret != client_secret:\n                raise AuthenticationError(\"Invalid client_secret\")\n\n            if client.client_secret_expires_at and client.client_secret_expires_at < int(time.time()):\n                raise AuthenticationError(\"Client secret has expired\")\n\n        return client\n\n\n--- src/mcp/server/auth/provider.py (py) ---\nfrom dataclasses import dataclass\nfrom typing import Generic, Literal, Protocol, TypeVar\nfrom urllib.parse import parse_qs, urlencode, urlparse, urlunparse\n\nfrom pydantic import AnyUrl, BaseModel\n\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthToken\n\n\nclass AuthorizationParams(BaseModel):\n    state: str | None\n    scopes: list[str] | None\n    code_challenge: str\n    redirect_uri: AnyUrl\n    redirect_uri_provided_explicitly: bool\n    resource: str | None = None  # RFC 8707 resource indicator\n\n\nclass AuthorizationCode(BaseModel):\n    code: str\n    scopes: list[str]\n    expires_at: float\n    client_id: str\n    code_challenge: str\n    redirect_uri: AnyUrl\n    redirect_uri_provided_explicitly: bool\n    resource: str | None = None  # RFC 8707 resource indicator\n\n\nclass RefreshToken(BaseModel):\n    token: str\n    client_id: str\n    scopes: list[str]\n    expires_at: int | None = None\n\n\nclass AccessToken(BaseModel):\n    token: str\n    client_id: str\n    scopes: list[str]\n    expires_at: int | None = None\n    resource: str | None = None  # RFC 8707 resource indicator\n\n\nRegistrationErrorCode = Literal[\n    \"invalid_redirect_uri\",\n    \"invalid_client_metadata\",\n    \"invalid_software_statement\",\n    \"unapproved_software_statement\",\n]\n\n\n@dataclass(frozen=True)\nclass RegistrationError(Exception):\n    error: RegistrationErrorCode\n    error_description: str | None = None\n\n\nAuthorizationErrorCode = Literal[\n    \"invalid_request\",\n    \"unauthorized_client\",\n    \"access_denied\",\n    \"unsupported_response_type\",\n    \"invalid_scope\",\n    \"server_error\",\n    \"temporarily_unavailable\",\n]\n\n\n@dataclass(frozen=True)\nclass AuthorizeError(Exception):\n    error: AuthorizationErrorCode\n    error_description: str | None = None\n\n\nTokenErrorCode = Literal[\n    \"invalid_request\",\n    \"invalid_client\",\n    \"invalid_grant\",\n    \"unauthorized_client\",\n    \"unsupported_grant_type\",\n    \"invalid_scope\",\n]\n\n\n@dataclass(frozen=True)\nclass TokenError(Exception):\n    error: TokenErrorCode\n    er\n... (content truncated)\n\n--- src/mcp/server/auth/routes.py (py) ---\nfrom collections.abc import Awaitable, Callable\nfrom typing import Any\n\nfrom pydantic import AnyHttpUrl\nfrom starlette.middleware.cors import CORSMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import Route, request_response  # type: ignore\nfrom starlette.types import ASGIApp\n\nfrom mcp.server.auth.handlers.authorize import AuthorizationHandler\nfrom mcp.server.auth.handlers.metadata import MetadataHandler\nfrom mcp.server.auth.handlers.register import RegistrationHandler\nfrom mcp.server.auth.handlers.revoke import RevocationHandler\nfrom mcp.server.auth.handlers.token import TokenHandler\nfrom mcp.server.auth.middleware.client_auth import ClientAuthenticator\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider\nfrom mcp.server.auth.settings import ClientRegistrationOptions, RevocationOptions\nfrom mcp.server.streamable_http import MCP_PROTOCOL_VERSION_HEADER\nfrom mcp.shared.auth import OAuthMetadata\n\n\ndef validate_issuer_url(url: AnyHttpUrl):\n    \"\"\"\n    Validate that the issuer URL meets OAuth 2.0 requirements.\n\n    Args:\n        url: The issuer URL to validate\n\n    Raises:\n        ValueError: If the issuer URL is invalid\n    \"\"\"\n\n    # RFC 8414 requires HTTPS, but we allow localhost HTTP for testing\n    if (\n        url.scheme != \"https\"\n        and url.host != \"localhost\"\n        and (url.host is not None and not url.host.startswith(\"127.0.0.1\"))\n    ):\n        raise ValueError(\"Issuer URL must be HTTPS\")\n\n    # No fragments or query parameters allowed\n    if url.fragment:\n        raise ValueError(\"Issuer URL must not have a fragment\")\n    if url.query:\n        raise ValueError(\"Issuer URL must not have a query string\")\n\n\nAUTHORIZATION_PATH = \"/authorize\"\nTOKEN_PATH = \"/token\"\nREGISTRATION_PATH = \"/register\"\nREVOCATION_PATH = \"/revoke\"\n\n\ndef cors_middleware(\n    handler: Callable[[Request], Response | Awaitable[Response]],\n    allow_methods: list[str],\n) -> ASGIApp:\n    cors_app = CORSMi\n... (content truncated)\n\n--- src/mcp/server/auth/settings.py (py) ---\nfrom pydantic import AnyHttpUrl, BaseModel, Field\n\n\nclass ClientRegistrationOptions(BaseModel):\n    enabled: bool = False\n    client_secret_expiry_seconds: int | None = None\n    valid_scopes: list[str] | None = None\n    default_scopes: list[str] | None = None\n\n\nclass RevocationOptions(BaseModel):\n    enabled: bool = False\n\n\nclass AuthSettings(BaseModel):\n    issuer_url: AnyHttpUrl = Field(\n        ...,\n        description=\"OAuth authorization server URL that issues tokens for this resource server.\",\n    )\n    service_documentation_url: AnyHttpUrl | None = None\n    client_registration_options: ClientRegistrationOptions | None = None\n    revocation_options: RevocationOptions | None = None\n    required_scopes: list[str] | None = None\n\n    # Resource Server settings (when operating as RS only)\n    resource_server_url: AnyHttpUrl | None = Field(\n        ...,\n        description=\"The URL of the MCP server to be used as the resource identifier \"\n        \"and base route to look up OAuth Protected Resource Metadata.\",\n    )\n\n\n--- src/mcp/server/elicitation.py (py) ---\n\"\"\"Elicitation utilities for MCP servers.\"\"\"\n\nfrom __future__ import annotations\n\nimport types\nfrom typing import Generic, Literal, TypeVar, Union, get_args, get_origin\n\nfrom pydantic import BaseModel\nfrom pydantic.fields import FieldInfo\n\nfrom mcp.server.session import ServerSession\nfrom mcp.types import RequestId\n\nElicitSchemaModelT = TypeVar(\"ElicitSchemaModelT\", bound=BaseModel)\n\n\nclass AcceptedElicitation(BaseModel, Generic[ElicitSchemaModelT]):\n    \"\"\"Result when user accepts the elicitation.\"\"\"\n\n    action: Literal[\"accept\"] = \"accept\"\n    data: ElicitSchemaModelT\n\n\nclass DeclinedElicitation(BaseModel):\n    \"\"\"Result when user declines the elicitation.\"\"\"\n\n    action: Literal[\"decline\"] = \"decline\"\n\n\nclass CancelledElicitation(BaseModel):\n    \"\"\"Result when user cancels the elicitation.\"\"\"\n\n    action: Literal[\"cancel\"] = \"cancel\"\n\n\nElicitationResult = AcceptedElicitation[ElicitSchemaModelT] | DeclinedElicitation | CancelledElicitation\n\n\n# Primitive types allowed in elicitation schemas\n_ELICITATION_PRIMITIVE_TYPES = (str, int, float, bool)\n\n\ndef _validate_elicitation_schema(schema: type[BaseModel]) -> None:\n    \"\"\"Validate that a Pydantic model only contains primitive field types.\"\"\"\n    for field_name, field_info in schema.model_fields.items():\n        if not _is_primitive_field(field_info):\n            raise TypeError(\n                f\"Elicitation schema field '{field_name}' must be a primitive type \"\n                f\"{_ELICITATION_PRIMITIVE_TYPES} or Optional of these types. \"\n                f\"Complex types like lists, dicts, or nested models are not allowed.\"\n            )\n\n\ndef _is_primitive_field(field_info: FieldInfo) -> bool:\n    \"\"\"Check if a field is a primitive type allowed in elicitation schemas.\"\"\"\n    annotation = field_info.annotation\n\n    # Handle None type\n    if annotation is types.NoneType:\n        return True\n\n    # Handle basic primitive types\n    if annotation in _ELICITATION_PRIMITIVE_TYPES:\n        return True\n\n    # Handle Union ty\n... (content truncated)\n\n--- src/mcp/server/fastmcp/__init__.py (py) ---\n\"\"\"FastMCP - A more ergonomic interface for MCP servers.\"\"\"\n\nfrom importlib.metadata import version\n\nfrom .server import Context, FastMCP\nfrom .utilities.types import Image\n\n__version__ = version(\"mcp\")\n__all__ = [\"FastMCP\", \"Context\", \"Image\"]\n\n\n--- src/mcp/server/fastmcp/exceptions.py (py) ---\n\"\"\"Custom exceptions for FastMCP.\"\"\"\n\n\nclass FastMCPError(Exception):\n    \"\"\"Base error for FastMCP.\"\"\"\n\n\nclass ValidationError(FastMCPError):\n    \"\"\"Error in validating parameters or return values.\"\"\"\n\n\nclass ResourceError(FastMCPError):\n    \"\"\"Error in resource operations.\"\"\"\n\n\nclass ToolError(FastMCPError):\n    \"\"\"Error in tool operations.\"\"\"\n\n\nclass InvalidSignature(Exception):\n    \"\"\"Invalid signature for use with FastMCP.\"\"\"\n\n\n--- src/mcp/server/fastmcp/prompts/__init__.py (py) ---\nfrom .base import Prompt\nfrom .manager import PromptManager\n\n__all__ = [\"Prompt\", \"PromptManager\"]\n\n\n--- src/mcp/server/fastmcp/prompts/base.py (py) ---\n\"\"\"Base classes for FastMCP prompts.\"\"\"\n\nimport inspect\nfrom collections.abc import Awaitable, Callable, Sequence\nfrom typing import Any, Literal\n\nimport pydantic_core\nfrom pydantic import BaseModel, Field, TypeAdapter, validate_call\n\nfrom mcp.types import ContentBlock, TextContent\n\n\nclass Message(BaseModel):\n    \"\"\"Base class for all prompt messages.\"\"\"\n\n    role: Literal[\"user\", \"assistant\"]\n    content: ContentBlock\n\n    def __init__(self, content: str | ContentBlock, **kwargs: Any):\n        if isinstance(content, str):\n            content = TextContent(type=\"text\", text=content)\n        super().__init__(content=content, **kwargs)\n\n\nclass UserMessage(Message):\n    \"\"\"A message from the user.\"\"\"\n\n    role: Literal[\"user\", \"assistant\"] = \"user\"\n\n    def __init__(self, content: str | ContentBlock, **kwargs: Any):\n        super().__init__(content=content, **kwargs)\n\n\nclass AssistantMessage(Message):\n    \"\"\"A message from the assistant.\"\"\"\n\n    role: Literal[\"user\", \"assistant\"] = \"assistant\"\n\n    def __init__(self, content: str | ContentBlock, **kwargs: Any):\n        super().__init__(content=content, **kwargs)\n\n\nmessage_validator = TypeAdapter[UserMessage | AssistantMessage](UserMessage | AssistantMessage)\n\nSyncPromptResult = str | Message | dict[str, Any] | Sequence[str | Message | dict[str, Any]]\nPromptResult = SyncPromptResult | Awaitable[SyncPromptResult]\n\n\nclass PromptArgument(BaseModel):\n    \"\"\"An argument that can be passed to a prompt.\"\"\"\n\n    name: str = Field(description=\"Name of the argument\")\n    description: str | None = Field(None, description=\"Description of what the argument does\")\n    required: bool = Field(default=False, description=\"Whether the argument is required\")\n\n\nclass Prompt(BaseModel):\n    \"\"\"A prompt template that can be rendered with parameters.\"\"\"\n\n    name: str = Field(description=\"Name of the prompt\")\n    title: str | None = Field(None, description=\"Human-readable title of the prompt\")\n    description: str | None = Field(None, descript\n... (content truncated)\n\n--- src/mcp/server/fastmcp/prompts/manager.py (py) ---\n\"\"\"Prompt management functionality.\"\"\"\n\nfrom typing import Any\n\nfrom mcp.server.fastmcp.prompts.base import Message, Prompt\nfrom mcp.server.fastmcp.utilities.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass PromptManager:\n    \"\"\"Manages FastMCP prompts.\"\"\"\n\n    def __init__(self, warn_on_duplicate_prompts: bool = True):\n        self._prompts: dict[str, Prompt] = {}\n        self.warn_on_duplicate_prompts = warn_on_duplicate_prompts\n\n    def get_prompt(self, name: str) -> Prompt | None:\n        \"\"\"Get prompt by name.\"\"\"\n        return self._prompts.get(name)\n\n    def list_prompts(self) -> list[Prompt]:\n        \"\"\"List all registered prompts.\"\"\"\n        return list(self._prompts.values())\n\n    def add_prompt(\n        self,\n        prompt: Prompt,\n    ) -> Prompt:\n        \"\"\"Add a prompt to the manager.\"\"\"\n\n        # Check for duplicates\n        existing = self._prompts.get(prompt.name)\n        if existing:\n            if self.warn_on_duplicate_prompts:\n                logger.warning(f\"Prompt already exists: {prompt.name}\")\n            return existing\n\n        self._prompts[prompt.name] = prompt\n        return prompt\n\n    async def render_prompt(self, name: str, arguments: dict[str, Any] | None = None) -> list[Message]:\n        \"\"\"Render a prompt by name with arguments.\"\"\"\n        prompt = self.get_prompt(name)\n        if not prompt:\n            raise ValueError(f\"Unknown prompt: {name}\")\n\n        return await prompt.render(arguments)\n\n\n--- src/mcp/server/fastmcp/prompts/prompt_manager.py (py) ---\n\"\"\"Prompt management functionality.\"\"\"\n\nfrom mcp.server.fastmcp.prompts.base import Prompt\nfrom mcp.server.fastmcp.utilities.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass PromptManager:\n    \"\"\"Manages FastMCP prompts.\"\"\"\n\n    def __init__(self, warn_on_duplicate_prompts: bool = True):\n        self._prompts: dict[str, Prompt] = {}\n        self.warn_on_duplicate_prompts = warn_on_duplicate_prompts\n\n    def add_prompt(self, prompt: Prompt) -> Prompt:\n        \"\"\"Add a prompt to the manager.\"\"\"\n        logger.debug(f\"Adding prompt: {prompt.name}\")\n        existing = self._prompts.get(prompt.name)\n        if existing:\n            if self.warn_on_duplicate_prompts:\n                logger.warning(f\"Prompt already exists: {prompt.name}\")\n            return existing\n        self._prompts[prompt.name] = prompt\n        return prompt\n\n    def get_prompt(self, name: str) -> Prompt | None:\n        \"\"\"Get prompt by name.\"\"\"\n        return self._prompts.get(name)\n\n    def list_prompts(self) -> list[Prompt]:\n        \"\"\"List all registered prompts.\"\"\"\n        return list(self._prompts.values())\n\n\n--- src/mcp/server/fastmcp/resources/__init__.py (py) ---\nfrom .base import Resource\nfrom .resource_manager import ResourceManager\nfrom .templates import ResourceTemplate\nfrom .types import (\n    BinaryResource,\n    DirectoryResource,\n    FileResource,\n    FunctionResource,\n    HttpResource,\n    TextResource,\n)\n\n__all__ = [\n    \"Resource\",\n    \"TextResource\",\n    \"BinaryResource\",\n    \"FunctionResource\",\n    \"FileResource\",\n    \"HttpResource\",\n    \"DirectoryResource\",\n    \"ResourceTemplate\",\n    \"ResourceManager\",\n]\n\n\n--- src/mcp/server/fastmcp/resources/base.py (py) ---\n\"\"\"Base classes and interfaces for FastMCP resources.\"\"\"\n\nimport abc\nfrom typing import Annotated\n\nfrom pydantic import (\n    AnyUrl,\n    BaseModel,\n    ConfigDict,\n    Field,\n    UrlConstraints,\n    ValidationInfo,\n    field_validator,\n)\n\n\nclass Resource(BaseModel, abc.ABC):\n    \"\"\"Base class for all resources.\"\"\"\n\n    model_config = ConfigDict(validate_default=True)\n\n    uri: Annotated[AnyUrl, UrlConstraints(host_required=False)] = Field(default=..., description=\"URI of the resource\")\n    name: str | None = Field(description=\"Name of the resource\", default=None)\n    title: str | None = Field(description=\"Human-readable title of the resource\", default=None)\n    description: str | None = Field(description=\"Description of the resource\", default=None)\n    mime_type: str = Field(\n        default=\"text/plain\",\n        description=\"MIME type of the resource content\",\n        pattern=r\"^[a-zA-Z0-9]+/[a-zA-Z0-9\\-+.]+$\",\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    @classmethod\n    def set_default_name(cls, name: str | None, info: ValidationInfo) -> str:\n        \"\"\"Set default name from URI if not provided.\"\"\"\n        if name:\n            return name\n        if uri := info.data.get(\"uri\"):\n            return str(uri)\n        raise ValueError(\"Either name or uri must be provided\")\n\n    @abc.abstractmethod\n    async def read(self) -> str | bytes:\n        \"\"\"Read the resource content.\"\"\"\n        pass\n\n\n--- src/mcp/server/fastmcp/resources/resource_manager.py (py) ---\n\"\"\"Resource manager functionality.\"\"\"\n\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom pydantic import AnyUrl\n\nfrom mcp.server.fastmcp.resources.base import Resource\nfrom mcp.server.fastmcp.resources.templates import ResourceTemplate\nfrom mcp.server.fastmcp.utilities.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass ResourceManager:\n    \"\"\"Manages FastMCP resources.\"\"\"\n\n    def __init__(self, warn_on_duplicate_resources: bool = True):\n        self._resources: dict[str, Resource] = {}\n        self._templates: dict[str, ResourceTemplate] = {}\n        self.warn_on_duplicate_resources = warn_on_duplicate_resources\n\n    def add_resource(self, resource: Resource) -> Resource:\n        \"\"\"Add a resource to the manager.\n\n        Args:\n            resource: A Resource instance to add\n\n        Returns:\n            The added resource. If a resource with the same URI already exists,\n            returns the existing resource.\n        \"\"\"\n        logger.debug(\n            \"Adding resource\",\n            extra={\n                \"uri\": resource.uri,\n                \"type\": type(resource).__name__,\n                \"resource_name\": resource.name,\n            },\n        )\n        existing = self._resources.get(str(resource.uri))\n        if existing:\n            if self.warn_on_duplicate_resources:\n                logger.warning(f\"Resource already exists: {resource.uri}\")\n            return existing\n        self._resources[str(resource.uri)] = resource\n        return resource\n\n    def add_template(\n        self,\n        fn: Callable[..., Any],\n        uri_template: str,\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        mime_type: str | None = None,\n    ) -> ResourceTemplate:\n        \"\"\"Add a template from a function.\"\"\"\n        template = ResourceTemplate.from_function(\n            fn,\n            uri_template=uri_template,\n            name=name,\n            title=title,\n            descript\n... (content truncated)\n\n--- src/mcp/server/fastmcp/resources/templates.py (py) ---\n\"\"\"Resource template functionality.\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nimport re\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, TypeAdapter, validate_call\n\nfrom mcp.server.fastmcp.resources.types import FunctionResource, Resource\n\n\nclass ResourceTemplate(BaseModel):\n    \"\"\"A template for dynamically creating resources.\"\"\"\n\n    uri_template: str = Field(description=\"URI template with parameters (e.g. weather://{city}/current)\")\n    name: str = Field(description=\"Name of the resource\")\n    title: str | None = Field(description=\"Human-readable title of the resource\", default=None)\n    description: str | None = Field(description=\"Description of what the resource does\")\n    mime_type: str = Field(default=\"text/plain\", description=\"MIME type of the resource content\")\n    fn: Callable[..., Any] = Field(exclude=True)\n    parameters: dict[str, Any] = Field(description=\"JSON schema for function parameters\")\n\n    @classmethod\n    def from_function(\n        cls,\n        fn: Callable[..., Any],\n        uri_template: str,\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        mime_type: str | None = None,\n    ) -> ResourceTemplate:\n        \"\"\"Create a template from a function.\"\"\"\n        func_name = name or fn.__name__\n        if func_name == \"<lambda>\":\n            raise ValueError(\"You must provide a name for lambda functions\")\n\n        # Get schema from TypeAdapter - will fail if function isn't properly typed\n        parameters = TypeAdapter(fn).json_schema()\n\n        # ensure the arguments are properly cast\n        fn = validate_call(fn)\n\n        return cls(\n            uri_template=uri_template,\n            name=func_name,\n            title=title,\n            description=description or fn.__doc__ or \"\",\n            mime_type=mime_type or \"text/plain\",\n            fn=fn,\n            parameters=parameters,\n        )\n\n    def matches(self, uri: st\n... (content truncated)\n\n--- src/mcp/server/fastmcp/resources/types.py (py) ---\n\"\"\"Concrete resource implementations.\"\"\"\n\nimport inspect\nimport json\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport anyio\nimport anyio.to_thread\nimport httpx\nimport pydantic\nimport pydantic_core\nfrom pydantic import AnyUrl, Field, ValidationInfo, validate_call\n\nfrom mcp.server.fastmcp.resources.base import Resource\n\n\nclass TextResource(Resource):\n    \"\"\"A resource that reads from a string.\"\"\"\n\n    text: str = Field(description=\"Text content of the resource\")\n\n    async def read(self) -> str:\n        \"\"\"Read the text content.\"\"\"\n        return self.text\n\n\nclass BinaryResource(Resource):\n    \"\"\"A resource that reads from bytes.\"\"\"\n\n    data: bytes = Field(description=\"Binary content of the resource\")\n\n    async def read(self) -> bytes:\n        \"\"\"Read the binary content.\"\"\"\n        return self.data\n\n\nclass FunctionResource(Resource):\n    \"\"\"A resource that defers data loading by wrapping a function.\n\n    The function is only called when the resource is read, allowing for lazy loading\n    of potentially expensive data. This is particularly useful when listing resources,\n    as the function won't be called until the resource is actually accessed.\n\n    The function can return:\n    - str for text content (default)\n    - bytes for binary content\n    - other types will be converted to JSON\n    \"\"\"\n\n    fn: Callable[[], Any] = Field(exclude=True)\n\n    async def read(self) -> str | bytes:\n        \"\"\"Read the resource by calling the wrapped function.\"\"\"\n        try:\n            # Call the function first to see if it returns a coroutine\n            result = self.fn()\n            # If it's a coroutine, await it\n            if inspect.iscoroutine(result):\n                result = await result\n\n            if isinstance(result, Resource):\n                return await result.read()\n            elif isinstance(result, bytes):\n                return result\n            elif isinstance(result, str):\n                return result\n           \n... (content truncated)\n\n--- src/mcp/server/fastmcp/server.py (py) ---\n\"\"\"FastMCP - A more ergonomic interface for MCP servers.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport inspect\nimport re\nfrom collections.abc import AsyncIterator, Awaitable, Callable, Iterable, Sequence\nfrom contextlib import (\n    AbstractAsyncContextManager,\n    asynccontextmanager,\n)\nfrom typing import Any, Generic, Literal\n\nimport anyio\nimport pydantic_core\nfrom pydantic import BaseModel, Field\nfrom pydantic.networks import AnyUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.authentication import AuthenticationMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import Mount, Route\nfrom starlette.types import Receive, Scope, Send\n\nfrom mcp.server.auth.middleware.auth_context import AuthContextMiddleware\nfrom mcp.server.auth.middleware.bearer_auth import (\n    BearerAuthBackend,\n    RequireAuthMiddleware,\n)\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider, ProviderTokenVerifier, TokenVerifier\nfrom mcp.server.auth.settings import AuthSettings\nfrom mcp.server.elicitation import ElicitationResult, ElicitSchemaModelT, elicit_with_validation\nfrom mcp.server.fastmcp.exceptions import ResourceError\nfrom mcp.server.fastmcp.prompts import Prompt, PromptManager\nfrom mcp.server.fastmcp.resources import FunctionResource, Resource, ResourceManager\nfrom mcp.server.fastmcp.tools import Tool, ToolManager\nfrom mcp.server.fastmcp.utilities.logging import configure_logging, get_logger\nfrom mcp.server.lowlevel.helper_types import ReadResourceContents\nfrom mcp.server.lowlevel.server import LifespanResultT\nfrom mcp.server.lowlevel.server import Server as MCPServer\nfrom mcp.server.lowlevel.server import lifespan as default_lifespan\nfrom mcp.server.session import ServerSession, ServerSessionT\nfrom mcp.server.sse import SseServerTransport\nfrom mcp.server.stdi\n... (content truncated)\n\n--- src/mcp/server/fastmcp/tools/__init__.py (py) ---\nfrom .base import Tool\nfrom .tool_manager import ToolManager\n\n__all__ = [\"Tool\", \"ToolManager\"]\n\n\n--- src/mcp/server/fastmcp/tools/base.py (py) ---\nfrom __future__ import annotations as _annotations\n\nimport functools\nimport inspect\nfrom collections.abc import Callable\nfrom functools import cached_property\nfrom typing import TYPE_CHECKING, Any, get_origin\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp.exceptions import ToolError\nfrom mcp.server.fastmcp.utilities.func_metadata import FuncMetadata, func_metadata\nfrom mcp.types import ToolAnnotations\n\nif TYPE_CHECKING:\n    from mcp.server.fastmcp.server import Context\n    from mcp.server.session import ServerSessionT\n    from mcp.shared.context import LifespanContextT, RequestT\n\n\nclass Tool(BaseModel):\n    \"\"\"Internal tool registration info.\"\"\"\n\n    fn: Callable[..., Any] = Field(exclude=True)\n    name: str = Field(description=\"Name of the tool\")\n    title: str | None = Field(None, description=\"Human-readable title of the tool\")\n    description: str = Field(description=\"Description of what the tool does\")\n    parameters: dict[str, Any] = Field(description=\"JSON schema for tool parameters\")\n    fn_metadata: FuncMetadata = Field(\n        description=\"Metadata about the function including a pydantic model for tool arguments\"\n    )\n    is_async: bool = Field(description=\"Whether the tool is async\")\n    context_kwarg: str | None = Field(None, description=\"Name of the kwarg that should receive context\")\n    annotations: ToolAnnotations | None = Field(None, description=\"Optional annotations for the tool\")\n\n    @cached_property\n    def output_schema(self) -> dict[str, Any] | None:\n        return self.fn_metadata.output_schema\n\n    @classmethod\n    def from_function(\n        cls,\n        fn: Callable[..., Any],\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        context_kwarg: str | None = None,\n        annotations: ToolAnnotations | None = None,\n        structured_output: bool | None = None,\n    ) -> Tool:\n        \"\"\"Create a Tool from a function.\"\"\"\n        from mcp.server.fastmcp.server impor\n... (content truncated)\n\n--- src/mcp/server/fastmcp/tools/tool_manager.py (py) ---\nfrom __future__ import annotations as _annotations\n\nfrom collections.abc import Callable\nfrom typing import TYPE_CHECKING, Any\n\nfrom mcp.server.fastmcp.exceptions import ToolError\nfrom mcp.server.fastmcp.tools.base import Tool\nfrom mcp.server.fastmcp.utilities.logging import get_logger\nfrom mcp.shared.context import LifespanContextT, RequestT\nfrom mcp.types import ToolAnnotations\n\nif TYPE_CHECKING:\n    from mcp.server.fastmcp.server import Context\n    from mcp.server.session import ServerSessionT\n\nlogger = get_logger(__name__)\n\n\nclass ToolManager:\n    \"\"\"Manages FastMCP tools.\"\"\"\n\n    def __init__(\n        self,\n        warn_on_duplicate_tools: bool = True,\n        *,\n        tools: list[Tool] | None = None,\n    ):\n        self._tools: dict[str, Tool] = {}\n        if tools is not None:\n            for tool in tools:\n                if warn_on_duplicate_tools and tool.name in self._tools:\n                    logger.warning(f\"Tool already exists: {tool.name}\")\n                self._tools[tool.name] = tool\n\n        self.warn_on_duplicate_tools = warn_on_duplicate_tools\n\n    def get_tool(self, name: str) -> Tool | None:\n        \"\"\"Get tool by name.\"\"\"\n        return self._tools.get(name)\n\n    def list_tools(self) -> list[Tool]:\n        \"\"\"List all registered tools.\"\"\"\n        return list(self._tools.values())\n\n    def add_tool(\n        self,\n        fn: Callable[..., Any],\n        name: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        annotations: ToolAnnotations | None = None,\n        structured_output: bool | None = None,\n    ) -> Tool:\n        \"\"\"Add a tool to the server.\"\"\"\n        tool = Tool.from_function(\n            fn,\n            name=name,\n            title=title,\n            description=description,\n            annotations=annotations,\n            structured_output=structured_output,\n        )\n        existing = self._tools.get(tool.name)\n        if existing:\n            if self.warn_on_duplicate_tools:\n   \n... (content truncated)\n\n--- src/mcp/server/fastmcp/utilities/__init__.py (py) ---\n\"\"\"FastMCP utility modules.\"\"\"\n\n\n--- src/mcp/server/fastmcp/utilities/func_metadata.py (py) ---\nimport inspect\nimport json\nfrom collections.abc import Awaitable, Callable, Sequence\nfrom itertools import chain\nfrom types import GenericAlias\nfrom typing import Annotated, Any, ForwardRef, cast, get_args, get_origin, get_type_hints\n\nimport pydantic_core\nfrom pydantic import (\n    BaseModel,\n    ConfigDict,\n    Field,\n    RootModel,\n    WithJsonSchema,\n    create_model,\n)\nfrom pydantic._internal._typing_extra import eval_type_backport\nfrom pydantic.fields import FieldInfo\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaWarningKind\nfrom pydantic_core import PydanticUndefined\n\nfrom mcp.server.fastmcp.exceptions import InvalidSignature\nfrom mcp.server.fastmcp.utilities.logging import get_logger\nfrom mcp.server.fastmcp.utilities.types import Image\nfrom mcp.types import ContentBlock, TextContent\n\nlogger = get_logger(__name__)\n\n\nclass StrictJsonSchema(GenerateJsonSchema):\n    \"\"\"A JSON schema generator that raises exceptions instead of emitting warnings.\n\n    This is used to detect non-serializable types during schema generation.\n    \"\"\"\n\n    def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -> None:\n        # Raise an exception instead of emitting a warning\n        raise ValueError(f\"JSON schema warning: {kind} - {detail}\")\n\n\nclass ArgModelBase(BaseModel):\n    \"\"\"A model representing the arguments to a function.\"\"\"\n\n    def model_dump_one_level(self) -> dict[str, Any]:\n        \"\"\"Return a dict of the model's fields, one level deep.\n\n        That is, sub-models etc are not dumped - they are kept as pydantic models.\n        \"\"\"\n        kwargs: dict[str, Any] = {}\n        for field_name, field_info in self.__class__.model_fields.items():\n            value = getattr(self, field_name)\n            # Use the alias if it exists, otherwise use the field name\n            output_name = field_info.alias if field_info.alias else field_name\n            kwargs[output_name] = value\n        return kwargs\n\n    model_config = ConfigDict(\n        arbitrary_typ\n... (content truncated)\n\n--- src/mcp/server/fastmcp/utilities/logging.py (py) ---\n\"\"\"Logging utilities for FastMCP.\"\"\"\n\nimport logging\nfrom typing import Literal\n\n\ndef get_logger(name: str) -> logging.Logger:\n    \"\"\"Get a logger nested under MCPnamespace.\n\n    Args:\n        name: the name of the logger, which will be prefixed with 'FastMCP.'\n\n    Returns:\n        a configured logger instance\n    \"\"\"\n    return logging.getLogger(name)\n\n\ndef configure_logging(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"] = \"INFO\",\n) -> None:\n    \"\"\"Configure logging for MCP.\n\n    Args:\n        level: the log level to use\n    \"\"\"\n    handlers: list[logging.Handler] = []\n    try:\n        from rich.console import Console\n        from rich.logging import RichHandler\n\n        handlers.append(RichHandler(console=Console(stderr=True), rich_tracebacks=True))\n    except ImportError:\n        pass\n\n    if not handlers:\n        handlers.append(logging.StreamHandler())\n\n    logging.basicConfig(\n        level=level,\n        format=\"%(message)s\",\n        handlers=handlers,\n    )\n\n\n--- src/mcp/server/fastmcp/utilities/types.py (py) ---\n\"\"\"Common types used across FastMCP.\"\"\"\n\nimport base64\nfrom pathlib import Path\n\nfrom mcp.types import ImageContent\n\n\nclass Image:\n    \"\"\"Helper class for returning images from tools.\"\"\"\n\n    def __init__(\n        self,\n        path: str | Path | None = None,\n        data: bytes | None = None,\n        format: str | None = None,\n    ):\n        if path is None and data is None:\n            raise ValueError(\"Either path or data must be provided\")\n        if path is not None and data is not None:\n            raise ValueError(\"Only one of path or data can be provided\")\n\n        self.path = Path(path) if path else None\n        self.data = data\n        self._format = format\n        self._mime_type = self._get_mime_type()\n\n    def _get_mime_type(self) -> str:\n        \"\"\"Get MIME type from format or guess from file extension.\"\"\"\n        if self._format:\n            return f\"image/{self._format.lower()}\"\n\n        if self.path:\n            suffix = self.path.suffix.lower()\n            return {\n                \".png\": \"image/png\",\n                \".jpg\": \"image/jpeg\",\n                \".jpeg\": \"image/jpeg\",\n                \".gif\": \"image/gif\",\n                \".webp\": \"image/webp\",\n            }.get(suffix, \"application/octet-stream\")\n        return \"image/png\"  # default for raw binary data\n\n    def to_image_content(self) -> ImageContent:\n        \"\"\"Convert to MCP ImageContent.\"\"\"\n        if self.path:\n            with open(self.path, \"rb\") as f:\n                data = base64.b64encode(f.read()).decode()\n        elif self.data is not None:\n            data = base64.b64encode(self.data).decode()\n        else:\n            raise ValueError(\"No image data available\")\n\n        return ImageContent(type=\"image\", data=data, mimeType=self._mime_type)\n\n\n--- src/mcp/server/lowlevel/__init__.py (py) ---\nfrom .server import NotificationOptions, Server\n\n__all__ = [\"Server\", \"NotificationOptions\"]\n\n\n--- src/mcp/server/lowlevel/helper_types.py (py) ---\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass ReadResourceContents:\n    \"\"\"Contents returned from a read_resource call.\"\"\"\n\n    content: str | bytes\n    mime_type: str | None = None\n\n\n--- src/mcp/server/lowlevel/server.py (py) ---\n\"\"\"\nMCP Server Module\n\nThis module provides a framework for creating an MCP (Model Context Protocol) server.\nIt allows you to easily define and handle various types of requests and notifications\nin an asynchronous manner.\n\nUsage:\n1. Create a Server instance:\n   server = Server(\"your_server_name\")\n\n2. Define request handlers using decorators:\n   @server.list_prompts()\n   async def handle_list_prompts() -> list[types.Prompt]:\n       # Implementation\n\n   @server.get_prompt()\n   async def handle_get_prompt(\n       name: str, arguments: dict[str, str] | None\n   ) -> types.GetPromptResult:\n       # Implementation\n\n   @server.list_tools()\n   async def handle_list_tools() -> list[types.Tool]:\n       # Implementation\n\n   @server.call_tool()\n   async def handle_call_tool(\n       name: str, arguments: dict | None\n   ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:\n       # Implementation\n\n   @server.list_resource_templates()\n   async def handle_list_resource_templates() -> list[types.ResourceTemplate]:\n       # Implementation\n\n3. Define notification handlers if needed:\n   @server.progress_notification()\n   async def handle_progress(\n       progress_token: str | int, progress: float, total: float | None,\n       message: str | None\n   ) -> None:\n       # Implementation\n\n4. Run the server:\n   async def main():\n       async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n           await server.run(\n               read_stream,\n               write_stream,\n               InitializationOptions(\n                   server_name=\"your_server_name\",\n                   server_version=\"your_version\",\n                   capabilities=server.get_capabilities(\n                       notification_options=NotificationOptions(),\n                       experimental_capabilities={},\n                   ),\n               ),\n           )\n\n   asyncio.run(main())\n\nThe Server class provides methods to register handlers for various MCP requests and\nnotificat\n... (content truncated)\n\n--- src/mcp/server/models.py (py) ---\n\"\"\"\nThis module provides simpler types to use with the server for managing prompts\nand tools.\n\"\"\"\n\nfrom pydantic import BaseModel\n\nfrom mcp.types import (\n    ServerCapabilities,\n)\n\n\nclass InitializationOptions(BaseModel):\n    server_name: str\n    server_version: str\n    capabilities: ServerCapabilities\n    instructions: str | None = None\n\n\n--- src/mcp/server/session.py (py) ---\n\"\"\"\nServerSession Module\n\nThis module provides the ServerSession class, which manages communication between the\nserver and client in the MCP (Model Context Protocol) framework. It is most commonly\nused in MCP servers to interact with the client.\n\nCommon usage pattern:\n```\n    server = Server(name)\n\n    @server.call_tool()\n    async def handle_tool_call(ctx: RequestContext, arguments: dict[str, Any]) -> Any:\n        # Check client capabilities before proceeding\n        if ctx.session.check_client_capability(\n            types.ClientCapabilities(experimental={\"advanced_tools\": dict()})\n        ):\n            # Perform advanced tool operations\n            result = await perform_advanced_tool_operation(arguments)\n        else:\n            # Fall back to basic tool operations\n            result = await perform_basic_tool_operation(arguments)\n\n        return result\n\n    @server.list_prompts()\n    async def handle_list_prompts(ctx: RequestContext) -> list[types.Prompt]:\n        # Access session for any necessary checks or operations\n        if ctx.session.client_params:\n            # Customize prompts based on client initialization parameters\n            return generate_custom_prompts(ctx.session.client_params)\n        else:\n            return default_prompts\n```\n\nThe ServerSession class is typically used internally by the Server class and should not\nbe instantiated directly by users of the MCP framework.\n\"\"\"\n\nfrom enum import Enum\nfrom typing import Any, TypeVar\n\nimport anyio\nimport anyio.lowlevel\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import AnyUrl\n\nimport mcp.types as types\nfrom mcp.server.models import InitializationOptions\nfrom mcp.shared.message import ServerMessageMetadata, SessionMessage\nfrom mcp.shared.session import (\n    BaseSession,\n    RequestResponder,\n)\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\n\n\nclass InitializationState(Enum):\n    NotInitialized = 1\n    Initializing = 2\n    Initiali\n... (content truncated)\n\n--- src/mcp/server/sse.py (py) ---\n\"\"\"\nSSE Server Transport Module\n\nThis module implements a Server-Sent Events (SSE) transport layer for MCP servers.\n\nExample usage:\n```\n    # Create an SSE transport at an endpoint\n    sse = SseServerTransport(\"/messages/\")\n\n    # Create Starlette routes for SSE and message handling\n    routes = [\n        Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n        Mount(\"/messages/\", app=sse.handle_post_message),\n    ]\n\n    # Define handler functions\n    async def handle_sse(request):\n        async with sse.connect_sse(\n            request.scope, request.receive, request._send\n        ) as streams:\n            await app.run(\n                streams[0], streams[1], app.create_initialization_options()\n            )\n        # Return empty response to avoid NoneType error\n        return Response()\n\n    # Create and run Starlette app\n    starlette_app = Starlette(routes=routes)\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n```\n\nNote: The handle_sse function must return a Response to avoid a \"TypeError: 'NoneType'\nobject is not callable\" error when client disconnects. The example above returns\nan empty Response() after the SSE connection ends to fix this.\n\nSee SseServerTransport class documentation for more details.\n\"\"\"\n\nimport logging\nfrom contextlib import asynccontextmanager\nfrom typing import Any\nfrom urllib.parse import quote\nfrom uuid import UUID, uuid4\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import ValidationError\nfrom sse_starlette import EventSourceResponse\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.types import Receive, Scope, Send\n\nimport mcp.types as types\nfrom mcp.server.transport_security import (\n    TransportSecurityMiddleware,\n    TransportSecuritySettings,\n)\nfrom mcp.shared.message import ServerMessageMetadata, SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n\nclass SseServerTransport:\n    \"\"\"\n    SSE server trans\n... (content truncated)\n\n--- src/mcp/server/stdio.py (py) ---\n\"\"\"\nStdio Server Transport Module\n\nThis module provides functionality for creating an stdio-based transport layer\nthat can be used to communicate with an MCP client through standard input/output\nstreams.\n\nExample usage:\n```\n    async def run_server():\n        async with stdio_server() as (read_stream, write_stream):\n            # read_stream contains incoming JSONRPCMessages from stdin\n            # write_stream allows sending JSONRPCMessages to stdout\n            server = await create_my_server()\n            await server.run(read_stream, write_stream, init_options)\n\n    anyio.run(run_server)\n```\n\"\"\"\n\nimport sys\nfrom contextlib import asynccontextmanager\nfrom io import TextIOWrapper\n\nimport anyio\nimport anyio.lowlevel\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\n\nimport mcp.types as types\nfrom mcp.shared.message import SessionMessage\n\n\n@asynccontextmanager\nasync def stdio_server(\n    stdin: anyio.AsyncFile[str] | None = None,\n    stdout: anyio.AsyncFile[str] | None = None,\n):\n    \"\"\"\n    Server transport for stdio: this communicates with an MCP client by reading\n    from the current process' stdin and writing to stdout.\n    \"\"\"\n    # Purposely not using context managers for these, as we don't want to close\n    # standard process handles. Encoding of stdin/stdout as text streams on\n    # python is platform-dependent (Windows is particularly problematic), so we\n    # re-wrap the underlying binary stream to ensure UTF-8.\n    if not stdin:\n        stdin = anyio.wrap_file(TextIOWrapper(sys.stdin.buffer, encoding=\"utf-8\"))\n    if not stdout:\n        stdout = anyio.wrap_file(TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\"))\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyi\n... (content truncated)\n\n--- src/mcp/server/streamable_http.py (py) ---\n\"\"\"\nStreamableHTTP Server Transport Module\n\nThis module implements an HTTP transport layer with Streamable HTTP.\n\nThe transport handles bidirectional communication using HTTP requests and\nresponses, with streaming support for long-running operations.\n\"\"\"\n\nimport json\nimport logging\nimport re\nfrom abc import ABC, abstractmethod\nfrom collections.abc import AsyncGenerator, Awaitable, Callable\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom http import HTTPStatus\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import ValidationError\nfrom sse_starlette import EventSourceResponse\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.types import Receive, Scope, Send\n\nfrom mcp.server.transport_security import (\n    TransportSecurityMiddleware,\n    TransportSecuritySettings,\n)\nfrom mcp.shared.message import ServerMessageMetadata, SessionMessage\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\nfrom mcp.types import (\n    DEFAULT_NEGOTIATED_VERSION,\n    INTERNAL_ERROR,\n    INVALID_PARAMS,\n    INVALID_REQUEST,\n    PARSE_ERROR,\n    ErrorData,\n    JSONRPCError,\n    JSONRPCMessage,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    RequestId,\n)\n\nlogger = logging.getLogger(__name__)\n\n\n# Header names\nMCP_SESSION_ID_HEADER = \"mcp-session-id\"\nMCP_PROTOCOL_VERSION_HEADER = \"mcp-protocol-version\"\nLAST_EVENT_ID_HEADER = \"last-event-id\"\n\n# Content types\nCONTENT_TYPE_JSON = \"application/json\"\nCONTENT_TYPE_SSE = \"text/event-stream\"\n\n# Special key for the standalone GET stream\nGET_STREAM_KEY = \"_GET_stream\"\n\n# Session ID validation pattern (visible ASCII characters ranging from 0x21 to 0x7E)\n# Pattern ensures entire string contains only valid characters by using ^ and $ anchors\nSESSION_ID_PATTERN = re.compile(r\"^[\\x21-\\x7E]+$\")\n\n# Type aliases\nStreamId = str\nEventId = str\n\n\n@dataclass\nclass EventMessage:\n    \"\"\"\n    A JSONRPCMessage with an optional e\n... (content truncated)\n\n--- src/mcp/server/streamable_http_manager.py (py) ---\n\"\"\"StreamableHTTP Session Manager for MCP servers.\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport logging\nimport threading\nfrom collections.abc import AsyncIterator\nfrom http import HTTPStatus\nfrom typing import Any\nfrom uuid import uuid4\n\nimport anyio\nfrom anyio.abc import TaskStatus\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.types import Receive, Scope, Send\n\nfrom mcp.server.lowlevel.server import Server as MCPServer\nfrom mcp.server.streamable_http import (\n    MCP_SESSION_ID_HEADER,\n    EventStore,\n    StreamableHTTPServerTransport,\n)\nfrom mcp.server.transport_security import TransportSecuritySettings\n\nlogger = logging.getLogger(__name__)\n\n\nclass StreamableHTTPSessionManager:\n    \"\"\"\n    Manages StreamableHTTP sessions with optional resumability via event store.\n\n    This class abstracts away the complexity of session management, event storage,\n    and request handling for StreamableHTTP transports. It handles:\n\n    1. Session tracking for clients\n    2. Resumability via an optional event store\n    3. Connection management and lifecycle\n    4. Request handling and transport setup\n\n    Important: Only one StreamableHTTPSessionManager instance should be created\n    per application. The instance cannot be reused after its run() context has\n    completed. If you need to restart the manager, create a new instance.\n\n    Args:\n        app: The MCP server instance\n        event_store: Optional event store for resumability support.\n                     If provided, enables resumable connections where clients\n                     can reconnect and receive missed events.\n                     If None, sessions are still tracked but not resumable.\n        json_response: Whether to use JSON responses instead of SSE streams\n        stateless: If True, creates a completely fresh transport for each request\n                   with no session tracking or state persistence between requests.\n    \"\"\"\n\n    def __init\n... (content truncated)\n\n--- src/mcp/server/streaming_asgi_transport.py (py) ---\n\"\"\"\nA modified version of httpx.ASGITransport that supports streaming responses.\n\nThis transport runs the ASGI app as a separate anyio task, allowing it to\nhandle streaming responses like SSE where the app doesn't terminate until\nthe connection is closed.\n\nThis is only intended for writing tests for the SSE transport.\n\"\"\"\n\nimport typing\nfrom typing import Any, cast\n\nimport anyio\nimport anyio.abc\nimport anyio.streams.memory\nfrom httpx._models import Request, Response\nfrom httpx._transports.base import AsyncBaseTransport\nfrom httpx._types import AsyncByteStream\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\n\nclass StreamingASGITransport(AsyncBaseTransport):\n    \"\"\"\n    A custom AsyncTransport that handles sending requests directly to an ASGI app\n    and supports streaming responses like SSE.\n\n    Unlike the standard ASGITransport, this transport runs the ASGI app in a\n    separate anyio task, allowing it to handle responses from apps that don't\n    terminate immediately (like SSE endpoints).\n\n    Arguments:\n\n    * `app` - The ASGI application.\n    * `raise_app_exceptions` - Boolean indicating if exceptions in the application\n       should be raised. Default to `True`. Can be set to `False` for use cases\n       such as testing the content of a client 500 response.\n    * `root_path` - The root path on which the ASGI application should be mounted.\n    * `client` - A two-tuple indicating the client IP and port of incoming requests.\n    * `response_timeout` - Timeout in seconds to wait for the initial response.\n       Default is 10 seconds.\n\n    TODO: https://github.com/encode/httpx/pull/3059 is adding something similar to\n    upstream httpx. When that merges, we should delete this & switch back to the\n    upstream implementation.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        task_group: anyio.abc.TaskGroup,\n        raise_app_exceptions: bool = True,\n        root_path: str = \"\",\n        client: tuple[str, int] = (\"127.0.0.1\", 123),\n    \n... (content truncated)\n\n--- src/mcp/server/transport_security.py (py) ---\n\"\"\"DNS rebinding protection for MCP server transports.\"\"\"\n\nimport logging\n\nfrom pydantic import BaseModel, Field\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nlogger = logging.getLogger(__name__)\n\n\nclass TransportSecuritySettings(BaseModel):\n    \"\"\"Settings for MCP transport security features.\n\n    These settings help protect against DNS rebinding attacks by validating\n    incoming request headers.\n    \"\"\"\n\n    enable_dns_rebinding_protection: bool = Field(\n        default=True,\n        description=\"Enable DNS rebinding protection (recommended for production)\",\n    )\n\n    allowed_hosts: list[str] = Field(\n        default=[],\n        description=\"List of allowed Host header values. Only applies when \"\n        + \"enable_dns_rebinding_protection is True.\",\n    )\n\n    allowed_origins: list[str] = Field(\n        default=[],\n        description=\"List of allowed Origin header values. Only applies when \"\n        + \"enable_dns_rebinding_protection is True.\",\n    )\n\n\nclass TransportSecurityMiddleware:\n    \"\"\"Middleware to enforce DNS rebinding protection for MCP transport endpoints.\"\"\"\n\n    def __init__(self, settings: TransportSecuritySettings | None = None):\n        # If not specified, disable DNS rebinding protection by default\n        # for backwards compatibility\n        self.settings = settings or TransportSecuritySettings(enable_dns_rebinding_protection=False)\n\n    def _validate_host(self, host: str | None) -> bool:\n        \"\"\"Validate the Host header against allowed values.\"\"\"\n        if not host:\n            logger.warning(\"Missing Host header in request\")\n            return False\n\n        # Check exact match first\n        if host in self.settings.allowed_hosts:\n            return True\n\n        # Check wildcard port patterns\n        for allowed in self.settings.allowed_hosts:\n            if allowed.endswith(\":*\"):\n                # Extract base host from pattern\n                base_host = allowed[:-2]\n                # Check if the\n... (content truncated)\n\n--- src/mcp/server/websocket.py (py) ---\nimport logging\nfrom contextlib import asynccontextmanager\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic_core import ValidationError\nfrom starlette.types import Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n\nimport mcp.types as types\nfrom mcp.shared.message import SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def websocket_server(scope: Scope, receive: Receive, send: Send):\n    \"\"\"\n    WebSocket server transport for MCP. This is an ASGI application, suitable to be\n    used with a framework like Starlette and a server like Hypercorn.\n    \"\"\"\n\n    websocket = WebSocket(scope, receive, send)\n    await websocket.accept(subprotocol=\"mcp\")\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async def ws_reader():\n        try:\n            async with read_stream_writer:\n                async for msg in websocket.iter_text():\n                    try:\n                        client_message = types.JSONRPCMessage.model_validate_json(msg)\n                    except ValidationError as exc:\n                        await read_stream_writer.send(exc)\n                        continue\n\n                    session_message = SessionMessage(client_message)\n                    await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await websocket.close()\n\n    async def ws_writer():\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    obj = session_message.message.mode\n... (content truncated)\n\n--- src/mcp/shared/__init__.py (py) ---\n\n\n--- src/mcp/shared/_httpx_utils.py (py) ---\n\"\"\"Utilities for creating standardized httpx AsyncClient instances.\"\"\"\n\nfrom typing import Any, Protocol\n\nimport httpx\n\n__all__ = [\"create_mcp_http_client\"]\n\n\nclass McpHttpClientFactory(Protocol):\n    def __call__(\n        self,\n        headers: dict[str, str] | None = None,\n        timeout: httpx.Timeout | None = None,\n        auth: httpx.Auth | None = None,\n    ) -> httpx.AsyncClient: ...\n\n\ndef create_mcp_http_client(\n    headers: dict[str, str] | None = None,\n    timeout: httpx.Timeout | None = None,\n    auth: httpx.Auth | None = None,\n) -> httpx.AsyncClient:\n    \"\"\"Create a standardized httpx AsyncClient with MCP defaults.\n\n    This function provides common defaults used throughout the MCP codebase:\n    - follow_redirects=True (always enabled)\n    - Default timeout of 30 seconds if not specified\n\n    Args:\n        headers: Optional headers to include with all requests.\n        timeout: Request timeout as httpx.Timeout object.\n            Defaults to 30 seconds if not specified.\n        auth: Optional authentication handler.\n\n    Returns:\n        Configured httpx.AsyncClient instance with MCP defaults.\n\n    Note:\n        The returned AsyncClient must be used as a context manager to ensure\n        proper cleanup of connections.\n\n    Examples:\n        # Basic usage with MCP defaults\n        async with create_mcp_http_client() as client:\n            response = await client.get(\"https://api.example.com\")\n\n        # With custom headers\n        headers = {\"Authorization\": \"Bearer token\"}\n        async with create_mcp_http_client(headers) as client:\n            response = await client.get(\"/endpoint\")\n\n        # With both custom headers and timeout\n        timeout = httpx.Timeout(60.0, read=300.0)\n        async with create_mcp_http_client(headers, timeout) as client:\n            response = await client.get(\"/long-request\")\n\n        # With authentication\n        from httpx import BasicAuth\n        auth = BasicAuth(username=\"user\", password=\"pass\")\n        async with crea\n... (content truncated)\n\n--- src/mcp/shared/auth.py (py) ---\nfrom typing import Any, Literal\n\nfrom pydantic import AnyHttpUrl, AnyUrl, BaseModel, Field, field_validator\n\n\nclass OAuthToken(BaseModel):\n    \"\"\"\n    See https://datatracker.ietf.org/doc/html/rfc6749#section-5.1\n    \"\"\"\n\n    access_token: str\n    token_type: Literal[\"Bearer\"] = \"Bearer\"\n    expires_in: int | None = None\n    scope: str | None = None\n    refresh_token: str | None = None\n\n    @field_validator(\"token_type\", mode=\"before\")\n    @classmethod\n    def normalize_token_type(cls, v: str | None) -> str | None:\n        if isinstance(v, str):\n            # Bearer is title-cased in the spec, so we normalize it\n            # https://datatracker.ietf.org/doc/html/rfc6750#section-4\n            return v.title()\n        return v\n\n\nclass InvalidScopeError(Exception):\n    def __init__(self, message: str):\n        self.message = message\n\n\nclass InvalidRedirectUriError(Exception):\n    def __init__(self, message: str):\n        self.message = message\n\n\nclass OAuthClientMetadata(BaseModel):\n    \"\"\"\n    RFC 7591 OAuth 2.0 Dynamic Client Registration metadata.\n    See https://datatracker.ietf.org/doc/html/rfc7591#section-2\n    for the full specification.\n    \"\"\"\n\n    redirect_uris: list[AnyUrl] = Field(..., min_length=1)\n    # token_endpoint_auth_method: this implementation only supports none &\n    # client_secret_post;\n    # ie: we do not support client_secret_basic\n    token_endpoint_auth_method: Literal[\"none\", \"client_secret_post\"] = \"client_secret_post\"\n    # grant_types: this implementation only supports authorization_code & refresh_token\n    grant_types: list[Literal[\"authorization_code\", \"refresh_token\"]] = [\n        \"authorization_code\",\n        \"refresh_token\",\n    ]\n    # this implementation only supports code; ie: it does not support implicit grants\n    response_types: list[Literal[\"code\"]] = [\"code\"]\n    scope: str | None = None\n\n    # these fields are currently unused, but we support & store them for potential\n    # future use\n    client_name: str | None = None\n  \n... (content truncated)\n\n--- src/mcp/shared/auth_utils.py (py) ---\n\"\"\"Utilities for OAuth 2.0 Resource Indicators (RFC 8707).\"\"\"\n\nfrom urllib.parse import urlparse, urlsplit, urlunsplit\n\nfrom pydantic import AnyUrl, HttpUrl\n\n\ndef resource_url_from_server_url(url: str | HttpUrl | AnyUrl) -> str:\n    \"\"\"Convert server URL to canonical resource URL per RFC 8707.\n\n    RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\".\n    Returns absolute URI with lowercase scheme/host for canonical form.\n\n    Args:\n        url: Server URL to convert\n\n    Returns:\n        Canonical resource URL string\n    \"\"\"\n    # Convert to string if needed\n    url_str = str(url)\n\n    # Parse the URL and remove fragment, create canonical form\n    parsed = urlsplit(url_str)\n    canonical = urlunsplit(parsed._replace(scheme=parsed.scheme.lower(), netloc=parsed.netloc.lower(), fragment=\"\"))\n\n    return canonical\n\n\ndef check_resource_allowed(requested_resource: str, configured_resource: str) -> bool:\n    \"\"\"Check if a requested resource URL matches a configured resource URL.\n\n    A requested resource matches if it has the same scheme, domain, port,\n    and its path starts with the configured resource's path. This allows\n    hierarchical matching where a token for a parent resource can be used\n    for child resources.\n\n    Args:\n        requested_resource: The resource URL being requested\n        configured_resource: The resource URL that has been configured\n\n    Returns:\n        True if the requested resource matches the configured resource\n    \"\"\"\n    # Parse both URLs\n    requested = urlparse(requested_resource)\n    configured = urlparse(configured_resource)\n\n    # Compare scheme, host, and port (origin)\n    if requested.scheme.lower() != configured.scheme.lower() or requested.netloc.lower() != configured.netloc.lower():\n        return False\n\n    # Handle cases like requested=/foo and configured=/foo/\n    requested_path = requested.path\n    configured_path = configured.path\n\n    # If requested path is shorter, it cannot be a child\n   \n... (content truncated)\n\n--- src/mcp/shared/context.py (py) ---\nfrom dataclasses import dataclass\nfrom typing import Any, Generic\n\nfrom typing_extensions import TypeVar\n\nfrom mcp.shared.session import BaseSession\nfrom mcp.types import RequestId, RequestParams\n\nSessionT = TypeVar(\"SessionT\", bound=BaseSession[Any, Any, Any, Any, Any])\nLifespanContextT = TypeVar(\"LifespanContextT\")\nRequestT = TypeVar(\"RequestT\", default=Any)\n\n\n@dataclass\nclass RequestContext(Generic[SessionT, LifespanContextT, RequestT]):\n    request_id: RequestId\n    meta: RequestParams.Meta | None\n    session: SessionT\n    lifespan_context: LifespanContextT\n    request: RequestT | None = None\n\n\n--- src/mcp/shared/exceptions.py (py) ---\nfrom mcp.types import ErrorData\n\n\nclass McpError(Exception):\n    \"\"\"\n    Exception type raised when an error arrives over an MCP connection.\n    \"\"\"\n\n    error: ErrorData\n\n    def __init__(self, error: ErrorData):\n        \"\"\"Initialize McpError.\"\"\"\n        super().__init__(error.message)\n        self.error = error\n\n\n--- src/mcp/shared/memory.py (py) ---\n\"\"\"\nIn-memory transports\n\"\"\"\n\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom datetime import timedelta\nfrom typing import Any\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\n\nimport mcp.types as types\nfrom mcp.client.session import (\n    ClientSession,\n    ElicitationFnT,\n    ListRootsFnT,\n    LoggingFnT,\n    MessageHandlerFnT,\n    SamplingFnT,\n)\nfrom mcp.server import Server\nfrom mcp.shared.message import SessionMessage\n\nMessageStream = tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage]]\n\n\n@asynccontextmanager\nasync def create_client_server_memory_streams() -> AsyncGenerator[tuple[MessageStream, MessageStream], None]:\n    \"\"\"\n    Creates a pair of bidirectional memory streams for client-server communication.\n\n    Returns:\n        A tuple of (client_streams, server_streams) where each is a tuple of\n        (read_stream, write_stream)\n    \"\"\"\n    # Create streams for both directions\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage | Exception](1)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage | Exception](1)\n\n    client_streams = (server_to_client_receive, client_to_server_send)\n    server_streams = (client_to_server_receive, server_to_client_send)\n\n    async with (\n        server_to_client_receive,\n        client_to_server_send,\n        client_to_server_receive,\n        server_to_client_send,\n    ):\n        yield client_streams, server_streams\n\n\n@asynccontextmanager\nasync def create_connected_server_and_client_session(\n    server: Server[Any],\n    read_timeout_seconds: timedelta | None = None,\n    sampling_callback: SamplingFnT | None = None,\n    list_roots_callback: ListRootsFnT | None = None,\n    logging_callback: LoggingFnT | None = None,\n    message_handler: MessageHandlerFnT | None = None,\n    client_info: types.I\n... (content truncated)\n\n--- src/mcp/shared/message.py (py) ---\n\"\"\"\nMessage wrapper with metadata support.\n\nThis module defines a wrapper type that combines JSONRPCMessage with metadata\nto support transport-specific features like resumability.\n\"\"\"\n\nfrom collections.abc import Awaitable, Callable\nfrom dataclasses import dataclass\n\nfrom mcp.types import JSONRPCMessage, RequestId\n\nResumptionToken = str\n\nResumptionTokenUpdateCallback = Callable[[ResumptionToken], Awaitable[None]]\n\n\n@dataclass\nclass ClientMessageMetadata:\n    \"\"\"Metadata specific to client messages.\"\"\"\n\n    resumption_token: ResumptionToken | None = None\n    on_resumption_token_update: Callable[[ResumptionToken], Awaitable[None]] | None = None\n\n\n@dataclass\nclass ServerMessageMetadata:\n    \"\"\"Metadata specific to server messages.\"\"\"\n\n    related_request_id: RequestId | None = None\n    # Request-specific context (e.g., headers, auth info)\n    request_context: object | None = None\n\n\nMessageMetadata = ClientMessageMetadata | ServerMessageMetadata | None\n\n\n@dataclass\nclass SessionMessage:\n    \"\"\"A message with specific metadata for transport-specific features.\"\"\"\n\n    message: JSONRPCMessage\n    metadata: MessageMetadata = None\n\n\n--- src/mcp/shared/metadata_utils.py (py) ---\n\"\"\"Utility functions for working with metadata in MCP types.\n\nThese utilities are primarily intended for client-side usage to properly display\nhuman-readable names in user interfaces in a spec compliant way.\n\"\"\"\n\nfrom mcp.types import Implementation, Prompt, Resource, ResourceTemplate, Tool\n\n\ndef get_display_name(obj: Tool | Resource | Prompt | ResourceTemplate | Implementation) -> str:\n    \"\"\"\n    Get the display name for an MCP object with proper precedence.\n\n    This is a client-side utility function designed to help MCP clients display\n    human-readable names in their user interfaces. When servers provide a 'title'\n    field, it should be preferred over the programmatic 'name' field for display.\n\n    For tools: title > annotations.title > name\n    For other objects: title > name\n\n    Example:\n        # In a client displaying available tools\n        tools = await session.list_tools()\n        for tool in tools.tools:\n            display_name = get_display_name(tool)\n            print(f\"Available tool: {display_name}\")\n\n    Args:\n        obj: An MCP object with name and optional title fields\n\n    Returns:\n        The display name to use for UI presentation\n    \"\"\"\n    if isinstance(obj, Tool):\n        # Tools have special precedence: title > annotations.title > name\n        if hasattr(obj, \"title\") and obj.title is not None:\n            return obj.title\n        if obj.annotations and hasattr(obj.annotations, \"title\") and obj.annotations.title is not None:\n            return obj.annotations.title\n        return obj.name\n    else:\n        # All other objects: title > name\n        if hasattr(obj, \"title\") and obj.title is not None:\n            return obj.title\n        return obj.name\n\n\n--- src/mcp/shared/progress.py (py) ---\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass, field\nfrom typing import Generic\n\nfrom pydantic import BaseModel\n\nfrom mcp.shared.context import LifespanContextT, RequestContext\nfrom mcp.shared.session import (\n    BaseSession,\n    ReceiveNotificationT,\n    ReceiveRequestT,\n    SendNotificationT,\n    SendRequestT,\n    SendResultT,\n)\nfrom mcp.types import ProgressToken\n\n\nclass Progress(BaseModel):\n    progress: float\n    total: float | None\n\n\n@dataclass\nclass ProgressContext(Generic[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT]):\n    session: BaseSession[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT]\n    progress_token: ProgressToken\n    total: float | None\n    current: float = field(default=0.0, init=False)\n\n    async def progress(self, amount: float, message: str | None = None) -> None:\n        self.current += amount\n\n        await self.session.send_progress_notification(\n            self.progress_token, self.current, total=self.total, message=message\n        )\n\n\n@contextmanager\ndef progress(\n    ctx: RequestContext[\n        BaseSession[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT],\n        LifespanContextT,\n    ],\n    total: float | None = None,\n) -> Generator[\n    ProgressContext[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT],\n    None,\n]:\n    if ctx.meta is None or ctx.meta.progressToken is None:\n        raise ValueError(\"No progress token provided\")\n\n    progress_ctx = ProgressContext(ctx.session, ctx.meta.progressToken, total)\n    try:\n        yield progress_ctx\n    finally:\n        pass\n\n\n--- src/mcp/shared/session.py (py) ---\nimport logging\nfrom collections.abc import Callable\nfrom contextlib import AsyncExitStack\nfrom datetime import timedelta\nfrom types import TracebackType\nfrom typing import Any, Generic, Protocol, TypeVar\n\nimport anyio\nimport httpx\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import BaseModel\nfrom typing_extensions import Self\n\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.message import MessageMetadata, ServerMessageMetadata, SessionMessage\nfrom mcp.types import (\n    CONNECTION_CLOSED,\n    INVALID_PARAMS,\n    CancelledNotification,\n    ClientNotification,\n    ClientRequest,\n    ClientResult,\n    ErrorData,\n    JSONRPCError,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    ProgressNotification,\n    RequestParams,\n    ServerNotification,\n    ServerRequest,\n    ServerResult,\n)\n\nSendRequestT = TypeVar(\"SendRequestT\", ClientRequest, ServerRequest)\nSendResultT = TypeVar(\"SendResultT\", ClientResult, ServerResult)\nSendNotificationT = TypeVar(\"SendNotificationT\", ClientNotification, ServerNotification)\nReceiveRequestT = TypeVar(\"ReceiveRequestT\", ClientRequest, ServerRequest)\nReceiveResultT = TypeVar(\"ReceiveResultT\", bound=BaseModel)\nReceiveNotificationT = TypeVar(\"ReceiveNotificationT\", ClientNotification, ServerNotification)\n\nRequestId = str | int\n\n\nclass ProgressFnT(Protocol):\n    \"\"\"Protocol for progress notification callbacks.\"\"\"\n\n    async def __call__(self, progress: float, total: float | None, message: str | None) -> None: ...\n\n\nclass RequestResponder(Generic[ReceiveRequestT, SendResultT]):\n    \"\"\"Handles responding to MCP requests and manages request lifecycle.\n\n    This class MUST be used as a context manager to ensure proper cleanup and\n    cancellation handling:\n\n    Example:\n        with request_responder as resp:\n            await resp.respond(result)\n\n    The context manager ensures:\n    1. Proper cancellation scope setup and cleanup\n    2. Request compl\n... (content truncated)\n\n--- src/mcp/shared/version.py (py) ---\nfrom mcp.types import LATEST_PROTOCOL_VERSION\n\nSUPPORTED_PROTOCOL_VERSIONS: list[str] = [\"2024-11-05\", \"2025-03-26\", LATEST_PROTOCOL_VERSION]\n\n\n--- src/mcp/types.py (py) ---\nfrom collections.abc import Callable\nfrom typing import Annotated, Any, Generic, Literal, TypeAlias, TypeVar\n\nfrom pydantic import BaseModel, ConfigDict, Field, FileUrl, RootModel\nfrom pydantic.networks import AnyUrl, UrlConstraints\nfrom typing_extensions import deprecated\n\n\"\"\"\nModel Context Protocol bindings for Python\n\nThese bindings were generated from https://github.com/modelcontextprotocol/specification,\nusing Claude, with a prompt something like the following:\n\nGenerate idiomatic Python bindings for this schema for MCP, or the \"Model Context\nProtocol.\" The schema is defined in TypeScript, but there's also a JSON Schema version\nfor reference.\n\n* For the bindings, let's use Pydantic V2 models.\n* Each model should allow extra fields everywhere, by specifying `model_config =\n  ConfigDict(extra='allow')`. Do this in every case, instead of a custom base class.\n* Union types should be represented with a Pydantic `RootModel`.\n* Define additional model classes instead of using dictionaries. Do this even if they're\n  not separate types in the schema.\n\"\"\"\n\nLATEST_PROTOCOL_VERSION = \"2025-06-18\"\n\n\"\"\"\nThe default negotiated version of the Model Context Protocol when no version is specified.\nWe need this to satisfy the MCP specification, which requires the server to assume a\nspecific version if none is provided by the client. See section \"Protocol Version Header\" at\nhttps://modelcontextprotocol.io/specification\n\"\"\"\nDEFAULT_NEGOTIATED_VERSION = \"2025-03-26\"\n\nProgressToken = str | int\nCursor = str\nRole = Literal[\"user\", \"assistant\"]\nRequestId = Annotated[int | str, Field(union_mode=\"left_to_right\")]\nAnyFunction: TypeAlias = Callable[..., Any]\n\n\nclass RequestParams(BaseModel):\n    class Meta(BaseModel):\n        progressToken: ProgressToken | None = None\n        \"\"\"\n        If specified, the caller requests out-of-band progress notifications for\n        this request (as represented by notifications/progress). The value of this\n        parameter is an opaque token that will be a\n... (content truncated)\n\n--- tests/__init__.py (py) ---\n\n\n--- tests/cli/__init__.py (py) ---\n\n\n--- tests/cli/test_utils.py (py) ---\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nfrom mcp.cli.cli import _build_uv_command, _get_npx_command, _parse_file_path\n\n\n@pytest.mark.parametrize(\n    \"spec, expected_obj\",\n    [\n        (\"server.py\", None),\n        (\"foo.py:srv_obj\", \"srv_obj\"),\n    ],\n)\ndef test_parse_file_path_accepts_valid_specs(tmp_path, spec, expected_obj):\n    \"\"\"Should accept valid file specs.\"\"\"\n    file = tmp_path / spec.split(\":\")[0]\n    file.write_text(\"x = 1\")\n    path, obj = _parse_file_path(f\"{file}:{expected_obj}\" if \":\" in spec else str(file))\n    assert path == file.resolve()\n    assert obj == expected_obj\n\n\ndef test_parse_file_path_missing(tmp_path):\n    \"\"\"Should system exit if a file is missing.\"\"\"\n    with pytest.raises(SystemExit):\n        _parse_file_path(str(tmp_path / \"missing.py\"))\n\n\ndef test_parse_file_exit_on_dir(tmp_path):\n    \"\"\"Should system exit if a directory is passed\"\"\"\n    dir_path = tmp_path / \"dir\"\n    dir_path.mkdir()\n    with pytest.raises(SystemExit):\n        _parse_file_path(str(dir_path))\n\n\ndef test_build_uv_command_minimal():\n    \"\"\"Should emit core command when no extras specified.\"\"\"\n    cmd = _build_uv_command(\"foo.py\")\n    assert cmd == [\"uv\", \"run\", \"--with\", \"mcp\", \"mcp\", \"run\", \"foo.py\"]\n\n\ndef test_build_uv_command_adds_editable_and_packages():\n    \"\"\"Should include --with-editable and every --with pkg in correct order.\"\"\"\n    test_path = Path(\"/pkg\")\n    cmd = _build_uv_command(\n        \"foo.py\",\n        with_editable=test_path,\n        with_packages=[\"package1\", \"package2\"],\n    )\n    assert cmd == [\n        \"uv\",\n        \"run\",\n        \"--with\",\n        \"mcp\",\n        \"--with-editable\",\n        str(test_path),  # Use str() to match what the function does\n        \"--with\",\n        \"package1\",\n        \"--with\",\n        \"package2\",\n        \"mcp\",\n        \"run\",\n        \"foo.py\",\n    ]\n\n\ndef test_get_npx_unix_like(monkeypatch):\n    \"\"\"Should return \"npx\" on unix-like systems.\"\"\"\n    monkeypatch.setattr(sys, \"platform\", \"\n... (content truncated)\n\n--- tests/client/__init__.py (py) ---\n\n\n--- tests/client/conftest.py (py) ---\nfrom contextlib import asynccontextmanager\nfrom unittest.mock import patch\n\nimport pytest\n\nimport mcp.shared.memory\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import (\n    JSONRPCNotification,\n    JSONRPCRequest,\n)\n\n\nclass SpyMemoryObjectSendStream:\n    def __init__(self, original_stream):\n        self.original_stream = original_stream\n        self.sent_messages: list[SessionMessage] = []\n\n    async def send(self, message):\n        self.sent_messages.append(message)\n        await self.original_stream.send(message)\n\n    async def aclose(self):\n        await self.original_stream.aclose()\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *args):\n        await self.aclose()\n\n\nclass StreamSpyCollection:\n    def __init__(\n        self,\n        client_spy: SpyMemoryObjectSendStream,\n        server_spy: SpyMemoryObjectSendStream,\n    ):\n        self.client = client_spy\n        self.server = server_spy\n\n    def clear(self) -> None:\n        \"\"\"Clear all captured messages.\"\"\"\n        self.client.sent_messages.clear()\n        self.server.sent_messages.clear()\n\n    def get_client_requests(self, method: str | None = None) -> list[JSONRPCRequest]:\n        \"\"\"Get client-sent requests, optionally filtered by method.\"\"\"\n        return [\n            req.message.root\n            for req in self.client.sent_messages\n            if isinstance(req.message.root, JSONRPCRequest) and (method is None or req.message.root.method == method)\n        ]\n\n    def get_server_requests(self, method: str | None = None) -> list[JSONRPCRequest]:\n        \"\"\"Get server-sent requests, optionally filtered by method.\"\"\"\n        return [\n            req.message.root\n            for req in self.server.sent_messages\n            if isinstance(req.message.root, JSONRPCRequest) and (method is None or req.message.root.method == method)\n        ]\n\n    def get_client_notifications(self, method: str | None = None) -> list[JSONRPCNotification]:\n        \"\"\"Get client-sen\n... (content truncated)\n\n--- tests/client/test_auth.py (py) ---\n\"\"\"\nTests for refactored OAuth client authentication implementation.\n\"\"\"\n\nimport time\n\nimport httpx\nimport pytest\nfrom inline_snapshot import Is, snapshot\nfrom pydantic import AnyHttpUrl, AnyUrl\n\nfrom mcp.client.auth import OAuthClientProvider, PKCEParameters\nfrom mcp.shared.auth import (\n    OAuthClientInformationFull,\n    OAuthClientMetadata,\n    OAuthToken,\n    ProtectedResourceMetadata,\n)\n\n\nclass MockTokenStorage:\n    \"\"\"Mock token storage for testing.\"\"\"\n\n    def __init__(self):\n        self._tokens: OAuthToken | None = None\n        self._client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -> OAuthToken | None:\n        return self._tokens\n\n    async def set_tokens(self, tokens: OAuthToken) -> None:\n        self._tokens = tokens\n\n    async def get_client_info(self) -> OAuthClientInformationFull | None:\n        return self._client_info\n\n    async def set_client_info(self, client_info: OAuthClientInformationFull) -> None:\n        self._client_info = client_info\n\n\n@pytest.fixture\ndef mock_storage():\n    return MockTokenStorage()\n\n\n@pytest.fixture\ndef client_metadata():\n    return OAuthClientMetadata(\n        client_name=\"Test Client\",\n        client_uri=AnyHttpUrl(\"https://example.com\"),\n        redirect_uris=[AnyUrl(\"http://localhost:3030/callback\")],\n        scope=\"read write\",\n    )\n\n\n@pytest.fixture\ndef valid_tokens():\n    return OAuthToken(\n        access_token=\"test_access_token\",\n        token_type=\"Bearer\",\n        expires_in=3600,\n        refresh_token=\"test_refresh_token\",\n        scope=\"read write\",\n    )\n\n\n@pytest.fixture\ndef oauth_provider(client_metadata, mock_storage):\n    async def redirect_handler(url: str) -> None:\n        \"\"\"Mock redirect handler.\"\"\"\n        pass\n\n    async def callback_handler() -> tuple[str, str | None]:\n        \"\"\"Mock callback handler.\"\"\"\n        return \"test_auth_code\", \"test_state\"\n\n    return OAuthClientProvider(\n        server_url=\"https://api.example.com/v1/mcp\",\n        client_metadata=\n... (content truncated)\n\n--- tests/client/test_config.py (py) ---\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom mcp.cli.claude import update_claude_config\n\n\n@pytest.fixture\ndef temp_config_dir(tmp_path: Path):\n    \"\"\"Create a temporary Claude config directory.\"\"\"\n    config_dir = tmp_path / \"Claude\"\n    config_dir.mkdir()\n    return config_dir\n\n\n@pytest.fixture\ndef mock_config_path(temp_config_dir: Path):\n    \"\"\"Mock get_claude_config_path to return our temporary directory.\"\"\"\n    with patch(\"mcp.cli.claude.get_claude_config_path\", return_value=temp_config_dir):\n        yield temp_config_dir\n\n\ndef test_command_execution(mock_config_path: Path):\n    \"\"\"Test that the generated command can actually be executed.\"\"\"\n    # Setup\n    server_name = \"test_server\"\n    file_spec = \"test_server.py:app\"\n\n    # Update config\n    success = update_claude_config(file_spec=file_spec, server_name=server_name)\n    assert success\n\n    # Read the generated config\n    config_file = mock_config_path / \"claude_desktop_config.json\"\n    config = json.loads(config_file.read_text())\n\n    # Get the command and args\n    server_config = config[\"mcpServers\"][server_name]\n    command = server_config[\"command\"]\n    args = server_config[\"args\"]\n\n    test_args = [command] + args + [\"--help\"]\n\n    result = subprocess.run(test_args, capture_output=True, text=True, timeout=5, check=False)\n\n    assert result.returncode == 0\n    assert \"usage\" in result.stdout.lower()\n\n\ndef test_absolute_uv_path(mock_config_path: Path):\n    \"\"\"Test that the absolute path to uv is used when available.\"\"\"\n    # Mock the shutil.which function to return a fake path\n    mock_uv_path = \"/usr/local/bin/uv\"\n\n    with patch(\"mcp.cli.claude.get_uv_path\", return_value=mock_uv_path):\n        # Setup\n        server_name = \"test_server\"\n        file_spec = \"test_server.py:app\"\n\n        # Update config\n        success = update_claude_config(file_spec=file_spec, server_name=server_name)\n        assert success\n\n        # Read the generated conf\n... (content truncated)\n\n--- tests/client/test_list_methods_cursor.py (py) ---\nimport pytest\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\n\n# Mark the whole module for async tests\npytestmark = pytest.mark.anyio\n\n\nasync def test_list_tools_cursor_parameter(stream_spy):\n    \"\"\"Test that the cursor parameter is accepted for list_tools\n    and that it is correctly passed to the server.\n\n    See: https://modelcontextprotocol.io/specification/2025-03-26/server/utilities/pagination#request-format\n    \"\"\"\n    server = FastMCP(\"test\")\n\n    # Create a couple of test tools\n    @server.tool(name=\"test_tool_1\")\n    async def test_tool_1() -> str:\n        \"\"\"First test tool\"\"\"\n        return \"Result 1\"\n\n    @server.tool(name=\"test_tool_2\")\n    async def test_tool_2() -> str:\n        \"\"\"Second test tool\"\"\"\n        return \"Result 2\"\n\n    async with create_session(server._mcp_server) as client_session:\n        spies = stream_spy()\n\n        # Test without cursor parameter (omitted)\n        _ = await client_session.list_tools()\n        list_tools_requests = spies.get_client_requests(method=\"tools/list\")\n        assert len(list_tools_requests) == 1\n        assert list_tools_requests[0].params is None\n\n        spies.clear()\n\n        # Test with cursor=None\n        _ = await client_session.list_tools(cursor=None)\n        list_tools_requests = spies.get_client_requests(method=\"tools/list\")\n        assert len(list_tools_requests) == 1\n        assert list_tools_requests[0].params is None\n\n        spies.clear()\n\n        # Test with cursor as string\n        _ = await client_session.list_tools(cursor=\"some_cursor_value\")\n        list_tools_requests = spies.get_client_requests(method=\"tools/list\")\n        assert len(list_tools_requests) == 1\n        assert list_tools_requests[0].params is not None\n        assert list_tools_requests[0].params[\"cursor\"] == \"some_cursor_value\"\n\n        spies.clear()\n\n        # Test with empty string cursor\n        _ = await client_session.list_tools\n... (content truncated)\n\n--- tests/client/test_list_roots_callback.py (py) ---\nimport pytest\nfrom pydantic import FileUrl\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server.fastmcp.server import Context\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.types import ListRootsResult, Root, TextContent\n\n\n@pytest.mark.anyio\nasync def test_list_roots_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n\n    callback_return = ListRootsResult(\n        roots=[\n            Root(\n                uri=FileUrl(\"file://users/fake/test\"),\n                name=\"Test Root 1\",\n            ),\n            Root(\n                uri=FileUrl(\"file://users/fake/test/2\"),\n                name=\"Test Root 2\",\n            ),\n        ]\n    )\n\n    async def list_roots_callback(\n        context: RequestContext[ClientSession, None],\n    ) -> ListRootsResult:\n        return callback_return\n\n    @server.tool(\"test_list_roots\")\n    async def test_list_roots(context: Context, message: str):  # type: ignore[reportUnknownMemberType]\n        roots = await context.session.list_roots()\n        assert roots == callback_return\n        return True\n\n    # Test with list_roots callback\n    async with create_session(server._mcp_server, list_roots_callback=list_roots_callback) as client_session:\n        # Make a request to trigger sampling callback\n        result = await client_session.call_tool(\"test_list_roots\", {\"message\": \"test message\"})\n        assert result.isError is False\n        assert isinstance(result.content[0], TextContent)\n        assert result.content[0].text == \"true\"\n\n    # Test without list_roots callback\n    async with create_session(server._mcp_server) as client_session:\n        # Make a request to trigger sampling callback\n        result = await client_session.call_tool(\"test_list_roots\", {\"message\": \"test message\"})\n        assert result.isError is True\n        assert isinstance(result.content[0], TextContent)\n        asse\n... (content truncated)\n\n--- tests/client/test_logging_callback.py (py) ---\nfrom typing import Literal\n\nimport pytest\n\nimport mcp.types as types\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import (\n    LoggingMessageNotificationParams,\n    TextContent,\n)\n\n\nclass LoggingCollector:\n    def __init__(self):\n        self.log_messages: list[LoggingMessageNotificationParams] = []\n\n    async def __call__(self, params: LoggingMessageNotificationParams) -> None:\n        self.log_messages.append(params)\n\n\n@pytest.mark.anyio\nasync def test_logging_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n    logging_collector = LoggingCollector()\n\n    # Create a simple test tool\n    @server.tool(\"test_tool\")\n    async def test_tool() -> bool:\n        # The actual tool is very simple and just returns True\n        return True\n\n    # Create a function that can send a log notification\n    @server.tool(\"test_tool_with_log\")\n    async def test_tool_with_log(\n        message: str, level: Literal[\"debug\", \"info\", \"warning\", \"error\"], logger: str\n    ) -> bool:\n        \"\"\"Send a log notification to the client.\"\"\"\n        await server.get_context().log(\n            level=level,\n            message=message,\n            logger_name=logger,\n        )\n        return True\n\n    # Create a message handler to catch exceptions\n    async def message_handler(\n        message: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n    ) -> None:\n        if isinstance(message, Exception):\n            raise message\n\n    async with create_session(\n        server._mcp_server,\n        logging_callback=logging_collector,\n        message_handler=message_handler,\n    ) as client_session:\n        # First verify our test tool works\n        result = await client_session.call_tool(\"test_tool\", {})\n        assert result.isError is False\n        assert isinstance(result.content[0], TextContent)\n       \n... (content truncated)\n\n--- tests/client/test_output_schema_validation.py (py) ---\nimport logging\nfrom contextlib import contextmanager\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom mcp.server.lowlevel import Server\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as client_session,\n)\nfrom mcp.types import Tool\n\n\n@contextmanager\ndef bypass_server_output_validation():\n    \"\"\"\n    Context manager that bypasses server-side output validation.\n    This simulates a malicious or non-compliant server that doesn't validate\n    its outputs, allowing us to test client-side validation.\n    \"\"\"\n    # Patch jsonschema.validate in the server module to disable all validation\n    with patch(\"mcp.server.lowlevel.server.jsonschema.validate\"):\n        # The mock will simply return None (do nothing) for all validation calls\n        yield\n\n\nclass TestClientOutputSchemaValidation:\n    \"\"\"Test client-side validation of structured output from tools\"\"\"\n\n    @pytest.mark.anyio\n    async def test_tool_structured_output_client_side_validation_basemodel(self):\n        \"\"\"Test that client validates structured content against schema for BaseModel outputs\"\"\"\n        # Create a malicious low-level server that returns invalid structured content\n        server = Server(\"test-server\")\n\n        # Define the expected schema for our tool\n        output_schema = {\n            \"type\": \"object\",\n            \"properties\": {\"name\": {\"type\": \"string\", \"title\": \"Name\"}, \"age\": {\"type\": \"integer\", \"title\": \"Age\"}},\n            \"required\": [\"name\", \"age\"],\n            \"title\": \"UserOutput\",\n        }\n\n        @server.list_tools()\n        async def list_tools():\n            return [\n                Tool(\n                    name=\"get_user\",\n                    description=\"Get user data\",\n                    inputSchema={\"type\": \"object\"},\n                    outputSchema=output_schema,\n                )\n            ]\n\n        @server.call_tool()\n        async def call_tool(name: str, arguments: dict):\n            # Return invalid structured content - age is s\n... (content truncated)\n\n--- tests/client/test_resource_cleanup.py (py) ---\nfrom unittest.mock import patch\n\nimport anyio\nimport pytest\n\nfrom mcp.shared.session import BaseSession\nfrom mcp.types import (\n    ClientRequest,\n    EmptyResult,\n    PingRequest,\n)\n\n\n@pytest.mark.anyio\nasync def test_send_request_stream_cleanup():\n    \"\"\"\n    Test that send_request properly cleans up streams when an exception occurs.\n\n    This test mocks out most of the session functionality to focus on stream cleanup.\n    \"\"\"\n\n    # Create a mock session with the minimal required functionality\n    class TestSession(BaseSession):\n        async def _send_response(self, request_id, response):\n            pass\n\n    # Create streams\n    write_stream_send, write_stream_receive = anyio.create_memory_object_stream(1)\n    read_stream_send, read_stream_receive = anyio.create_memory_object_stream(1)\n\n    # Create the session\n    session = TestSession(\n        read_stream_receive,\n        write_stream_send,\n        object,  # Request type doesn't matter for this test\n        object,  # Notification type doesn't matter for this test\n    )\n\n    # Create a test request\n    request = ClientRequest(\n        PingRequest(\n            method=\"ping\",\n        )\n    )\n\n    # Patch the _write_stream.send method to raise an exception\n    async def mock_send(*args, **kwargs):\n        raise RuntimeError(\"Simulated network error\")\n\n    # Record the response streams before the test\n    initial_stream_count = len(session._response_streams)\n\n    # Run the test with the patched method\n    with patch.object(session._write_stream, \"send\", mock_send):\n        with pytest.raises(RuntimeError):\n            await session.send_request(request, EmptyResult)\n\n    # Verify that no response streams were leaked\n    assert len(session._response_streams) == initial_stream_count, (\n        f\"Expected {initial_stream_count} response streams after request, but found {len(session._response_streams)}\"\n    )\n\n    # Clean up\n    await write_stream_send.aclose()\n    await write_stream_receive.aclose()\n    await read\n... (content truncated)\n\n--- tests/client/test_sampling_callback.py (py) ---\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.types import (\n    CreateMessageRequestParams,\n    CreateMessageResult,\n    SamplingMessage,\n    TextContent,\n)\n\n\n@pytest.mark.anyio\nasync def test_sampling_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n\n    callback_return = CreateMessageResult(\n        role=\"assistant\",\n        content=TextContent(type=\"text\", text=\"This is a response from the sampling callback\"),\n        model=\"test-model\",\n        stopReason=\"endTurn\",\n    )\n\n    async def sampling_callback(\n        context: RequestContext[ClientSession, None],\n        params: CreateMessageRequestParams,\n    ) -> CreateMessageResult:\n        return callback_return\n\n    @server.tool(\"test_sampling\")\n    async def test_sampling_tool(message: str):\n        value = await server.get_context().session.create_message(\n            messages=[SamplingMessage(role=\"user\", content=TextContent(type=\"text\", text=message))],\n            max_tokens=100,\n        )\n        assert value == callback_return\n        return True\n\n    # Test with sampling callback\n    async with create_session(server._mcp_server, sampling_callback=sampling_callback) as client_session:\n        # Make a request to trigger sampling callback\n        result = await client_session.call_tool(\"test_sampling\", {\"message\": \"Test message for sampling\"})\n        assert result.isError is False\n        assert isinstance(result.content[0], TextContent)\n        assert result.content[0].text == \"true\"\n\n    # Test without sampling callback\n    async with create_session(server._mcp_server) as client_session:\n        # Make a request to trigger sampling callback\n        result = await client_session.call_tool(\"test_sampling\", {\"message\": \"Test message for sampling\"})\n        assert result.isError is True\n        assert isi\n... (content truncated)\n\n--- tests/client/test_session.py (py) ---\nfrom typing import Any\n\nimport anyio\nimport pytest\n\nimport mcp.types as types\nfrom mcp.client.session import DEFAULT_CLIENT_INFO, ClientSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\nfrom mcp.types import (\n    LATEST_PROTOCOL_VERSION,\n    ClientNotification,\n    ClientRequest,\n    Implementation,\n    InitializedNotification,\n    InitializeRequest,\n    InitializeResult,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    ServerCapabilities,\n    ServerResult,\n)\n\n\n@pytest.mark.anyio\nasync def test_client_session_initialize():\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](1)\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](1)\n\n    initialized_notification = None\n\n    async def mock_server():\n        nonlocal initialized_notification\n\n        session_message = await client_to_server_receive.receive()\n        jsonrpc_request = session_message.message\n        assert isinstance(jsonrpc_request.root, JSONRPCRequest)\n        request = ClientRequest.model_validate(\n            jsonrpc_request.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n        )\n        assert isinstance(request.root, InitializeRequest)\n\n        result = ServerResult(\n            InitializeResult(\n                protocolVersion=LATEST_PROTOCOL_VERSION,\n                capabilities=ServerCapabilities(\n                    logging=None,\n                    resources=None,\n                    tools=None,\n                    experimental=None,\n                    prompts=None,\n                ),\n                serverInfo=Implementation(name=\"mock-server\", version=\"0.1.0\"),\n                instructions=\"The server instructions.\",\n            )\n        )\n\n        async with server_to_client_send\n... (content truncated)\n\n--- tests/client/test_session_group.py (py) ---\nimport contextlib\nfrom unittest import mock\n\nimport pytest\n\nimport mcp\nfrom mcp import types\nfrom mcp.client.session_group import (\n    ClientSessionGroup,\n    SseServerParameters,\n    StreamableHttpParameters,\n)\nfrom mcp.client.stdio import StdioServerParameters\nfrom mcp.shared.exceptions import McpError\n\n\n@pytest.fixture\ndef mock_exit_stack():\n    \"\"\"Fixture for a mocked AsyncExitStack.\"\"\"\n    # Use unittest.mock.Mock directly if needed, or just a plain object\n    # if only attribute access/existence is needed.\n    # For AsyncExitStack, Mock or MagicMock is usually fine.\n    return mock.MagicMock(spec=contextlib.AsyncExitStack)\n\n\n@pytest.mark.anyio\nclass TestClientSessionGroup:\n    def test_init(self):\n        mcp_session_group = ClientSessionGroup()\n        assert not mcp_session_group._tools\n        assert not mcp_session_group._resources\n        assert not mcp_session_group._prompts\n        assert not mcp_session_group._tool_to_session\n\n    def test_component_properties(self):\n        # --- Mock Dependencies ---\n        mock_prompt = mock.Mock()\n        mock_resource = mock.Mock()\n        mock_tool = mock.Mock()\n\n        # --- Prepare Session Group ---\n        mcp_session_group = ClientSessionGroup()\n        mcp_session_group._prompts = {\"my_prompt\": mock_prompt}\n        mcp_session_group._resources = {\"my_resource\": mock_resource}\n        mcp_session_group._tools = {\"my_tool\": mock_tool}\n\n        # --- Assertions ---\n        assert mcp_session_group.prompts == {\"my_prompt\": mock_prompt}\n        assert mcp_session_group.resources == {\"my_resource\": mock_resource}\n        assert mcp_session_group.tools == {\"my_tool\": mock_tool}\n\n    async def test_call_tool(self):\n        # --- Mock Dependencies ---\n        mock_session = mock.AsyncMock()\n\n        # --- Prepare Session Group ---\n        def hook(name, server_info):\n            return f\"{(server_info.name)}-{name}\"\n\n        mcp_session_group = ClientSessionGroup(component_name_hook=hook)\n        mcp_session_group\n... (content truncated)\n\n--- tests/client/test_stdio.py (py) ---\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport textwrap\nimport time\n\nimport anyio\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import (\n    StdioServerParameters,\n    _create_platform_compatible_process,\n    stdio_client,\n)\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import CONNECTION_CLOSED, JSONRPCMessage, JSONRPCRequest, JSONRPCResponse\nfrom tests.shared.test_win32_utils import escape_path_for_python\n\n# Timeout for cleanup of processes that ignore SIGTERM\n# This timeout ensures the test fails quickly if the cleanup logic doesn't have\n# proper fallback mechanisms (SIGINT/SIGKILL) for processes that ignore SIGTERM\nSIGTERM_IGNORING_PROCESS_TIMEOUT = 5.0\n\ntee: str = shutil.which(\"tee\")  # type: ignore\npython: str = shutil.which(\"python\")  # type: ignore\n\n\n@pytest.mark.anyio\n@pytest.mark.skipif(tee is None, reason=\"could not find tee command\")\nasync def test_stdio_context_manager_exiting():\n    async with stdio_client(StdioServerParameters(command=tee)) as (_, _):\n        pass\n\n\n@pytest.mark.anyio\n@pytest.mark.skipif(tee is None, reason=\"could not find tee command\")\nasync def test_stdio_client():\n    server_parameters = StdioServerParameters(command=tee)\n\n    async with stdio_client(server_parameters) as (read_stream, write_stream):\n        # Test sending and receiving messages\n        messages = [\n            JSONRPCMessage(root=JSONRPCRequest(jsonrpc=\"2.0\", id=1, method=\"ping\")),\n            JSONRPCMessage(root=JSONRPCResponse(jsonrpc=\"2.0\", id=2, result={})),\n        ]\n\n        async with write_stream:\n            for message in messages:\n                session_message = SessionMessage(message)\n                await write_stream.send(session_message)\n\n        read_messages = []\n        async with read_stream:\n            async for message in read_stream:\n                if isinstance(message, Exception):\n                    raise message\n\n                rea\n... (content truncated)\n\n--- tests/conftest.py (py) ---\nimport pytest\n\n\n@pytest.fixture\ndef anyio_backend():\n    return \"asyncio\"\n\n\n--- tests/issues/test_100_tool_listing.py (py) ---\nimport pytest\n\nfrom mcp.server.fastmcp import FastMCP\n\npytestmark = pytest.mark.anyio\n\n\nasync def test_list_tools_returns_all_tools():\n    mcp = FastMCP(\"TestTools\")\n\n    # Create 100 tools with unique names\n    num_tools = 100\n    for i in range(num_tools):\n\n        @mcp.tool(name=f\"tool_{i}\")\n        def dummy_tool_func():\n            f\"\"\"Tool number {i}\"\"\"\n            return i\n\n        globals()[f\"dummy_tool_{i}\"] = dummy_tool_func  # Keep reference to avoid garbage collection\n\n    # Get all tools\n    tools = await mcp.list_tools()\n\n    # Verify we get all tools\n    assert len(tools) == num_tools, f\"Expected {num_tools} tools, but got {len(tools)}\"\n\n    # Verify each tool is unique and has the correct name\n    tool_names = [tool.name for tool in tools]\n    expected_names = [f\"tool_{i}\" for i in range(num_tools)]\n    assert sorted(tool_names) == sorted(expected_names), \"Tool names don't match expected names\"\n\n\n--- tests/issues/test_1027_win_unreachable_cleanup.py (py) ---\n\"\"\"\nRegression test for issue #1027: Ensure cleanup procedures run properly during shutdown\n\nIssue #1027 reported that cleanup code after \"yield\" in lifespan was unreachable when\nprocesses were terminated. This has been fixed by implementing the MCP spec-compliant\nstdio shutdown sequence that closes stdin first, allowing graceful exit.\n\nThese tests verify the fix continues to work correctly across all platforms.\n\"\"\"\n\nimport sys\nimport tempfile\nimport textwrap\nfrom pathlib import Path\n\nimport anyio\nimport pytest\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import _create_platform_compatible_process, stdio_client\nfrom tests.shared.test_win32_utils import escape_path_for_python\n\n\n@pytest.mark.anyio\nasync def test_lifespan_cleanup_executed():\n    \"\"\"\n    Regression test ensuring MCP server cleanup code runs during shutdown.\n\n    This test verifies that the fix for issue #1027 works correctly by:\n    1. Starting an MCP server that writes a marker file on startup\n    2. Shutting down the server normally via stdio_client\n    3. Verifying the cleanup code (after yield) executed and wrote its marker file\n\n    The fix implements proper stdin closure before termination, giving servers\n    time to run their cleanup handlers.\n    \"\"\"\n\n    # Create marker files to track server lifecycle\n    with tempfile.NamedTemporaryFile(mode=\"w\", delete=False, suffix=\".txt\") as f:\n        startup_marker = f.name\n    with tempfile.NamedTemporaryFile(mode=\"w\", delete=False, suffix=\".txt\") as f:\n        cleanup_marker = f.name\n\n    # Remove the files so we can detect when they're created\n    Path(startup_marker).unlink()\n    Path(cleanup_marker).unlink()\n\n    # Create a minimal MCP server using FastMCP that tracks lifecycle\n    server_code = textwrap.dedent(f\"\"\"\n        import asyncio\n        import sys\n        from pathlib import Path\n        from contextlib import asynccontextmanager\n        from mcp.server.fastmcp import FastMCP\n        \n        STARTUP_MARKER = \n... (content truncated)\n\n--- tests/issues/test_129_resource_templates.py (py) ---\nimport pytest\n\nfrom mcp import types\nfrom mcp.server.fastmcp import FastMCP\n\n\n@pytest.mark.anyio\nasync def test_resource_templates():\n    # Create an MCP server\n    mcp = FastMCP(\"Demo\")\n\n    # Add a dynamic greeting resource\n    @mcp.resource(\"greeting://{name}\")\n    def get_greeting(name: str) -> str:\n        \"\"\"Get a personalized greeting\"\"\"\n        return f\"Hello, {name}!\"\n\n    @mcp.resource(\"users://{user_id}/profile\")\n    def get_user_profile(user_id: str) -> str:\n        \"\"\"Dynamic user data\"\"\"\n        return f\"Profile data for user {user_id}\"\n\n    # Get the list of resource templates using the underlying server\n    # Note: list_resource_templates() returns a decorator that wraps the handler\n    # The handler returns a ServerResult with a ListResourceTemplatesResult inside\n    result = await mcp._mcp_server.request_handlers[types.ListResourceTemplatesRequest](\n        types.ListResourceTemplatesRequest(method=\"resources/templates/list\", params=None)\n    )\n    assert isinstance(result.root, types.ListResourceTemplatesResult)\n    templates = result.root.resourceTemplates\n\n    # Verify we get both templates back\n    assert len(templates) == 2\n\n    # Verify template details\n    greeting_template = next(t for t in templates if t.name == \"get_greeting\")\n    assert greeting_template.uriTemplate == \"greeting://{name}\"\n    assert greeting_template.description == \"Get a personalized greeting\"\n\n    profile_template = next(t for t in templates if t.name == \"get_user_profile\")\n    assert profile_template.uriTemplate == \"users://{user_id}/profile\"\n    assert profile_template.description == \"Dynamic user data\"\n\n\n--- tests/issues/test_141_resource_templates.py (py) ---\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as client_session,\n)\nfrom mcp.types import (\n    ListResourceTemplatesResult,\n    TextResourceContents,\n)\n\n\n@pytest.mark.anyio\nasync def test_resource_template_edge_cases():\n    \"\"\"Test server-side resource template validation\"\"\"\n    mcp = FastMCP(\"Demo\")\n\n    # Test case 1: Template with multiple parameters\n    @mcp.resource(\"resource://users/{user_id}/posts/{post_id}\")\n    def get_user_post(user_id: str, post_id: str) -> str:\n        return f\"Post {post_id} by user {user_id}\"\n\n    # Test case 2: Template with optional parameter (should fail)\n    with pytest.raises(ValueError, match=\"Mismatch between URI parameters\"):\n\n        @mcp.resource(\"resource://users/{user_id}/profile\")\n        def get_user_profile(user_id: str, optional_param: str | None = None) -> str:\n            return f\"Profile for user {user_id}\"\n\n    # Test case 3: Template with mismatched parameters\n    with pytest.raises(ValueError, match=\"Mismatch between URI parameters\"):\n\n        @mcp.resource(\"resource://users/{user_id}/profile\")\n        def get_user_profile_mismatch(different_param: str) -> str:\n            return f\"Profile for user {different_param}\"\n\n    # Test case 4: Template with extra function parameters\n    with pytest.raises(ValueError, match=\"Mismatch between URI parameters\"):\n\n        @mcp.resource(\"resource://users/{user_id}/profile\")\n        def get_user_profile_extra(user_id: str, extra_param: str) -> str:\n            return f\"Profile for user {user_id}\"\n\n    # Test case 5: Template with missing function parameters\n    with pytest.raises(ValueError, match=\"Mismatch between URI parameters\"):\n\n        @mcp.resource(\"resource://users/{user_id}/profile/{section}\")\n        def get_user_profile_missing(user_id: str) -> str:\n            return f\"Profile for user {user_id}\"\n\n    # Verify valid template works\n    result = await mcp\n... (content truncated)\n\n--- tests/issues/test_152_resource_mime_type.py (py) ---\nimport base64\n\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp import types\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.lowlevel.helper_types import ReadResourceContents\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as client_session,\n)\n\npytestmark = pytest.mark.anyio\n\n\nasync def test_fastmcp_resource_mime_type():\n    \"\"\"Test that mime_type parameter is respected for resources.\"\"\"\n    mcp = FastMCP(\"test\")\n\n    # Create a small test image as bytes\n    image_bytes = b\"fake_image_data\"\n    base64_string = base64.b64encode(image_bytes).decode(\"utf-8\")\n\n    @mcp.resource(\"test://image\", mime_type=\"image/png\")\n    def get_image_as_string() -> str:\n        \"\"\"Return a test image as base64 string.\"\"\"\n        return base64_string\n\n    @mcp.resource(\"test://image_bytes\", mime_type=\"image/png\")\n    def get_image_as_bytes() -> bytes:\n        \"\"\"Return a test image as bytes.\"\"\"\n        return image_bytes\n\n    # Test that resources are listed with correct mime type\n    async with client_session(mcp._mcp_server) as client:\n        # List resources and verify mime types\n        resources = await client.list_resources()\n        assert resources.resources is not None\n\n        mapping = {str(r.uri): r for r in resources.resources}\n\n        # Find our resources\n        string_resource = mapping[\"test://image\"]\n        bytes_resource = mapping[\"test://image_bytes\"]\n\n        # Verify mime types\n        assert string_resource.mimeType == \"image/png\", \"String resource mime type not respected\"\n        assert bytes_resource.mimeType == \"image/png\", \"Bytes resource mime type not respected\"\n\n        # Also verify the content can be read correctly\n        string_result = await client.read_resource(AnyUrl(\"test://image\"))\n        assert len(string_result.contents) == 1\n        assert getattr(string_result.contents[0], \"text\") == base64_string, \"Base64 string mismatch\"\n        assert string_result.contents[0].\n... (content truncated)\n\n--- tests/issues/test_176_progress_token.py (py) ---\nfrom unittest.mock import AsyncMock, MagicMock\n\nimport pytest\n\nfrom mcp.server.fastmcp import Context\nfrom mcp.shared.context import RequestContext\n\npytestmark = pytest.mark.anyio\n\n\nasync def test_progress_token_zero_first_call():\n    \"\"\"Test that progress notifications work when progress_token is 0 on first call.\"\"\"\n\n    # Create mock session with progress notification tracking\n    mock_session = AsyncMock()\n    mock_session.send_progress_notification = AsyncMock()\n\n    # Create request context with progress token 0\n    mock_meta = MagicMock()\n    mock_meta.progressToken = 0  # This is the key test case - token is 0\n\n    request_context = RequestContext(\n        request_id=\"test-request\",\n        session=mock_session,\n        meta=mock_meta,\n        lifespan_context=None,\n    )\n\n    # Create context with our mocks\n    ctx = Context(request_context=request_context, fastmcp=MagicMock())\n\n    # Test progress reporting\n    await ctx.report_progress(0, 10)  # First call with 0\n    await ctx.report_progress(5, 10)  # Middle progress\n    await ctx.report_progress(10, 10)  # Complete\n\n    # Verify progress notifications\n    assert mock_session.send_progress_notification.call_count == 3, \"All progress notifications should be sent\"\n    mock_session.send_progress_notification.assert_any_call(progress_token=0, progress=0.0, total=10.0, message=None)\n    mock_session.send_progress_notification.assert_any_call(progress_token=0, progress=5.0, total=10.0, message=None)\n    mock_session.send_progress_notification.assert_any_call(progress_token=0, progress=10.0, total=10.0, message=None)\n\n\n--- tests/issues/test_188_concurrency.py (py) ---\nimport anyio\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import create_connected_server_and_client_session as create_session\n\n\n@pytest.mark.anyio\nasync def test_messages_are_executed_concurrently_tools():\n    server = FastMCP(\"test\")\n    event = anyio.Event()\n    tool_started = anyio.Event()\n    call_order = []\n\n    @server.tool(\"sleep\")\n    async def sleep_tool():\n        call_order.append(\"waiting_for_event\")\n        tool_started.set()\n        await event.wait()\n        call_order.append(\"tool_end\")\n        return \"done\"\n\n    @server.tool(\"trigger\")\n    async def trigger():\n        # Wait for tool to start before setting the event\n        await tool_started.wait()\n        call_order.append(\"trigger_started\")\n        event.set()\n        call_order.append(\"trigger_end\")\n        return \"slow\"\n\n    async with create_session(server._mcp_server) as client_session:\n        # First tool will wait on event, second will set it\n        async with anyio.create_task_group() as tg:\n            # Start the tool first (it will wait on event)\n            tg.start_soon(client_session.call_tool, \"sleep\")\n            # Then the trigger tool will set the event to allow the first tool to continue\n            await client_session.call_tool(\"trigger\")\n\n        # Verify that both ran concurrently\n        assert call_order == [\n            \"waiting_for_event\",\n            \"trigger_started\",\n            \"trigger_end\",\n            \"tool_end\",\n        ], f\"Expected concurrent execution, but got: {call_order}\"\n\n\n@pytest.mark.anyio\nasync def test_messages_are_executed_concurrently_tools_and_resources():\n    server = FastMCP(\"test\")\n    event = anyio.Event()\n    tool_started = anyio.Event()\n    call_order = []\n\n    @server.tool(\"sleep\")\n    async def sleep_tool():\n        call_order.append(\"waiting_for_event\")\n        tool_started.set()\n        await event.wait()\n        call_order.append(\"tool_end\")\n        return \"done\"\n\n    @server.\n... (content truncated)\n\n--- tests/issues/test_192_request_id.py (py) ---\nimport anyio\nimport pytest\n\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import (\n    LATEST_PROTOCOL_VERSION,\n    ClientCapabilities,\n    Implementation,\n    InitializeRequestParams,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    NotificationParams,\n)\n\n\n@pytest.mark.anyio\nasync def test_request_id_match() -> None:\n    \"\"\"Test that the server preserves request IDs in responses.\"\"\"\n    server = Server(\"test\")\n    custom_request_id = \"test-123\"\n\n    # Create memory streams for communication\n    client_writer, client_reader = anyio.create_memory_object_stream(1)\n    server_writer, server_reader = anyio.create_memory_object_stream(1)\n\n    # Server task to process the request\n    async def run_server():\n        async with client_reader, server_writer:\n            await server.run(\n                client_reader,\n                server_writer,\n                InitializationOptions(\n                    server_name=\"test\",\n                    server_version=\"1.0.0\",\n                    capabilities=server.get_capabilities(\n                        notification_options=NotificationOptions(),\n                        experimental_capabilities={},\n                    ),\n                ),\n                raise_exceptions=True,\n            )\n\n    # Start server task\n    async with (\n        anyio.create_task_group() as tg,\n        client_writer,\n        client_reader,\n        server_writer,\n        server_reader,\n    ):\n        tg.start_soon(run_server)\n\n        # Send initialize request\n        init_req = JSONRPCRequest(\n            id=\"init-1\",\n            method=\"initialize\",\n            params=InitializeRequestParams(\n                protocolVersion=LATEST_PROTOCOL_VERSION,\n                capabilities=ClientCapabilities(),\n                clientInfo=Implementation(name=\"test-client\", version=\"1.0.0\"),\n            ).model_dump(by\n... (content truncated)\n\n--- tests/issues/test_342_base64_encoding.py (py) ---\n\"\"\"Test for base64 encoding issue in MCP server.\n\nThis test demonstrates the issue in server.py where the server uses\nurlsafe_b64encode but the BlobResourceContents validator expects standard\nbase64 encoding.\n\nThe test should FAIL before fixing server.py to use b64encode instead of\nurlsafe_b64encode.\nAfter the fix, the test should PASS.\n\"\"\"\n\nimport base64\nfrom typing import cast\n\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.server.lowlevel.helper_types import ReadResourceContents\nfrom mcp.server.lowlevel.server import Server\nfrom mcp.types import (\n    BlobResourceContents,\n    ReadResourceRequest,\n    ReadResourceRequestParams,\n    ReadResourceResult,\n    ServerResult,\n)\n\n\n@pytest.mark.anyio\nasync def test_server_base64_encoding_issue():\n    \"\"\"Tests that server response can be validated by BlobResourceContents.\n\n    This test will:\n    1. Set up a server that returns binary data\n    2. Extract the base64-encoded blob from the server's response\n    3. Verify the encoded data can be properly validated by BlobResourceContents\n\n    BEFORE FIX: The test will fail because server uses urlsafe_b64encode\n    AFTER FIX: The test will pass because server uses standard b64encode\n    \"\"\"\n    server = Server(\"test\")\n\n    # Create binary data that will definitely result in + and / characters\n    # when encoded with standard base64\n    binary_data = bytes(list(range(255)) * 4)\n\n    # Register a resource handler that returns our test data\n    @server.read_resource()\n    async def read_resource(uri: AnyUrl) -> list[ReadResourceContents]:\n        return [ReadResourceContents(content=binary_data, mime_type=\"application/octet-stream\")]\n\n    # Get the handler directly from the server\n    handler = server.request_handlers[ReadResourceRequest]\n\n    # Create a request\n    request = ReadResourceRequest(\n        method=\"resources/read\",\n        params=ReadResourceRequestParams(uri=AnyUrl(\"test://resource\")),\n    )\n\n    # Call the handler to get the response\n    result: ServerResult =\n... (content truncated)\n\n--- tests/issues/test_355_type_error.py (py) ---\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\n\nfrom mcp.server.fastmcp import Context, FastMCP\n\n\nclass Database:  # Replace with your actual DB type\n    @classmethod\n    async def connect(cls):\n        return cls()\n\n    async def disconnect(self):\n        pass\n\n    def query(self):\n        return \"Hello, World!\"\n\n\n# Create a named server\nmcp = FastMCP(\"My App\")\n\n\n@dataclass\nclass AppContext:\n    db: Database\n\n\n@asynccontextmanager\nasync def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:\n    \"\"\"Manage application lifecycle with type-safe context\"\"\"\n    # Initialize on startup\n    db = await Database.connect()\n    try:\n        yield AppContext(db=db)\n    finally:\n        # Cleanup on shutdown\n        await db.disconnect()\n\n\n# Pass lifespan to server\nmcp = FastMCP(\"My App\", lifespan=app_lifespan)\n\n\n# Access type-safe lifespan context in tools\n@mcp.tool()\ndef query_db(ctx: Context) -> str:\n    \"\"\"Tool that uses initialized resources\"\"\"\n    db = ctx.request_context.lifespan_context.db\n    return db.query()\n\n\n--- tests/issues/test_552_windows_hang.py (py) ---\n\"\"\"Test for issue #552: stdio_client hangs on Windows.\"\"\"\n\nimport sys\nfrom textwrap import dedent\n\nimport anyio\nimport pytest\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\n\n@pytest.mark.skipif(sys.platform != \"win32\", reason=\"Windows-specific test\")\n@pytest.mark.anyio\nasync def test_windows_stdio_client_with_session():\n    \"\"\"\n    Test the exact scenario from issue #552: Using ClientSession with stdio_client.\n\n    This reproduces the original bug report where stdio_client hangs on Windows 11\n    when used with ClientSession.\n    \"\"\"\n    # Create a minimal MCP server that responds to initialization\n    server_script = dedent(\"\"\"\n        import json\n        import sys\n\n        # Read initialization request\n        line = sys.stdin.readline()\n\n        # Send initialization response\n        response = {\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"result\": {\n                \"protocolVersion\": \"1.0\",\n                \"capabilities\": {},\n                \"serverInfo\": {\"name\": \"test-server\", \"version\": \"1.0\"}\n            }\n        }\n        print(json.dumps(response))\n        sys.stdout.flush()\n\n        # Exit after a short delay\n        import time\n        time.sleep(0.1)\n        sys.exit(0)\n    \"\"\").strip()\n\n    params = StdioServerParameters(\n        command=sys.executable,\n        args=[\"-c\", server_script],\n    )\n\n    # This is the exact pattern from the bug report\n    with anyio.fail_after(10):\n        try:\n            async with stdio_client(params) as (read, write):\n                async with ClientSession(read, write) as session:\n                    await session.initialize()\n                # Should exit ClientSession without hanging\n            # Should exit stdio_client without hanging\n        except Exception:\n            # Connection errors are expected when process exits\n            pass\n\n\n--- tests/issues/test_88_random_error.py (py) ---\n\"\"\"Test to reproduce issue #88: Random error thrown on response.\"\"\"\n\nfrom collections.abc import Sequence\nfrom datetime import timedelta\nfrom pathlib import Path\n\nimport anyio\nimport pytest\nfrom anyio.abc import TaskStatus\n\nfrom mcp import types\nfrom mcp.client.session import ClientSession\nfrom mcp.server.lowlevel import Server\nfrom mcp.shared.exceptions import McpError\nfrom mcp.types import ContentBlock, TextContent\n\n\n@pytest.mark.anyio\nasync def test_notification_validation_error(tmp_path: Path):\n    \"\"\"Test that timeouts are handled gracefully and don't break the server.\n\n    This test verifies that when a client request times out:\n    1. The server task stays alive\n    2. The server can still handle new requests\n    3. The client can make new requests\n    4. No resources are leaked\n    \"\"\"\n\n    server = Server(name=\"test\")\n    request_count = 0\n    slow_request_started = anyio.Event()\n    slow_request_complete = anyio.Event()\n\n    @server.list_tools()\n    async def list_tools() -> list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"slow\",\n                description=\"A slow tool\",\n                inputSchema={\"type\": \"object\"},\n            ),\n            types.Tool(\n                name=\"fast\",\n                description=\"A fast tool\",\n                inputSchema={\"type\": \"object\"},\n            ),\n        ]\n\n    @server.call_tool()\n    async def slow_tool(name: str, arg) -> Sequence[ContentBlock]:\n        nonlocal request_count\n        request_count += 1\n\n        if name == \"slow\":\n            # Signal that slow request has started\n            slow_request_started.set()\n            # Long enough to ensure timeout\n            await anyio.sleep(0.2)\n            # Signal completion\n            slow_request_complete.set()\n            return [TextContent(type=\"text\", text=f\"slow {request_count}\")]\n        elif name == \"fast\":\n            # Fast enough to complete before timeout\n            await anyio.sleep(0.01)\n            return [Text\n... (content truncated)\n\n--- tests/issues/test_malformed_input.py (py) ---\n# Claude Debug\n\"\"\"Test for HackerOne vulnerability report #3156202 - malformed input DOS.\"\"\"\n\nimport anyio\nimport pytest\n\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import (\n    INVALID_PARAMS,\n    JSONRPCError,\n    JSONRPCMessage,\n    JSONRPCRequest,\n    ServerCapabilities,\n)\n\n\n@pytest.mark.anyio\nasync def test_malformed_initialize_request_does_not_crash_server():\n    \"\"\"\n    Test that malformed initialize requests return proper error responses\n    instead of crashing the server (HackerOne #3156202).\n    \"\"\"\n    # Create in-memory streams for testing\n    read_send_stream, read_receive_stream = anyio.create_memory_object_stream[SessionMessage | Exception](10)\n    write_send_stream, write_receive_stream = anyio.create_memory_object_stream[SessionMessage](10)\n\n    try:\n        # Create a malformed initialize request (missing required params field)\n        malformed_request = JSONRPCRequest(\n            jsonrpc=\"2.0\",\n            id=\"f20fe86132ed4cd197f89a7134de5685\",\n            method=\"initialize\",\n            # params=None  # Missing required params field\n        )\n\n        # Wrap in session message\n        request_message = SessionMessage(message=JSONRPCMessage(malformed_request))\n\n        # Start a server session\n        async with ServerSession(\n            read_stream=read_receive_stream,\n            write_stream=write_send_stream,\n            init_options=InitializationOptions(\n                server_name=\"test_server\",\n                server_version=\"1.0.0\",\n                capabilities=ServerCapabilities(),\n            ),\n        ):\n            # Send the malformed request\n            await read_send_stream.send(request_message)\n\n            # Give the session time to process the request\n            await anyio.sleep(0.1)\n\n            # Check that we received an error response instead of a crash\n            try:\n                response_message =\n... (content truncated)\n\n--- tests/server/__init__.py (py) ---\n\n\n--- tests/server/auth/middleware/test_auth_context.py (py) ---\n\"\"\"\nTests for the AuthContext middleware components.\n\"\"\"\n\nimport time\n\nimport pytest\nfrom starlette.types import Message, Receive, Scope, Send\n\nfrom mcp.server.auth.middleware.auth_context import (\n    AuthContextMiddleware,\n    auth_context_var,\n    get_access_token,\n)\nfrom mcp.server.auth.middleware.bearer_auth import AuthenticatedUser\nfrom mcp.server.auth.provider import AccessToken\n\n\nclass MockApp:\n    \"\"\"Mock ASGI app for testing.\"\"\"\n\n    def __init__(self):\n        self.called = False\n        self.scope: Scope | None = None\n        self.receive: Receive | None = None\n        self.send: Send | None = None\n        self.access_token_during_call: AccessToken | None = None\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        self.called = True\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n        # Check the context during the call\n        self.access_token_during_call = get_access_token()\n\n\n@pytest.fixture\ndef valid_access_token() -> AccessToken:\n    \"\"\"Create a valid access token.\"\"\"\n    return AccessToken(\n        token=\"valid_token\",\n        client_id=\"test_client\",\n        scopes=[\"read\", \"write\"],\n        expires_at=int(time.time()) + 3600,  # 1 hour from now\n    )\n\n\n@pytest.mark.anyio\nclass TestAuthContextMiddleware:\n    \"\"\"Tests for the AuthContextMiddleware class.\"\"\"\n\n    async def test_with_authenticated_user(self, valid_access_token: AccessToken):\n        \"\"\"Test middleware with an authenticated user in scope.\"\"\"\n        app = MockApp()\n        middleware = AuthContextMiddleware(app)\n\n        # Create an authenticated user\n        user = AuthenticatedUser(valid_access_token)\n\n        scope: Scope = {\"type\": \"http\", \"user\": user}\n\n        # Create dummy async functions for receive and send\n        async def receive() -> Message:\n            return {\"type\": \"http.request\"}\n\n        async def send(message: Message) -> None:\n            pass\n\n        # Verify context is empty before m\n... (content truncated)\n\n--- tests/server/auth/middleware/test_bearer_auth.py (py) ---\n\"\"\"\nTests for the BearerAuth middleware components.\n\"\"\"\n\nimport time\nfrom typing import Any, cast\n\nimport pytest\nfrom starlette.authentication import AuthCredentials\nfrom starlette.datastructures import Headers\nfrom starlette.requests import Request\nfrom starlette.types import Message, Receive, Scope, Send\n\nfrom mcp.server.auth.middleware.bearer_auth import (\n    AuthenticatedUser,\n    BearerAuthBackend,\n    RequireAuthMiddleware,\n)\nfrom mcp.server.auth.provider import (\n    AccessToken,\n    OAuthAuthorizationServerProvider,\n    ProviderTokenVerifier,\n)\n\n\nclass MockOAuthProvider:\n    \"\"\"Mock OAuth provider for testing.\n\n    This is a simplified version that only implements the methods needed for testing\n    the BearerAuthMiddleware components.\n    \"\"\"\n\n    def __init__(self):\n        self.tokens = {}  # token -> AccessToken\n\n    def add_token(self, token: str, access_token: AccessToken) -> None:\n        \"\"\"Add a token to the provider.\"\"\"\n        self.tokens[token] = access_token\n\n    async def load_access_token(self, token: str) -> AccessToken | None:\n        \"\"\"Load an access token.\"\"\"\n        return self.tokens.get(token)\n\n\ndef add_token_to_provider(\n    provider: OAuthAuthorizationServerProvider[Any, Any, Any],\n    token: str,\n    access_token: AccessToken,\n) -> None:\n    \"\"\"Helper function to add a token to a provider.\n\n    This is used to work around type checking issues with our mock provider.\n    \"\"\"\n    # We know this is actually a MockOAuthProvider\n    mock_provider = cast(MockOAuthProvider, provider)\n    mock_provider.add_token(token, access_token)\n\n\nclass MockApp:\n    \"\"\"Mock ASGI app for testing.\"\"\"\n\n    def __init__(self):\n        self.called = False\n        self.scope: Scope | None = None\n        self.receive: Receive | None = None\n        self.send: Send | None = None\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        self.called = True\n        self.scope = scope\n        self.receive = receive\n        self.send \n... (content truncated)\n\n--- tests/server/auth/test_error_handling.py (py) ---\n\"\"\"\nTests for OAuth error handling in the auth handlers.\n\"\"\"\n\nimport unittest.mock\nfrom urllib.parse import parse_qs, urlparse\n\nimport httpx\nimport pytest\nfrom httpx import ASGITransport\nfrom pydantic import AnyHttpUrl\nfrom starlette.applications import Starlette\n\nfrom mcp.server.auth.provider import (\n    AuthorizeError,\n    RegistrationError,\n    TokenError,\n)\nfrom mcp.server.auth.routes import create_auth_routes\nfrom tests.server.fastmcp.auth.test_auth_integration import (\n    MockOAuthProvider,\n)\n\n\n@pytest.fixture\ndef oauth_provider():\n    \"\"\"Return a MockOAuthProvider instance that can be configured to raise errors.\"\"\"\n    return MockOAuthProvider()\n\n\n@pytest.fixture\ndef app(oauth_provider):\n    from mcp.server.auth.settings import ClientRegistrationOptions, RevocationOptions\n\n    # Enable client registration\n    client_registration_options = ClientRegistrationOptions(enabled=True)\n    revocation_options = RevocationOptions(enabled=True)\n\n    # Create auth routes\n    auth_routes = create_auth_routes(\n        oauth_provider,\n        issuer_url=AnyHttpUrl(\"http://localhost\"),\n        client_registration_options=client_registration_options,\n        revocation_options=revocation_options,\n    )\n\n    # Create Starlette app with routes directly\n    return Starlette(routes=auth_routes)\n\n\n@pytest.fixture\ndef client(app):\n    transport = ASGITransport(app=app)\n    # Use base_url without a path since routes are directly on the app\n    return httpx.AsyncClient(transport=transport, base_url=\"http://localhost\")\n\n\n@pytest.fixture\ndef pkce_challenge():\n    \"\"\"Create a PKCE challenge with code_verifier and code_challenge.\"\"\"\n    import base64\n    import hashlib\n    import secrets\n\n    # Generate a code verifier\n    code_verifier = secrets.token_urlsafe(64)[:128]\n\n    # Create code challenge using S256 method\n    code_verifier_bytes = code_verifier.encode(\"ascii\")\n    sha256 = hashlib.sha256(code_verifier_bytes).digest()\n    code_challenge = base64.urlsafe_b64encode(sha256).deco\n... (content truncated)\n\n--- tests/server/fastmcp/__init__.py (py) ---\n\n\n--- tests/server/fastmcp/auth/__init__.py (py) ---\n\"\"\"\nTests for the MCP server auth components.\n\"\"\"\n\n\n--- tests/server/fastmcp/auth/test_auth_integration.py (py) ---\n\"\"\"\nIntegration tests for MCP authorization components.\n\"\"\"\n\nimport base64\nimport hashlib\nimport secrets\nimport time\nimport unittest.mock\nfrom urllib.parse import parse_qs, urlparse\n\nimport httpx\nimport pytest\nfrom pydantic import AnyHttpUrl\nfrom starlette.applications import Starlette\n\nfrom mcp.server.auth.provider import (\n    AccessToken,\n    AuthorizationCode,\n    AuthorizationParams,\n    OAuthAuthorizationServerProvider,\n    RefreshToken,\n    construct_redirect_uri,\n)\nfrom mcp.server.auth.routes import (\n    ClientRegistrationOptions,\n    RevocationOptions,\n    create_auth_routes,\n)\nfrom mcp.shared.auth import (\n    OAuthClientInformationFull,\n    OAuthToken,\n)\n\n\n# Mock OAuth provider for testing\nclass MockOAuthProvider(OAuthAuthorizationServerProvider):\n    def __init__(self):\n        self.clients = {}\n        self.auth_codes = {}  # code -> {client_id, code_challenge, redirect_uri}\n        self.tokens = {}  # token -> {client_id, scopes, expires_at}\n        self.refresh_tokens = {}  # refresh_token -> access_token\n\n    async def get_client(self, client_id: str) -> OAuthClientInformationFull | None:\n        return self.clients.get(client_id)\n\n    async def register_client(self, client_info: OAuthClientInformationFull):\n        self.clients[client_info.client_id] = client_info\n\n    async def authorize(self, client: OAuthClientInformationFull, params: AuthorizationParams) -> str:\n        # toy authorize implementation which just immediately generates an authorization\n        # code and completes the redirect\n        code = AuthorizationCode(\n            code=f\"code_{int(time.time())}\",\n            client_id=client.client_id,\n            code_challenge=params.code_challenge,\n            redirect_uri=params.redirect_uri,\n            redirect_uri_provided_explicitly=params.redirect_uri_provided_explicitly,\n            expires_at=time.time() + 300,\n            scopes=params.scopes or [\"read\", \"write\"],\n        )\n        self.auth_codes[code.code] = code\n\n        ret\n... (content truncated)\n\n--- tests/server/fastmcp/prompts/__init__.py (py) ---\n\n\n--- tests/server/fastmcp/prompts/test_base.py (py) ---\nimport pytest\nfrom pydantic import FileUrl\n\nfrom mcp.server.fastmcp.prompts.base import (\n    AssistantMessage,\n    Message,\n    Prompt,\n    TextContent,\n    UserMessage,\n)\nfrom mcp.types import EmbeddedResource, TextResourceContents\n\n\nclass TestRenderPrompt:\n    @pytest.mark.anyio\n    async def test_basic_fn(self):\n        def fn() -> str:\n            return \"Hello, world!\"\n\n        prompt = Prompt.from_function(fn)\n        assert await prompt.render() == [UserMessage(content=TextContent(type=\"text\", text=\"Hello, world!\"))]\n\n    @pytest.mark.anyio\n    async def test_async_fn(self):\n        async def fn() -> str:\n            return \"Hello, world!\"\n\n        prompt = Prompt.from_function(fn)\n        assert await prompt.render() == [UserMessage(content=TextContent(type=\"text\", text=\"Hello, world!\"))]\n\n    @pytest.mark.anyio\n    async def test_fn_with_args(self):\n        async def fn(name: str, age: int = 30) -> str:\n            return f\"Hello, {name}! You're {age} years old.\"\n\n        prompt = Prompt.from_function(fn)\n        assert await prompt.render(arguments={\"name\": \"World\"}) == [\n            UserMessage(content=TextContent(type=\"text\", text=\"Hello, World! You're 30 years old.\"))\n        ]\n\n    @pytest.mark.anyio\n    async def test_fn_with_invalid_kwargs(self):\n        async def fn(name: str, age: int = 30) -> str:\n            return f\"Hello, {name}! You're {age} years old.\"\n\n        prompt = Prompt.from_function(fn)\n        with pytest.raises(ValueError):\n            await prompt.render(arguments={\"age\": 40})\n\n    @pytest.mark.anyio\n    async def test_fn_returns_message(self):\n        async def fn() -> UserMessage:\n            return UserMessage(content=\"Hello, world!\")\n\n        prompt = Prompt.from_function(fn)\n        assert await prompt.render() == [UserMessage(content=TextContent(type=\"text\", text=\"Hello, world!\"))]\n\n    @pytest.mark.anyio\n    async def test_fn_returns_assistant_message(self):\n        async def fn() -> AssistantMessage:\n            return Ass\n... (content truncated)\n\n--- tests/server/fastmcp/prompts/test_manager.py (py) ---\nimport pytest\n\nfrom mcp.server.fastmcp.prompts.base import Prompt, TextContent, UserMessage\nfrom mcp.server.fastmcp.prompts.manager import PromptManager\n\n\nclass TestPromptManager:\n    def test_add_prompt(self):\n        \"\"\"Test adding a prompt to the manager.\"\"\"\n\n        def fn() -> str:\n            return \"Hello, world!\"\n\n        manager = PromptManager()\n        prompt = Prompt.from_function(fn)\n        added = manager.add_prompt(prompt)\n        assert added == prompt\n        assert manager.get_prompt(\"fn\") == prompt\n\n    def test_add_duplicate_prompt(self, caplog):\n        \"\"\"Test adding the same prompt twice.\"\"\"\n\n        def fn() -> str:\n            return \"Hello, world!\"\n\n        manager = PromptManager()\n        prompt = Prompt.from_function(fn)\n        first = manager.add_prompt(prompt)\n        second = manager.add_prompt(prompt)\n        assert first == second\n        assert \"Prompt already exists\" in caplog.text\n\n    def test_disable_warn_on_duplicate_prompts(self, caplog):\n        \"\"\"Test disabling warning on duplicate prompts.\"\"\"\n\n        def fn() -> str:\n            return \"Hello, world!\"\n\n        manager = PromptManager(warn_on_duplicate_prompts=False)\n        prompt = Prompt.from_function(fn)\n        first = manager.add_prompt(prompt)\n        second = manager.add_prompt(prompt)\n        assert first == second\n        assert \"Prompt already exists\" not in caplog.text\n\n    def test_list_prompts(self):\n        \"\"\"Test listing all prompts.\"\"\"\n\n        def fn1() -> str:\n            return \"Hello, world!\"\n\n        def fn2() -> str:\n            return \"Goodbye, world!\"\n\n        manager = PromptManager()\n        prompt1 = Prompt.from_function(fn1)\n        prompt2 = Prompt.from_function(fn2)\n        manager.add_prompt(prompt1)\n        manager.add_prompt(prompt2)\n        prompts = manager.list_prompts()\n        assert len(prompts) == 2\n        assert prompts == [prompt1, prompt2]\n\n    @pytest.mark.anyio\n    async def test_render_prompt(self):\n        \"\"\"Test render\n... (content truncated)\n\n--- tests/server/fastmcp/resources/__init__.py (py) ---\n\n\n--- tests/server/fastmcp/resources/test_file_resources.py (py) ---\nimport os\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\n\nimport pytest\nfrom pydantic import FileUrl\n\nfrom mcp.server.fastmcp.resources import FileResource\n\n\n@pytest.fixture\ndef temp_file():\n    \"\"\"Create a temporary file for testing.\n\n    File is automatically cleaned up after the test if it still exists.\n    \"\"\"\n    content = \"test content\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(content)\n        path = Path(f.name).resolve()\n    yield path\n    try:\n        path.unlink()\n    except FileNotFoundError:\n        pass  # File was already deleted by the test\n\n\nclass TestFileResource:\n    \"\"\"Test FileResource functionality.\"\"\"\n\n    def test_file_resource_creation(self, temp_file: Path):\n        \"\"\"Test creating a FileResource.\"\"\"\n        resource = FileResource(\n            uri=FileUrl(temp_file.as_uri()),\n            name=\"test\",\n            description=\"test file\",\n            path=temp_file,\n        )\n        assert str(resource.uri) == temp_file.as_uri()\n        assert resource.name == \"test\"\n        assert resource.description == \"test file\"\n        assert resource.mime_type == \"text/plain\"  # default\n        assert resource.path == temp_file\n        assert resource.is_binary is False  # default\n\n    def test_file_resource_str_path_conversion(self, temp_file: Path):\n        \"\"\"Test FileResource handles string paths.\"\"\"\n        resource = FileResource(\n            uri=FileUrl(f\"file://{temp_file}\"),\n            name=\"test\",\n            path=Path(str(temp_file)),\n        )\n        assert isinstance(resource.path, Path)\n        assert resource.path.is_absolute()\n\n    @pytest.mark.anyio\n    async def test_read_text_file(self, temp_file: Path):\n        \"\"\"Test reading a text file.\"\"\"\n        resource = FileResource(\n            uri=FileUrl(f\"file://{temp_file}\"),\n            name=\"test\",\n            path=temp_file,\n        )\n        content = await resource.read()\n        assert content == \"test content\"\n        assert \n... (content truncated)\n\n--- tests/server/fastmcp/resources/test_function_resources.py (py) ---\nimport pytest\nfrom pydantic import AnyUrl, BaseModel\n\nfrom mcp.server.fastmcp.resources import FunctionResource\n\n\nclass TestFunctionResource:\n    \"\"\"Test FunctionResource functionality.\"\"\"\n\n    def test_function_resource_creation(self):\n        \"\"\"Test creating a FunctionResource.\"\"\"\n\n        def my_func() -> str:\n            return \"test content\"\n\n        resource = FunctionResource(\n            uri=AnyUrl(\"fn://test\"),\n            name=\"test\",\n            description=\"test function\",\n            fn=my_func,\n        )\n        assert str(resource.uri) == \"fn://test\"\n        assert resource.name == \"test\"\n        assert resource.description == \"test function\"\n        assert resource.mime_type == \"text/plain\"  # default\n        assert resource.fn == my_func\n\n    @pytest.mark.anyio\n    async def test_read_text(self):\n        \"\"\"Test reading text from a FunctionResource.\"\"\"\n\n        def get_data() -> str:\n            return \"Hello, world!\"\n\n        resource = FunctionResource(\n            uri=AnyUrl(\"function://test\"),\n            name=\"test\",\n            fn=get_data,\n        )\n        content = await resource.read()\n        assert content == \"Hello, world!\"\n        assert resource.mime_type == \"text/plain\"\n\n    @pytest.mark.anyio\n    async def test_read_binary(self):\n        \"\"\"Test reading binary data from a FunctionResource.\"\"\"\n\n        def get_data() -> bytes:\n            return b\"Hello, world!\"\n\n        resource = FunctionResource(\n            uri=AnyUrl(\"function://test\"),\n            name=\"test\",\n            fn=get_data,\n        )\n        content = await resource.read()\n        assert content == b\"Hello, world!\"\n\n    @pytest.mark.anyio\n    async def test_json_conversion(self):\n        \"\"\"Test automatic JSON conversion of non-string results.\"\"\"\n\n        def get_data() -> dict:\n            return {\"key\": \"value\"}\n\n        resource = FunctionResource(\n            uri=AnyUrl(\"function://test\"),\n            name=\"test\",\n            fn=get_data,\n        )\n        conte\n... (content truncated)\n\n--- tests/server/fastmcp/resources/test_resource_manager.py (py) ---\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\n\nimport pytest\nfrom pydantic import AnyUrl, FileUrl\n\nfrom mcp.server.fastmcp.resources import (\n    FileResource,\n    FunctionResource,\n    ResourceManager,\n    ResourceTemplate,\n)\n\n\n@pytest.fixture\ndef temp_file():\n    \"\"\"Create a temporary file for testing.\n\n    File is automatically cleaned up after the test if it still exists.\n    \"\"\"\n    content = \"test content\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(content)\n        path = Path(f.name).resolve()\n    yield path\n    try:\n        path.unlink()\n    except FileNotFoundError:\n        pass  # File was already deleted by the test\n\n\nclass TestResourceManager:\n    \"\"\"Test ResourceManager functionality.\"\"\"\n\n    def test_add_resource(self, temp_file: Path):\n        \"\"\"Test adding a resource.\"\"\"\n        manager = ResourceManager()\n        resource = FileResource(\n            uri=FileUrl(f\"file://{temp_file}\"),\n            name=\"test\",\n            path=temp_file,\n        )\n        added = manager.add_resource(resource)\n        assert added == resource\n        assert manager.list_resources() == [resource]\n\n    def test_add_duplicate_resource(self, temp_file: Path):\n        \"\"\"Test adding the same resource twice.\"\"\"\n        manager = ResourceManager()\n        resource = FileResource(\n            uri=FileUrl(f\"file://{temp_file}\"),\n            name=\"test\",\n            path=temp_file,\n        )\n        first = manager.add_resource(resource)\n        second = manager.add_resource(resource)\n        assert first == second\n        assert manager.list_resources() == [resource]\n\n    def test_warn_on_duplicate_resources(self, temp_file: Path, caplog):\n        \"\"\"Test warning on duplicate resources.\"\"\"\n        manager = ResourceManager()\n        resource = FileResource(\n            uri=FileUrl(f\"file://{temp_file}\"),\n            name=\"test\",\n            path=temp_file,\n        )\n        manager.add_resource(resource)\n        manager.add_r\n... (content truncated)\n\n--- tests/server/fastmcp/resources/test_resource_template.py (py) ---\nimport json\n\nimport pytest\nfrom pydantic import BaseModel\n\nfrom mcp.server.fastmcp.resources import FunctionResource, ResourceTemplate\n\n\nclass TestResourceTemplate:\n    \"\"\"Test ResourceTemplate functionality.\"\"\"\n\n    def test_template_creation(self):\n        \"\"\"Test creating a template from a function.\"\"\"\n\n        def my_func(key: str, value: int) -> dict:\n            return {\"key\": key, \"value\": value}\n\n        template = ResourceTemplate.from_function(\n            fn=my_func,\n            uri_template=\"test://{key}/{value}\",\n            name=\"test\",\n        )\n        assert template.uri_template == \"test://{key}/{value}\"\n        assert template.name == \"test\"\n        assert template.mime_type == \"text/plain\"  # default\n        test_input = {\"key\": \"test\", \"value\": 42}\n        assert template.fn(**test_input) == my_func(**test_input)\n\n    def test_template_matches(self):\n        \"\"\"Test matching URIs against a template.\"\"\"\n\n        def my_func(key: str, value: int) -> dict:\n            return {\"key\": key, \"value\": value}\n\n        template = ResourceTemplate.from_function(\n            fn=my_func,\n            uri_template=\"test://{key}/{value}\",\n            name=\"test\",\n        )\n\n        # Valid match\n        params = template.matches(\"test://foo/123\")\n        assert params == {\"key\": \"foo\", \"value\": \"123\"}\n\n        # No match\n        assert template.matches(\"test://foo\") is None\n        assert template.matches(\"other://foo/123\") is None\n\n    @pytest.mark.anyio\n    async def test_create_resource(self):\n        \"\"\"Test creating a resource from a template.\"\"\"\n\n        def my_func(key: str, value: int) -> dict:\n            return {\"key\": key, \"value\": value}\n\n        template = ResourceTemplate.from_function(\n            fn=my_func,\n            uri_template=\"test://{key}/{value}\",\n            name=\"test\",\n        )\n\n        resource = await template.create_resource(\n            \"test://foo/123\",\n            {\"key\": \"foo\", \"value\": 123},\n        )\n\n        assert isinsta\n... (content truncated)\n\n--- tests/server/fastmcp/resources/test_resources.py (py) ---\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.server.fastmcp.resources import FunctionResource, Resource\n\n\nclass TestResourceValidation:\n    \"\"\"Test base Resource validation.\"\"\"\n\n    def test_resource_uri_validation(self):\n        \"\"\"Test URI validation.\"\"\"\n\n        def dummy_func() -> str:\n            return \"data\"\n\n        # Valid URI\n        resource = FunctionResource(\n            uri=AnyUrl(\"http://example.com/data\"),\n            name=\"test\",\n            fn=dummy_func,\n        )\n        assert str(resource.uri) == \"http://example.com/data\"\n\n        # Missing protocol\n        with pytest.raises(ValueError, match=\"Input should be a valid URL\"):\n            FunctionResource(\n                uri=AnyUrl(\"invalid\"),\n                name=\"test\",\n                fn=dummy_func,\n            )\n\n        # Missing host\n        with pytest.raises(ValueError, match=\"Input should be a valid URL\"):\n            FunctionResource(\n                uri=AnyUrl(\"http://\"),\n                name=\"test\",\n                fn=dummy_func,\n            )\n\n    def test_resource_name_from_uri(self):\n        \"\"\"Test name is extracted from URI if not provided.\"\"\"\n\n        def dummy_func() -> str:\n            return \"data\"\n\n        resource = FunctionResource(\n            uri=AnyUrl(\"resource://my-resource\"),\n            fn=dummy_func,\n        )\n        assert resource.name == \"resource://my-resource\"\n\n    def test_resource_name_validation(self):\n        \"\"\"Test name validation.\"\"\"\n\n        def dummy_func() -> str:\n            return \"data\"\n\n        # Must provide either name or URI\n        with pytest.raises(ValueError, match=\"Either name or uri must be provided\"):\n            FunctionResource(\n                fn=dummy_func,\n            )\n\n        # Explicit name takes precedence over URI\n        resource = FunctionResource(\n            uri=AnyUrl(\"resource://uri-name\"),\n            name=\"explicit-name\",\n            fn=dummy_func,\n        )\n        assert resource.name == \"explicit-name\"\n\n  \n... (content truncated)\n\n--- tests/server/fastmcp/servers/__init__.py (py) ---\n\n\n--- tests/server/fastmcp/servers/test_file_server.py (py) ---\nimport json\nfrom pathlib import Path\n\nimport pytest\n\nfrom mcp.server.fastmcp import FastMCP\n\n\n@pytest.fixture()\ndef test_dir(tmp_path_factory) -> Path:\n    \"\"\"Create a temporary directory with test files.\"\"\"\n    tmp = tmp_path_factory.mktemp(\"test_files\")\n\n    # Create test files\n    (tmp / \"example.py\").write_text(\"print('hello world')\")\n    (tmp / \"readme.md\").write_text(\"# Test Directory\\nThis is a test.\")\n    (tmp / \"config.json\").write_text('{\"test\": true}')\n\n    return tmp\n\n\n@pytest.fixture\ndef mcp() -> FastMCP:\n    mcp = FastMCP()\n\n    return mcp\n\n\n@pytest.fixture(autouse=True)\ndef resources(mcp: FastMCP, test_dir: Path) -> FastMCP:\n    @mcp.resource(\"dir://test_dir\")\n    def list_test_dir() -> list[str]:\n        \"\"\"List the files in the test directory\"\"\"\n        return [str(f) for f in test_dir.iterdir()]\n\n    @mcp.resource(\"file://test_dir/example.py\")\n    def read_example_py() -> str:\n        \"\"\"Read the example.py file\"\"\"\n        try:\n            return (test_dir / \"example.py\").read_text()\n        except FileNotFoundError:\n            return \"File not found\"\n\n    @mcp.resource(\"file://test_dir/readme.md\")\n    def read_readme_md() -> str:\n        \"\"\"Read the readme.md file\"\"\"\n        try:\n            return (test_dir / \"readme.md\").read_text()\n        except FileNotFoundError:\n            return \"File not found\"\n\n    @mcp.resource(\"file://test_dir/config.json\")\n    def read_config_json() -> str:\n        \"\"\"Read the config.json file\"\"\"\n        try:\n            return (test_dir / \"config.json\").read_text()\n        except FileNotFoundError:\n            return \"File not found\"\n\n    return mcp\n\n\n@pytest.fixture(autouse=True)\ndef tools(mcp: FastMCP, test_dir: Path) -> FastMCP:\n    @mcp.tool()\n    def delete_file(path: str) -> bool:\n        # ensure path is in test_dir\n        if Path(path).resolve().parent != test_dir:\n            raise ValueError(f\"Path must be in test_dir: {path}\")\n        Path(path).unlink()\n        return True\n\n    return mcp\n\n\n@pytest.mark\n... (content truncated)\n\n--- tests/server/fastmcp/test_elicitation.py (py) ---\n\"\"\"\nTest the elicitation feature using stdio transport.\n\"\"\"\n\nimport pytest\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.shared.memory import create_connected_server_and_client_session\nfrom mcp.types import ElicitResult, TextContent\n\n\n# Shared schema for basic tests\nclass AnswerSchema(BaseModel):\n    answer: str = Field(description=\"The user's answer to the question\")\n\n\ndef create_ask_user_tool(mcp: FastMCP):\n    \"\"\"Create a standard ask_user tool that handles all elicitation responses.\"\"\"\n\n    @mcp.tool(description=\"A tool that uses elicitation\")\n    async def ask_user(prompt: str, ctx: Context) -> str:\n        result = await ctx.elicit(\n            message=f\"Tool wants to ask: {prompt}\",\n            schema=AnswerSchema,\n        )\n\n        if result.action == \"accept\" and result.data:\n            return f\"User answered: {result.data.answer}\"\n        elif result.action == \"decline\":\n            return \"User declined to answer\"\n        else:\n            return \"User cancelled\"\n\n    return ask_user\n\n\nasync def call_tool_and_assert(\n    mcp: FastMCP,\n    elicitation_callback,\n    tool_name: str,\n    args: dict,\n    expected_text: str | None = None,\n    text_contains: list[str] | None = None,\n):\n    \"\"\"Helper to create session, call tool, and assert result.\"\"\"\n    async with create_connected_server_and_client_session(\n        mcp._mcp_server, elicitation_callback=elicitation_callback\n    ) as client_session:\n        await client_session.initialize()\n\n        result = await client_session.call_tool(tool_name, args)\n        assert len(result.content) == 1\n        assert isinstance(result.content[0], TextContent)\n\n        if expected_text is not None:\n            assert result.content[0].text == expected_text\n        elif text_contains is not None:\n            for substring in text_contains:\n                assert substring in result.content[0].text\n\n        return result\n\n\n@pytest.mark.anyio\nasync def test_stdio_elicitatio\n... (content truncated)\n\n--- tests/server/fastmcp/test_func_metadata.py (py) ---\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, TypedDict\n\nimport annotated_types\nimport pytest\nfrom dirty_equals import IsPartialDict\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp.utilities.func_metadata import func_metadata\n\n\nclass SomeInputModelA(BaseModel):\n    pass\n\n\nclass SomeInputModelB(BaseModel):\n    class InnerModel(BaseModel):\n        x: int\n\n    how_many_shrimp: Annotated[int, Field(description=\"How many shrimp in the tank???\")]\n    ok: InnerModel\n    y: None\n\n\ndef complex_arguments_fn(\n    an_int: int,\n    must_be_none: None,\n    must_be_none_dumb_annotation: Annotated[None, \"blah\"],\n    list_of_ints: list[int],\n    # list[str] | str is an interesting case because if it comes in as JSON like\n    # \"[\\\"a\\\", \\\"b\\\"]\" then it will be naively parsed as a string.\n    list_str_or_str: list[str] | str,\n    an_int_annotated_with_field: Annotated[int, Field(description=\"An int with a field\")],\n    an_int_annotated_with_field_and_others: Annotated[\n        int,\n        str,  # Should be ignored, really\n        Field(description=\"An int with a field\"),\n        annotated_types.Gt(1),\n    ],\n    an_int_annotated_with_junk: Annotated[\n        int,\n        \"123\",\n        456,\n    ],\n    field_with_default_via_field_annotation_before_nondefault_arg: Annotated[int, Field(1)],\n    unannotated,\n    my_model_a: SomeInputModelA,\n    my_model_a_forward_ref: \"SomeInputModelA\",\n    my_model_b: SomeInputModelB,\n    an_int_annotated_with_field_default: Annotated[\n        int,\n        Field(1, description=\"An int with a field\"),\n    ],\n    unannotated_with_default=5,\n    my_model_a_with_default: SomeInputModelA = SomeInputModelA(),  # noqa: B008\n    an_int_with_default: int = 1,\n    must_be_none_with_default: None = None,\n    an_int_with_equals_field: int = Field(1, ge=0),\n    int_annotated_with_default: Annotated[int, Field(description=\"hey\")] = 5,\n) -> str:\n    _ = (\n        an_int,\n        must_be_none,\n        must_be_none_dumb_annotation,\n... (content truncated)\n\n--- tests/server/fastmcp/test_integration.py (py) ---\n\"\"\"\nIntegration tests for FastMCP server functionality.\n\nThese tests validate the proper functioning of FastMCP features using focused,\nsingle-feature servers across different transports (SSE and StreamableHTTP).\n\"\"\"\n\nimport json\nimport multiprocessing\nimport socket\nimport time\nfrom collections.abc import Generator\n\nimport pytest\nimport uvicorn\nfrom pydantic import AnyUrl\n\nfrom examples.snippets.servers import (\n    basic_prompt,\n    basic_resource,\n    basic_tool,\n    completion,\n    elicitation,\n    fastmcp_quickstart,\n    notifications,\n    sampling,\n    structured_output,\n    tool_progress,\n)\nfrom mcp.client.session import ClientSession\nfrom mcp.client.sse import sse_client\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.types import (\n    CreateMessageResult,\n    ElicitResult,\n    GetPromptResult,\n    InitializeResult,\n    LoggingMessageNotification,\n    ProgressNotification,\n    ReadResourceResult,\n    ResourceListChangedNotification,\n    ServerNotification,\n    TextContent,\n    TextResourceContents,\n    ToolListChangedNotification,\n)\n\n\nclass NotificationCollector:\n    \"\"\"Collects notifications from the server for testing.\"\"\"\n\n    def __init__(self):\n        self.progress_notifications: list = []\n        self.log_messages: list = []\n        self.resource_notifications: list = []\n        self.tool_notifications: list = []\n\n    async def handle_generic_notification(self, message) -> None:\n        \"\"\"Handle any server notification and route to appropriate handler.\"\"\"\n        if isinstance(message, ServerNotification):\n            if isinstance(message.root, ProgressNotification):\n                self.progress_notifications.append(message.root.params)\n            elif isinstance(message.root, LoggingMessageNotification):\n                self.log_messages.append(message.root.params)\n            elif isinstance(message.root, ResourceListChangedNotification):\n                self.resource_notifications.append(message.root.params)\n            eli\n... (content truncated)\n\n--- tests/server/fastmcp/test_parameter_descriptions.py (py) ---\n\"\"\"Test that parameter descriptions are properly exposed through list_tools\"\"\"\n\nimport pytest\nfrom pydantic import Field\n\nfrom mcp.server.fastmcp import FastMCP\n\n\n@pytest.mark.anyio\nasync def test_parameter_descriptions():\n    mcp = FastMCP(\"Test Server\")\n\n    @mcp.tool()\n    def greet(\n        name: str = Field(description=\"The name to greet\"),\n        title: str = Field(description=\"Optional title\", default=\"\"),\n    ) -> str:\n        \"\"\"A greeting tool\"\"\"\n        return f\"Hello {title} {name}\"\n\n    tools = await mcp.list_tools()\n    assert len(tools) == 1\n    tool = tools[0]\n\n    # Check that parameter descriptions are present in the schema\n    properties = tool.inputSchema[\"properties\"]\n    assert \"name\" in properties\n    assert properties[\"name\"][\"description\"] == \"The name to greet\"\n    assert \"title\" in properties\n    assert properties[\"title\"][\"description\"] == \"Optional title\"\n\n\n--- tests/server/fastmcp/test_server.py (py) ---\nimport base64\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\nfrom unittest.mock import patch\n\nimport pytest\nfrom pydantic import AnyUrl, BaseModel\nfrom starlette.routing import Mount, Route\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.fastmcp.prompts.base import Message, UserMessage\nfrom mcp.server.fastmcp.resources import FileResource, FunctionResource\nfrom mcp.server.fastmcp.utilities.types import Image\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as client_session,\n)\nfrom mcp.types import (\n    AudioContent,\n    BlobResourceContents,\n    ContentBlock,\n    EmbeddedResource,\n    ImageContent,\n    TextContent,\n    TextResourceContents,\n)\n\nif TYPE_CHECKING:\n    from mcp.server.fastmcp import Context\n\n\nclass TestServer:\n    @pytest.mark.anyio\n    async def test_create_server(self):\n        mcp = FastMCP(instructions=\"Server instructions\")\n        assert mcp.name == \"FastMCP\"\n        assert mcp.instructions == \"Server instructions\"\n\n    @pytest.mark.anyio\n    async def test_normalize_path(self):\n        \"\"\"Test path normalization for mount paths.\"\"\"\n        mcp = FastMCP()\n\n        # Test root path\n        assert mcp._normalize_path(\"/\", \"/messages/\") == \"/messages/\"\n\n        # Test path with trailing slash\n        assert mcp._normalize_path(\"/github/\", \"/messages/\") == \"/github/messages/\"\n\n        # Test path without trailing slash\n        assert mcp._normalize_path(\"/github\", \"/messages/\") == \"/github/messages/\"\n\n        # Test endpoint without leading slash\n        assert mcp._normalize_path(\"/github\", \"messages/\") == \"/github/messages/\"\n\n        # Test both with trailing/leading slashes\n        assert mcp._normalize_path(\"/api/\", \"/v1/\") == \"/api/v1/\"\n\n    @pytest.mark.anyio\n    async def test_sse_app_with_mount_path(self):\n        \"\"\"Test SSE app creation with different mount paths.\"\"\"\n        # Test with default mount path\n        mcp = FastMCP()\n     \n... (content truncated)\n\n--- tests/server/fastmcp/test_title.py (py) ---\n\"\"\"Integration tests for title field functionality.\"\"\"\n\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.server.fastmcp.resources import FunctionResource\nfrom mcp.shared.memory import create_connected_server_and_client_session\nfrom mcp.shared.metadata_utils import get_display_name\nfrom mcp.types import Prompt, Resource, ResourceTemplate, Tool, ToolAnnotations\n\n\n@pytest.mark.anyio\nasync def test_tool_title_precedence():\n    \"\"\"Test that tool title precedence works correctly: title > annotations.title > name.\"\"\"\n    # Create server with various tool configurations\n    mcp = FastMCP(name=\"TitleTestServer\")\n\n    # Tool with only name\n    @mcp.tool(description=\"Basic tool\")\n    def basic_tool(message: str) -> str:\n        return message\n\n    # Tool with title\n    @mcp.tool(description=\"Tool with title\", title=\"User-Friendly Tool\")\n    def tool_with_title(message: str) -> str:\n        return message\n\n    # Tool with annotations.title (when title is not supported on decorator)\n    # We'll need to add this manually after registration\n    @mcp.tool(description=\"Tool with annotations\")\n    def tool_with_annotations(message: str) -> str:\n        return message\n\n    # Tool with both title and annotations.title\n    @mcp.tool(description=\"Tool with both\", title=\"Primary Title\")\n    def tool_with_both(message: str) -> str:\n        return message\n\n    # Start server and connect client\n    async with create_connected_server_and_client_session(mcp._mcp_server) as client:\n        await client.initialize()\n\n        # List tools\n        tools_result = await client.list_tools()\n        tools = {tool.name: tool for tool in tools_result.tools}\n\n        # Verify basic tool uses name\n        assert \"basic_tool\" in tools\n        basic = tools[\"basic_tool\"]\n        # Since we haven't implemented get_display_name yet, we'll check the raw fields\n        assert basic.title is None\n        assert basic.name == \"basic_tool\"\n\n        # Verify tool with title\n... (content truncated)\n\n--- tests/server/fastmcp/test_tool_manager.py (py) ---\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, TypedDict\n\nimport pytest\nfrom pydantic import BaseModel\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.fastmcp.exceptions import ToolError\nfrom mcp.server.fastmcp.tools import Tool, ToolManager\nfrom mcp.server.fastmcp.utilities.func_metadata import ArgModelBase, FuncMetadata\nfrom mcp.server.session import ServerSessionT\nfrom mcp.shared.context import LifespanContextT, RequestT\nfrom mcp.types import TextContent, ToolAnnotations\n\n\nclass TestAddTools:\n    def test_basic_function(self):\n        \"\"\"Test registering and running a basic function.\"\"\"\n\n        def sum(a: int, b: int) -> int:\n            \"\"\"Add two numbers.\"\"\"\n            return a + b\n\n        manager = ToolManager()\n        manager.add_tool(sum)\n\n        tool = manager.get_tool(\"sum\")\n        assert tool is not None\n        assert tool.name == \"sum\"\n        assert tool.description == \"Add two numbers.\"\n        assert tool.is_async is False\n        assert tool.parameters[\"properties\"][\"a\"][\"type\"] == \"integer\"\n        assert tool.parameters[\"properties\"][\"b\"][\"type\"] == \"integer\"\n\n    def test_init_with_tools(self, caplog):\n        def sum(a: int, b: int) -> int:\n            return a + b\n\n        class AddArguments(ArgModelBase):\n            a: int\n            b: int\n\n        fn_metadata = FuncMetadata(arg_model=AddArguments)\n\n        original_tool = Tool(\n            name=\"sum\",\n            title=\"Add Tool\",\n            description=\"Add two numbers.\",\n            fn=sum,\n            fn_metadata=fn_metadata,\n            is_async=False,\n            parameters=AddArguments.model_json_schema(),\n            context_kwarg=None,\n            annotations=None,\n        )\n        manager = ToolManager(tools=[original_tool])\n        saved_tool = manager.get_tool(\"sum\")\n        assert saved_tool == original_tool\n\n        # warn on duplicate tools\n        with caplog.at_level(logging.WARNING):\n            manager = ToolM\n... (content truncated)\n\n--- tests/server/test_completion_with_context.py (py) ---\n\"\"\"\nTests for completion handler with context functionality.\n\"\"\"\n\nimport pytest\n\nfrom mcp.server.lowlevel import Server\nfrom mcp.shared.memory import create_connected_server_and_client_session\nfrom mcp.types import (\n    Completion,\n    CompletionArgument,\n    CompletionContext,\n    PromptReference,\n    ResourceTemplateReference,\n)\n\n\n@pytest.mark.anyio\nasync def test_completion_handler_receives_context():\n    \"\"\"Test that the completion handler receives context correctly.\"\"\"\n    server = Server(\"test-server\")\n\n    # Track what the handler receives\n    received_args = {}\n\n    @server.completion()\n    async def handle_completion(\n        ref: PromptReference | ResourceTemplateReference,\n        argument: CompletionArgument,\n        context: CompletionContext | None,\n    ) -> Completion | None:\n        received_args[\"ref\"] = ref\n        received_args[\"argument\"] = argument\n        received_args[\"context\"] = context\n\n        # Return test completion\n        return Completion(values=[\"test-completion\"], total=1, hasMore=False)\n\n    async with create_connected_server_and_client_session(server) as client:\n        # Test with context\n        result = await client.complete(\n            ref=ResourceTemplateReference(type=\"ref/resource\", uri=\"test://resource/{param}\"),\n            argument={\"name\": \"param\", \"value\": \"test\"},\n            context_arguments={\"previous\": \"value\"},\n        )\n\n        # Verify handler received the context\n        assert received_args[\"context\"] is not None\n        assert received_args[\"context\"].arguments == {\"previous\": \"value\"}\n        assert result.completion.values == [\"test-completion\"]\n\n\n@pytest.mark.anyio\nasync def test_completion_backward_compatibility():\n    \"\"\"Test that completion works without context (backward compatibility).\"\"\"\n    server = Server(\"test-server\")\n\n    context_was_none = False\n\n    @server.completion()\n    async def handle_completion(\n        ref: PromptReference | ResourceTemplateReference,\n        argument: CompletionAr\n... (content truncated)\n\n--- tests/server/test_lifespan.py (py) ---\n\"\"\"Tests for lifespan functionality in both low-level and FastMCP servers.\"\"\"\n\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nimport anyio\nimport pytest\nfrom pydantic import TypeAdapter\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.lowlevel.server import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import (\n    ClientCapabilities,\n    Implementation,\n    InitializeRequestParams,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n)\n\n\n@pytest.mark.anyio\nasync def test_lowlevel_server_lifespan():\n    \"\"\"Test that lifespan works in low-level server.\"\"\"\n\n    @asynccontextmanager\n    async def test_lifespan(server: Server) -> AsyncIterator[dict[str, bool]]:\n        \"\"\"Test lifespan context that tracks startup/shutdown.\"\"\"\n        context = {\"started\": False, \"shutdown\": False}\n        try:\n            context[\"started\"] = True\n            yield context\n        finally:\n            context[\"shutdown\"] = True\n\n    server = Server(\"test\", lifespan=test_lifespan)\n\n    # Create memory streams for testing\n    send_stream1, receive_stream1 = anyio.create_memory_object_stream(100)\n    send_stream2, receive_stream2 = anyio.create_memory_object_stream(100)\n\n    # Create a tool that accesses lifespan context\n    @server.call_tool()\n    async def check_lifespan(name: str, arguments: dict) -> list:\n        ctx = server.request_context\n        assert isinstance(ctx.lifespan_context, dict)\n        assert ctx.lifespan_context[\"started\"]\n        assert not ctx.lifespan_context[\"shutdown\"]\n        return [{\"type\": \"text\", \"text\": \"true\"}]\n\n    # Run server in background task\n    async with (\n        anyio.create_task_group() as tg,\n        send_stream1,\n        receive_stream1,\n        send_stream2,\n        receive_stream2,\n    ):\n\n        async def run_server():\n            await server.run(\n                receive_stream1,\n... (content truncated)\n\n--- tests/server/test_lowlevel_input_validation.py (py) ---\n\"\"\"Test input schema validation for lowlevel server.\"\"\"\n\nimport logging\nfrom collections.abc import Awaitable, Callable\nfrom typing import Any\n\nimport anyio\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.server.lowlevel import NotificationOptions\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import CallToolResult, ClientResult, ServerNotification, ServerRequest, TextContent, Tool\n\n\nasync def run_tool_test(\n    tools: list[Tool],\n    call_tool_handler: Callable[[str, dict[str, Any]], Awaitable[list[TextContent]]],\n    test_callback: Callable[[ClientSession], Awaitable[CallToolResult]],\n) -> CallToolResult:\n    \"\"\"Helper to run a tool test with minimal boilerplate.\n\n    Args:\n        tools: List of tools to register\n        call_tool_handler: Handler function for tool calls\n        test_callback: Async function that performs the test using the client session\n\n    Returns:\n        The result of the tool call\n    \"\"\"\n    server = Server(\"test\")\n\n    @server.list_tools()\n    async def list_tools():\n        return tools\n\n    @server.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:\n        return await call_tool_handler(name, arguments)\n\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](10)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](10)\n\n    # Message handler for client\n    async def message_handler(\n        message: RequestResponder[ServerRequest, ClientResult] | ServerNotification | Exception,\n    ) -> None:\n        if isinstance(message, Exception):\n            raise message\n\n    # Server task\n    async def run_server():\n        async with ServerSession(\n            client_to_server_receive,\n           \n... (content truncated)\n\n--- tests/server/test_lowlevel_output_validation.py (py) ---\n\"\"\"Test output schema validation for lowlevel server.\"\"\"\n\nimport json\nfrom collections.abc import Awaitable, Callable\nfrom typing import Any\n\nimport anyio\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.server.lowlevel import NotificationOptions\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import CallToolResult, ClientResult, ServerNotification, ServerRequest, TextContent, Tool\n\n\nasync def run_tool_test(\n    tools: list[Tool],\n    call_tool_handler: Callable[[str, dict[str, Any]], Awaitable[Any]],\n    test_callback: Callable[[ClientSession], Awaitable[CallToolResult]],\n) -> CallToolResult:\n    \"\"\"Helper to run a tool test with minimal boilerplate.\n\n    Args:\n        tools: List of tools to register\n        call_tool_handler: Handler function for tool calls\n        test_callback: Async function that performs the test using the client session\n\n    Returns:\n        The result of the tool call\n    \"\"\"\n    server = Server(\"test\")\n\n    @server.list_tools()\n    async def list_tools():\n        return tools\n\n    @server.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]):\n        return await call_tool_handler(name, arguments)\n\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](10)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](10)\n\n    # Message handler for client\n    async def message_handler(\n        message: RequestResponder[ServerRequest, ClientResult] | ServerNotification | Exception,\n    ) -> None:\n        if isinstance(message, Exception):\n            raise message\n\n    # Server task\n    async def run_server():\n        async with ServerSession(\n            client_to_server_receive,\n            server_to_client_send,\n            I\n... (content truncated)\n\n--- tests/server/test_lowlevel_tool_annotations.py (py) ---\n\"\"\"Tests for tool annotations in low-level server.\"\"\"\n\nimport anyio\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.server.lowlevel import NotificationOptions\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import ClientResult, ServerNotification, ServerRequest, Tool, ToolAnnotations\n\n\n@pytest.mark.anyio\nasync def test_lowlevel_server_tool_annotations():\n    \"\"\"Test that tool annotations work in low-level server.\"\"\"\n    server = Server(\"test\")\n\n    # Create a tool with annotations\n    @server.list_tools()\n    async def list_tools():\n        return [\n            Tool(\n                name=\"echo\",\n                description=\"Echo a message back\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"message\": {\"type\": \"string\"},\n                    },\n                    \"required\": [\"message\"],\n                },\n                annotations=ToolAnnotations(\n                    title=\"Echo Tool\",\n                    readOnlyHint=True,\n                ),\n            )\n        ]\n\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](10)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](10)\n\n    # Message handler for client\n    async def message_handler(\n        message: RequestResponder[ServerRequest, ClientResult] | ServerNotification | Exception,\n    ) -> None:\n        if isinstance(message, Exception):\n            raise message\n\n    # Server task\n    async def run_server():\n        async with ServerSession(\n            client_to_server_receive,\n            server_to_client_send,\n            InitializationOptions(\n                server_name=\"test-server\",\n                server_version\n... (content truncated)\n\n--- tests/server/test_read_resource.py (py) ---\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\n\nimport pytest\nfrom pydantic import AnyUrl, FileUrl\n\nimport mcp.types as types\nfrom mcp.server.lowlevel.server import ReadResourceContents, Server\n\n\n@pytest.fixture\ndef temp_file():\n    \"\"\"Create a temporary file for testing.\"\"\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(\"test content\")\n        path = Path(f.name).resolve()\n    yield path\n    try:\n        path.unlink()\n    except FileNotFoundError:\n        pass\n\n\n@pytest.mark.anyio\nasync def test_read_resource_text(temp_file: Path):\n    server = Server(\"test\")\n\n    @server.read_resource()\n    async def read_resource(uri: AnyUrl) -> Iterable[ReadResourceContents]:\n        return [ReadResourceContents(content=\"Hello World\", mime_type=\"text/plain\")]\n\n    # Get the handler directly from the server\n    handler = server.request_handlers[types.ReadResourceRequest]\n\n    # Create a request\n    request = types.ReadResourceRequest(\n        method=\"resources/read\",\n        params=types.ReadResourceRequestParams(uri=FileUrl(temp_file.as_uri())),\n    )\n\n    # Call the handler\n    result = await handler(request)\n    assert isinstance(result.root, types.ReadResourceResult)\n    assert len(result.root.contents) == 1\n\n    content = result.root.contents[0]\n    assert isinstance(content, types.TextResourceContents)\n    assert content.text == \"Hello World\"\n    assert content.mimeType == \"text/plain\"\n\n\n@pytest.mark.anyio\nasync def test_read_resource_binary(temp_file: Path):\n    server = Server(\"test\")\n\n    @server.read_resource()\n    async def read_resource(uri: AnyUrl) -> Iterable[ReadResourceContents]:\n        return [ReadResourceContents(content=b\"Hello World\", mime_type=\"application/octet-stream\")]\n\n    # Get the handler directly from the server\n    handler = server.request_handlers[types.ReadResourceRequest]\n\n    # Create a request\n    request = types.ReadResourceRequest(\n        method=\"resources/read\"\n... (content truncated)\n\n--- tests/server/test_session.py (py) ---\nimport anyio\nimport pytest\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.server.lowlevel import NotificationOptions\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import (\n    ClientNotification,\n    Completion,\n    CompletionArgument,\n    CompletionContext,\n    CompletionsCapability,\n    InitializedNotification,\n    PromptReference,\n    PromptsCapability,\n    ResourcesCapability,\n    ResourceTemplateReference,\n    ServerCapabilities,\n)\n\n\n@pytest.mark.anyio\nasync def test_server_session_initialize():\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](1)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](1)\n\n    # Create a message handler to catch exceptions\n    async def message_handler(\n        message: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n    ) -> None:\n        if isinstance(message, Exception):\n            raise message\n\n    received_initialized = False\n\n    async def run_server():\n        nonlocal received_initialized\n\n        async with ServerSession(\n            client_to_server_receive,\n            server_to_client_send,\n            InitializationOptions(\n                server_name=\"mcp\",\n                server_version=\"0.1.0\",\n                capabilities=ServerCapabilities(),\n            ),\n        ) as server_session:\n            async for message in server_session.incoming_messages:\n                if isinstance(message, Exception):\n                    raise message\n\n                if isinstance(message, ClientNotification) and isinstance(message.root, InitializedNotification):\n                    received_initialized = True\n                    return\n\n    try:\n        \n... (content truncated)\n\n--- tests/server/test_sse_security.py (py) ---\n\"\"\"Tests for SSE server DNS rebinding protection.\"\"\"\n\nimport logging\nimport multiprocessing\nimport socket\nimport time\n\nimport httpx\nimport pytest\nimport uvicorn\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import Mount, Route\n\nfrom mcp.server import Server\nfrom mcp.server.sse import SseServerTransport\nfrom mcp.server.transport_security import TransportSecuritySettings\nfrom mcp.types import Tool\n\nlogger = logging.getLogger(__name__)\nSERVER_NAME = \"test_sse_security_server\"\n\n\n@pytest.fixture\ndef server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]\n\n\n@pytest.fixture\ndef server_url(server_port: int) -> str:\n    return f\"http://127.0.0.1:{server_port}\"\n\n\nclass SecurityTestServer(Server):\n    def __init__(self):\n        super().__init__(SERVER_NAME)\n\n    async def on_list_tools(self) -> list[Tool]:\n        return []\n\n\ndef run_server_with_settings(port: int, security_settings: TransportSecuritySettings | None = None):\n    \"\"\"Run the SSE server with specified security settings.\"\"\"\n    app = SecurityTestServer()\n    sse_transport = SseServerTransport(\"/messages/\", security_settings)\n\n    async def handle_sse(request: Request):\n        try:\n            async with sse_transport.connect_sse(request.scope, request.receive, request._send) as streams:\n                if streams:\n                    await app.run(streams[0], streams[1], app.create_initialization_options())\n        except ValueError as e:\n            # Validation error was already handled inside connect_sse\n            logger.debug(f\"SSE connection failed validation: {e}\")\n        return Response()\n\n    routes = [\n        Route(\"/sse\", endpoint=handle_sse),\n        Mount(\"/messages/\", app=sse_transport.handle_post_message),\n    ]\n\n    starlette_app = Starlette(routes=routes)\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port, log_level=\"erro\n... (content truncated)\n\n--- tests/server/test_stdio.py (py) ---\nimport io\n\nimport anyio\nimport pytest\n\nfrom mcp.server.stdio import stdio_server\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import JSONRPCMessage, JSONRPCRequest, JSONRPCResponse\n\n\n@pytest.mark.anyio\nasync def test_stdio_server():\n    stdin = io.StringIO()\n    stdout = io.StringIO()\n\n    messages = [\n        JSONRPCMessage(root=JSONRPCRequest(jsonrpc=\"2.0\", id=1, method=\"ping\")),\n        JSONRPCMessage(root=JSONRPCResponse(jsonrpc=\"2.0\", id=2, result={})),\n    ]\n\n    for message in messages:\n        stdin.write(message.model_dump_json(by_alias=True, exclude_none=True) + \"\\n\")\n    stdin.seek(0)\n\n    async with stdio_server(stdin=anyio.AsyncFile(stdin), stdout=anyio.AsyncFile(stdout)) as (\n        read_stream,\n        write_stream,\n    ):\n        received_messages = []\n        async with read_stream:\n            async for message in read_stream:\n                if isinstance(message, Exception):\n                    raise message\n                received_messages.append(message.message)\n                if len(received_messages) == 2:\n                    break\n\n        # Verify received messages\n        assert len(received_messages) == 2\n        assert received_messages[0] == JSONRPCMessage(root=JSONRPCRequest(jsonrpc=\"2.0\", id=1, method=\"ping\"))\n        assert received_messages[1] == JSONRPCMessage(root=JSONRPCResponse(jsonrpc=\"2.0\", id=2, result={}))\n\n        # Test sending responses from the server\n        responses = [\n            JSONRPCMessage(root=JSONRPCRequest(jsonrpc=\"2.0\", id=3, method=\"ping\")),\n            JSONRPCMessage(root=JSONRPCResponse(jsonrpc=\"2.0\", id=4, result={})),\n        ]\n\n        async with write_stream:\n            for response in responses:\n                session_message = SessionMessage(response)\n                await write_stream.send(session_message)\n\n    stdout.seek(0)\n    output_lines = stdout.readlines()\n    assert len(output_lines) == 2\n\n    received_responses = [JSONRPCMessage.model_validate_json(line.strip()) for l\n... (content truncated)\n\n--- tests/server/test_streamable_http_manager.py (py) ---\n\"\"\"Tests for StreamableHTTPSessionManager.\"\"\"\n\nfrom unittest.mock import AsyncMock, patch\n\nimport anyio\nimport pytest\n\nfrom mcp.server import streamable_http_manager\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.streamable_http import MCP_SESSION_ID_HEADER\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\n\n\n@pytest.mark.anyio\nasync def test_run_can_only_be_called_once():\n    \"\"\"Test that run() can only be called once per instance.\"\"\"\n    app = Server(\"test-server\")\n    manager = StreamableHTTPSessionManager(app=app)\n\n    # First call should succeed\n    async with manager.run():\n        pass\n\n    # Second call should raise RuntimeError\n    with pytest.raises(RuntimeError) as excinfo:\n        async with manager.run():\n            pass\n\n    assert \"StreamableHTTPSessionManager .run() can only be called once per instance\" in str(excinfo.value)\n\n\n@pytest.mark.anyio\nasync def test_run_prevents_concurrent_calls():\n    \"\"\"Test that concurrent calls to run() are prevented.\"\"\"\n    app = Server(\"test-server\")\n    manager = StreamableHTTPSessionManager(app=app)\n\n    errors = []\n\n    async def try_run():\n        try:\n            async with manager.run():\n                # Simulate some work\n                await anyio.sleep(0.1)\n        except RuntimeError as e:\n            errors.append(e)\n\n    # Try to run concurrently\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(try_run)\n        tg.start_soon(try_run)\n\n    # One should succeed, one should fail\n    assert len(errors) == 1\n    assert \"StreamableHTTPSessionManager .run() can only be called once per instance\" in str(errors[0])\n\n\n@pytest.mark.anyio\nasync def test_handle_request_without_run_raises_error():\n    \"\"\"Test that handle_request raises error if run() hasn't been called.\"\"\"\n    app = Server(\"test-server\")\n    manager = StreamableHTTPSessionManager(app=app)\n\n    # Mock ASGI parameters\n    scope = {\"type\": \"http\", \"method\": \"POST\", \"path\": \"/test\"}\n\n    async def rec\n... (content truncated)\n\n--- tests/server/test_streamable_http_security.py (py) ---\n\"\"\"Tests for StreamableHTTP server DNS rebinding protection.\"\"\"\n\nimport logging\nimport multiprocessing\nimport socket\nimport time\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\n\nimport httpx\nimport pytest\nimport uvicorn\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.types import Receive, Scope, Send\n\nfrom mcp.server import Server\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom mcp.server.transport_security import TransportSecuritySettings\nfrom mcp.types import Tool\n\nlogger = logging.getLogger(__name__)\nSERVER_NAME = \"test_streamable_http_security_server\"\n\n\n@pytest.fixture\ndef server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]\n\n\n@pytest.fixture\ndef server_url(server_port: int) -> str:\n    return f\"http://127.0.0.1:{server_port}\"\n\n\nclass SecurityTestServer(Server):\n    def __init__(self):\n        super().__init__(SERVER_NAME)\n\n    async def on_list_tools(self) -> list[Tool]:\n        return []\n\n\ndef run_server_with_settings(port: int, security_settings: TransportSecuritySettings | None = None):\n    \"\"\"Run the StreamableHTTP server with specified security settings.\"\"\"\n    app = SecurityTestServer()\n\n    # Create session manager with security settings\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        json_response=False,\n        stateless=False,\n        security_settings=security_settings,\n    )\n\n    # Create the ASGI handler\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -> None:\n        await session_manager.handle_request(scope, receive, send)\n\n    # Create Starlette app with lifespan\n    @asynccontextmanager\n    async def lifespan(app: Starlette) -> AsyncGenerator[None, None]:\n        async with session_manager.run():\n            yield\n\n    routes = [\n        Mount(\"/\", app=handle_streamable_http),\n    ]\n\n    starlette_ap\n... (content truncated)\n\n--- tests/shared/test_auth.py (py) ---\n\"\"\"Tests for OAuth 2.0 shared code.\"\"\"\n\nfrom mcp.shared.auth import OAuthMetadata\n\n\nclass TestOAuthMetadata:\n    \"\"\"Tests for OAuthMetadata parsing.\"\"\"\n\n    def test_oauth(self):\n        \"\"\"Should not throw when parsing OAuth metadata.\"\"\"\n        OAuthMetadata.model_validate(\n            {\n                \"issuer\": \"https://example.com\",\n                \"authorization_endpoint\": \"https://example.com/oauth2/authorize\",\n                \"token_endpoint\": \"https://example.com/oauth2/token\",\n                \"scopes_supported\": [\"read\", \"write\"],\n                \"response_types_supported\": [\"code\", \"token\"],\n                \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\", \"client_secret_post\"],\n            }\n        )\n\n    def test_oidc(self):\n        \"\"\"Should not throw when parsing OIDC metadata.\"\"\"\n        OAuthMetadata.model_validate(\n            {\n                \"issuer\": \"https://example.com\",\n                \"authorization_endpoint\": \"https://example.com/oauth2/authorize\",\n                \"token_endpoint\": \"https://example.com/oauth2/token\",\n                \"end_session_endpoint\": \"https://example.com/logout\",\n                \"id_token_signing_alg_values_supported\": [\"RS256\"],\n                \"jwks_uri\": \"https://example.com/.well-known/jwks.json\",\n                \"response_types_supported\": [\"code\", \"token\"],\n                \"revocation_endpoint\": \"https://example.com/oauth2/revoke\",\n                \"scopes_supported\": [\"openid\", \"read\", \"write\"],\n                \"subject_types_supported\": [\"public\"],\n                \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\", \"client_secret_post\"],\n                \"userinfo_endpoint\": \"https://example.com/oauth2/userInfo\",\n            }\n        )\n\n\n--- tests/shared/test_auth_utils.py (py) ---\n\"\"\"Tests for OAuth 2.0 Resource Indicators utilities.\"\"\"\n\nfrom mcp.shared.auth_utils import check_resource_allowed, resource_url_from_server_url\n\n\nclass TestResourceUrlFromServerUrl:\n    \"\"\"Tests for resource_url_from_server_url function.\"\"\"\n\n    def test_removes_fragment(self):\n        \"\"\"Fragment should be removed per RFC 8707.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com/path#fragment\") == \"https://example.com/path\"\n        assert resource_url_from_server_url(\"https://example.com/#fragment\") == \"https://example.com/\"\n\n    def test_preserves_path(self):\n        \"\"\"Path should be preserved.\"\"\"\n        assert (\n            resource_url_from_server_url(\"https://example.com/path/to/resource\")\n            == \"https://example.com/path/to/resource\"\n        )\n        assert resource_url_from_server_url(\"https://example.com/\") == \"https://example.com/\"\n        assert resource_url_from_server_url(\"https://example.com\") == \"https://example.com\"\n\n    def test_preserves_query(self):\n        \"\"\"Query parameters should be preserved.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com/path?foo=bar\") == \"https://example.com/path?foo=bar\"\n        assert resource_url_from_server_url(\"https://example.com/?key=value\") == \"https://example.com/?key=value\"\n\n    def test_preserves_port(self):\n        \"\"\"Non-default ports should be preserved.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com:8443/path\") == \"https://example.com:8443/path\"\n        assert resource_url_from_server_url(\"http://example.com:8080/\") == \"http://example.com:8080/\"\n\n    def test_lowercase_scheme_and_host(self):\n        \"\"\"Scheme and host should be lowercase for canonical form.\"\"\"\n        assert resource_url_from_server_url(\"HTTPS://EXAMPLE.COM/path\") == \"https://example.com/path\"\n        assert resource_url_from_server_url(\"Http://Example.Com:8080/\") == \"http://example.com:8080/\"\n\n    def test_handles_pydantic_urls(self):\n        \"\"\"Should handle Pydantic URL t\n... (content truncated)\n\n--- tests/shared/test_httpx_utils.py (py) ---\n\"\"\"Tests for httpx utility functions.\"\"\"\n\nimport httpx\n\nfrom mcp.shared._httpx_utils import create_mcp_http_client\n\n\ndef test_default_settings():\n    \"\"\"Test that default settings are applied correctly.\"\"\"\n    client = create_mcp_http_client()\n\n    assert client.follow_redirects is True\n    assert client.timeout.connect == 30.0\n\n\ndef test_custom_parameters():\n    \"\"\"Test custom headers and timeout are set correctly.\"\"\"\n    headers = {\"Authorization\": \"Bearer token\"}\n    timeout = httpx.Timeout(60.0)\n\n    client = create_mcp_http_client(headers, timeout)\n\n    assert client.headers[\"Authorization\"] == \"Bearer token\"\n    assert client.timeout.connect == 60.0\n\n\n--- tests/shared/test_memory.py (py) ---\nimport pytest\nfrom pydantic import AnyUrl\nfrom typing_extensions import AsyncGenerator\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session,\n)\nfrom mcp.types import (\n    EmptyResult,\n    Resource,\n)\n\n\n@pytest.fixture\ndef mcp_server() -> Server:\n    server = Server(name=\"test_server\")\n\n    @server.list_resources()\n    async def handle_list_resources():\n        return [\n            Resource(\n                uri=AnyUrl(\"memory://test\"),\n                name=\"Test Resource\",\n                description=\"A test resource\",\n            )\n        ]\n\n    return server\n\n\n@pytest.fixture\nasync def client_connected_to_server(\n    mcp_server: Server,\n) -> AsyncGenerator[ClientSession, None]:\n    async with create_connected_server_and_client_session(mcp_server) as client_session:\n        yield client_session\n\n\n@pytest.mark.anyio\nasync def test_memory_server_and_client_connection(\n    client_connected_to_server: ClientSession,\n):\n    \"\"\"Shows how a client and server can communicate over memory streams.\"\"\"\n    response = await client_connected_to_server.send_ping()\n    assert isinstance(response, EmptyResult)\n\n\n--- tests/shared/test_progress_notifications.py (py) ---\nfrom typing import Any, cast\n\nimport anyio\nimport pytest\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.server import Server\nfrom mcp.server.lowlevel import NotificationOptions\nfrom mcp.server.models import InitializationOptions\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.progress import progress\nfrom mcp.shared.session import (\n    BaseSession,\n    RequestResponder,\n    SessionMessage,\n)\n\n\n@pytest.mark.anyio\nasync def test_bidirectional_progress_notifications():\n    \"\"\"Test that both client and server can send progress notifications.\"\"\"\n    # Create memory streams for client/server\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream[SessionMessage](5)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream[SessionMessage](5)\n\n    # Run a server session so we can send progress updates in tool\n    async def run_server():\n        # Create a server session\n        async with ServerSession(\n            client_to_server_receive,\n            server_to_client_send,\n            InitializationOptions(\n                server_name=\"ProgressTestServer\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(NotificationOptions(), {}),\n            ),\n        ) as server_session:\n            global serv_sesh\n\n            serv_sesh = server_session\n            async for message in server_session.incoming_messages:\n                try:\n                    await server._handle_message(message, server_session, ())\n                except Exception as e:\n                    raise e\n\n    # Track progress updates\n    server_progress_updates = []\n    client_progress_updates = []\n\n    # Progress tokens\n    server_progress_token = \"server_token_123\"\n    client_progress_token = \"client_token_456\"\n\n    # Create a server with progress capability\n    server = Server(name=\"ProgressTestServer\")\n\n \n... (content truncated)\n\n--- tests/shared/test_session.py (py) ---\nfrom collections.abc import AsyncGenerator\n\nimport anyio\nimport pytest\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.server.lowlevel.server import Server\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.memory import (\n    create_client_server_memory_streams,\n    create_connected_server_and_client_session,\n)\nfrom mcp.types import (\n    CancelledNotification,\n    CancelledNotificationParams,\n    ClientNotification,\n    ClientRequest,\n    EmptyResult,\n)\n\n\n@pytest.fixture\ndef mcp_server() -> Server:\n    return Server(name=\"test server\")\n\n\n@pytest.fixture\nasync def client_connected_to_server(\n    mcp_server: Server,\n) -> AsyncGenerator[ClientSession, None]:\n    async with create_connected_server_and_client_session(mcp_server) as client_session:\n        yield client_session\n\n\n@pytest.mark.anyio\nasync def test_in_flight_requests_cleared_after_completion(\n    client_connected_to_server: ClientSession,\n):\n    \"\"\"Verify that _in_flight is empty after all requests complete.\"\"\"\n    # Send a request and wait for response\n    response = await client_connected_to_server.send_ping()\n    assert isinstance(response, EmptyResult)\n\n    # Verify _in_flight is empty\n    assert len(client_connected_to_server._in_flight) == 0\n\n\n@pytest.mark.anyio\nasync def test_request_cancellation():\n    \"\"\"Test that requests can be cancelled while in-flight.\"\"\"\n    # The tool is already registered in the fixture\n\n    ev_tool_called = anyio.Event()\n    ev_cancelled = anyio.Event()\n    request_id = None\n\n    # Start the request in a separate task so we can cancel it\n    def make_server() -> Server:\n        server = Server(name=\"TestSessionServer\")\n\n        # Register the tool handler\n        @server.call_tool()\n        async def handle_call_tool(name: str, arguments: dict | None) -> list:\n            nonlocal request_id, ev_tool_called\n            if name == \"slow_tool\":\n                request_id = server.request_context.request_id\n                ev_tool_call\n... (content truncated)\n\n--- tests/shared/test_sse.py (py) ---\nimport json\nimport multiprocessing\nimport socket\nimport time\nfrom collections.abc import AsyncGenerator, Generator\n\nimport anyio\nimport httpx\nimport pytest\nimport uvicorn\nfrom inline_snapshot import snapshot\nfrom pydantic import AnyUrl\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import Mount, Route\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.client.sse import sse_client\nfrom mcp.server import Server\nfrom mcp.server.sse import SseServerTransport\nfrom mcp.server.transport_security import TransportSecuritySettings\nfrom mcp.shared.exceptions import McpError\nfrom mcp.types import (\n    EmptyResult,\n    ErrorData,\n    InitializeResult,\n    ReadResourceResult,\n    TextContent,\n    TextResourceContents,\n    Tool,\n)\n\nSERVER_NAME = \"test_server_for_SSE\"\n\n\n@pytest.fixture\ndef server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]\n\n\n@pytest.fixture\ndef server_url(server_port: int) -> str:\n    return f\"http://127.0.0.1:{server_port}\"\n\n\n# Test server implementation\nclass ServerTest(Server):\n    def __init__(self):\n        super().__init__(SERVER_NAME)\n\n        @self.read_resource()\n        async def handle_read_resource(uri: AnyUrl) -> str | bytes:\n            if uri.scheme == \"foobar\":\n                return f\"Read {uri.host}\"\n            elif uri.scheme == \"slow\":\n                # Simulate a slow resource\n                await anyio.sleep(2.0)\n                return f\"Slow response from {uri.host}\"\n\n            raise McpError(error=ErrorData(code=404, message=\"OOPS! no resource with that URI was found\"))\n\n        @self.list_tools()\n        async def handle_list_tools() -> list[Tool]:\n            return [\n                Tool(\n                    name=\"test_tool\",\n                    description=\"A test tool\",\n                    inputSchema={\"type\": \"object\", \"properties\": {\n... (content truncated)\n\n--- tests/shared/test_streamable_http.py (py) ---\n\"\"\"\nTests for the StreamableHTTP server and client transport.\n\nContains tests for both server and client sides of the StreamableHTTP transport.\n\"\"\"\n\nimport json\nimport multiprocessing\nimport socket\nimport time\nfrom collections.abc import Generator\nfrom typing import Any\n\nimport anyio\nimport httpx\nimport pytest\nimport requests\nimport uvicorn\nfrom pydantic import AnyUrl\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.routing import Mount\n\nimport mcp.types as types\nfrom mcp.client.session import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.server import Server\nfrom mcp.server.streamable_http import (\n    MCP_PROTOCOL_VERSION_HEADER,\n    MCP_SESSION_ID_HEADER,\n    SESSION_ID_PATTERN,\n    EventCallback,\n    EventId,\n    EventMessage,\n    EventStore,\n    StreamableHTTPServerTransport,\n    StreamId,\n)\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom mcp.server.transport_security import TransportSecuritySettings\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.message import (\n    ClientMessageMetadata,\n)\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import (\n    InitializeResult,\n    TextContent,\n    TextResourceContents,\n    Tool,\n)\n\n# Test constants\nSERVER_NAME = \"test_streamable_http_server\"\nTEST_SESSION_ID = \"test-session-id-12345\"\nINIT_REQUEST = {\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"initialize\",\n    \"params\": {\n        \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0\"},\n        \"protocolVersion\": \"2025-03-26\",\n        \"capabilities\": {},\n    },\n    \"id\": \"init-1\",\n}\n\n\n# Helper functions\ndef extract_protocol_version_from_sse(response: requests.Response) -> str:\n    \"\"\"Extract the negotiated protocol version from an SSE initialization response.\"\"\"\n    assert response.headers.get(\"Content-Type\") == \"text/event-stream\"\n    for line in response.text.splitlines():\n        if l\n... (content truncated)\n\n--- tests/shared/test_win32_utils.py (py) ---\n\"\"\"Windows-specific test utilities.\"\"\"\n\n\ndef escape_path_for_python(path: str) -> str:\n    \"\"\"Escape a file path for use in Python code strings.\n\n    Converts backslashes to forward slashes which work on all platforms\n    and don't need escaping in Python strings.\n    \"\"\"\n    return repr(path.replace(\"\\\\\", \"/\"))\n\n\n--- tests/shared/test_ws.py (py) ---\nimport multiprocessing\nimport socket\nimport time\nfrom collections.abc import AsyncGenerator, Generator\n\nimport anyio\nimport pytest\nimport uvicorn\nfrom pydantic import AnyUrl\nfrom starlette.applications import Starlette\nfrom starlette.routing import WebSocketRoute\n\nfrom mcp.client.session import ClientSession\nfrom mcp.client.websocket import websocket_client\nfrom mcp.server import Server\nfrom mcp.server.websocket import websocket_server\nfrom mcp.shared.exceptions import McpError\nfrom mcp.types import (\n    EmptyResult,\n    ErrorData,\n    InitializeResult,\n    ReadResourceResult,\n    TextContent,\n    TextResourceContents,\n    Tool,\n)\n\nSERVER_NAME = \"test_server_for_WS\"\n\n\n@pytest.fixture\ndef server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]\n\n\n@pytest.fixture\ndef server_url(server_port: int) -> str:\n    return f\"ws://127.0.0.1:{server_port}\"\n\n\n# Test server implementation\nclass ServerTest(Server):\n    def __init__(self):\n        super().__init__(SERVER_NAME)\n\n        @self.read_resource()\n        async def handle_read_resource(uri: AnyUrl) -> str | bytes:\n            if uri.scheme == \"foobar\":\n                return f\"Read {uri.host}\"\n            elif uri.scheme == \"slow\":\n                # Simulate a slow resource\n                await anyio.sleep(2.0)\n                return f\"Slow response from {uri.host}\"\n\n            raise McpError(error=ErrorData(code=404, message=\"OOPS! no resource with that URI was found\"))\n\n        @self.list_tools()\n        async def handle_list_tools() -> list[Tool]:\n            return [\n                Tool(\n                    name=\"test_tool\",\n                    description=\"A test tool\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                )\n            ]\n\n        @self.call_tool()\n        async def handle_call_tool(name: str, args: dict) -> list[TextContent]:\n            return [TextContent(type=\"text\", text=f\"Called {name}\")]\n\n\n# Test \n... (content truncated)\n\n--- tests/test_examples.py (py) ---\n\"\"\"Tests for example servers\"\"\"\n\nimport sys\n\nimport pytest\nfrom pytest_examples import CodeExample, EvalExample, find_examples\n\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as client_session,\n)\nfrom mcp.types import TextContent, TextResourceContents\n\n\n@pytest.mark.anyio\nasync def test_simple_echo():\n    \"\"\"Test the simple echo server\"\"\"\n    from examples.fastmcp.simple_echo import mcp\n\n    async with client_session(mcp._mcp_server) as client:\n        result = await client.call_tool(\"echo\", {\"text\": \"hello\"})\n        assert len(result.content) == 1\n        content = result.content[0]\n        assert isinstance(content, TextContent)\n        assert content.text == \"hello\"\n\n\n@pytest.mark.anyio\nasync def test_complex_inputs():\n    \"\"\"Test the complex inputs server\"\"\"\n    from examples.fastmcp.complex_inputs import mcp\n\n    async with client_session(mcp._mcp_server) as client:\n        tank = {\"shrimp\": [{\"name\": \"bob\"}, {\"name\": \"alice\"}]}\n        result = await client.call_tool(\"name_shrimp\", {\"tank\": tank, \"extra_names\": [\"charlie\"]})\n        assert len(result.content) == 3\n        assert isinstance(result.content[0], TextContent)\n        assert isinstance(result.content[1], TextContent)\n        assert isinstance(result.content[2], TextContent)\n        assert result.content[0].text == \"bob\"\n        assert result.content[1].text == \"alice\"\n        assert result.content[2].text == \"charlie\"\n\n\n@pytest.mark.anyio\nasync def test_desktop(monkeypatch):\n    \"\"\"Test the desktop server\"\"\"\n    from pathlib import Path\n\n    from pydantic import AnyUrl\n\n    from examples.fastmcp.desktop import mcp\n\n    # Mock desktop directory listing\n    mock_files = [Path(\"/fake/path/file1.txt\"), Path(\"/fake/path/file2.txt\")]\n    monkeypatch.setattr(Path, \"iterdir\", lambda self: mock_files)\n    monkeypatch.setattr(Path, \"home\", lambda: Path(\"/fake/home\"))\n\n    async with client_session(mcp._mcp_server) as client:\n        # Test the sum function\n        result = awa\n... (content truncated)\n\n--- tests/test_types.py (py) ---\nimport pytest\n\nfrom mcp.types import (\n    LATEST_PROTOCOL_VERSION,\n    ClientRequest,\n    JSONRPCMessage,\n    JSONRPCRequest,\n)\n\n\n@pytest.mark.anyio\nasync def test_jsonrpc_request():\n    json_data = {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"initialize\",\n        \"params\": {\n            \"protocolVersion\": LATEST_PROTOCOL_VERSION,\n            \"capabilities\": {\"batch\": None, \"sampling\": None},\n            \"clientInfo\": {\"name\": \"mcp\", \"version\": \"0.1.0\"},\n        },\n    }\n\n    request = JSONRPCMessage.model_validate(json_data)\n    assert isinstance(request.root, JSONRPCRequest)\n    ClientRequest.model_validate(request.model_dump(by_alias=True, exclude_none=True))\n\n    assert request.root.jsonrpc == \"2.0\"\n    assert request.root.id == 1\n    assert request.root.method == \"initialize\"\n    assert request.root.params is not None\n    assert request.root.params[\"protocolVersion\"] == LATEST_PROTOCOL_VERSION\n\n\n\n**ORGANIZATION-WIDE CONTEXT:**\nThis organization has 5 repositories total.\n\n**Organization Patterns:**\n- Common Languages: \n- Common Frameworks: \n- File Extensions Used: .yaml (5 files), .yml (12 files), .gitignore (7 files), .md (38 files), .no_ext (14 files), .py (266 files), .toml (14 files), .MD (1 files), .example (3 files), .txt (9 files)\n\n**Other Repositories in Organization:**\n- modelcontextprotocol-servers: ## Analysis of the Provided Model Context Protocol (MCP) Server Repository\n\nThis repository contains...\n- jayasaisrikar-flockshop: ## FlockShop Repository Architecture Analysis\n\nBased on the provided files, FlockShop is a web appli...\n- jayasaisrikar-bi_dashboard: ## Wayne Enterprises Business Intelligence Dashboard: Repository Analysis\n\nBased on the provided fil...\n- jayasaisrikar-portfolio_app: ## Repository Architecture Analysis\n\nThis Django-based portfolio website uses a modular architecture...\n\n**Architecture Analysis:**\n## Analysis of the Provided Repository\n\nBased on the provided file list and snippets, the repository appears to be a Python SDK (likely for the Model Context Protocol, judging by filenames) with associated documentation, examples, and a robust CI/CD pipeline.\n\n**1. Detailed Architecture Summary:**\n\nThe repository is structured around a core Python SDK, supplemented by example client and server applications.  Documentation is provided in Markdown files (`README.md`, `docs/api.md`, etc.). The CI/CD pipeline uses GitHub Actions and `uv` (likely a build system) for automated checks, testing, and publishing to PyPI.  Pre-commit hooks ensure code quality. Issue templates guide contributors in reporting bugs and suggesting features.\n\n\n**2. Key Components and Their Relationships:**\n\n* **Core SDK:** The majority of the unspecified 219 files likely constitute the main Python SDK codebase.  We see hints of this in the examples' `__init__.py` files (e.g., `examples/clients/simple-auth-client/mcp_simple_auth_client/__init__.py`).\n* **Example Clients:**  Folders like `examples/clients/simple-auth-client` and `examples/clients/simple-chatbot` demonstrate usage of the SDK.  These examples include `main.py` files showing client-side interactions.  Dependencies are managed via `pyproject.toml` and `requirements.txt`.\n* **Example Servers:**  `examples/servers/simple-auth` showcases server-side integration with the SDK, illustrating how to build services utilizing the library.  Modules like `auth_server.py` and `simple_auth_provider.py` suggest authentication mechanisms.\n* **Documentation:** `README.md`, `docs/api.md`, and other `.md` files provide user documentation.\n* **CI/CD Pipeline:** GitHub Actions workflows (`main-checks.yml`, `publish-docs-manually.yml`, `publish-pypi.yml`, `pull-request-checks.yml`) automate the build, test, and deployment process.  `shared.yml` centralizes common steps for various workflows.  The pipeline uses `uv` for build tasks and `pre-commit` for code linting.\n* **Pre-commit Hooks:** `.pre-commit-config.yaml` configures pre-commit hooks (Prettier, markdownlint, Ruff) to maintain code style and quality before commits.\n\n\n**3. Data Flow Patterns and API Structure (from actual code):**\n\nBased on the limited code, the SDK likely utilizes a client-server architecture.  Client examples interact with server examples via network calls (implicitly suggested by the server examples and chatbot configuration). The `simple-auth` example hints at authentication mechanisms (tokens, verification) which are core parts of the API.  The absence of extensive code prevents a detailed description of data flow or API endpoints.\n\n\n**4. Integration Points and Dependencies:**\n\n* **External Dependencies:** The `requirements.txt` files list runtime dependencies for the examples.\n* **Build System:** The `uv` build system is a central integration point for building, testing, and deploying the SDK.\n* **GitHub Actions:** The CI/CD pipeline is integrated with GitHub for workflow automation.\n* **Pre-commit:**  Code quality tools (Prettier, markdownlint, Ruff, pyright) are integrated via pre-commit hooks.\n* **PyPI:**  The SDK is deployed to PyPI, using `publish-pypi.yml`.\n\n\n**5. Specific Feature Addition Recommendations (exact file locations):**\n\n* **Improved Documentation:**  Adding more detailed examples and API references within the `docs/` folder, particularly `docs/api.md`, would significantly enhance usability.  Adding usage examples for advanced scenarios would be particularly helpful.\n* **Enhanced Error Handling:**  Including more robust error handling and informative error messages in the core SDK files (the unspecified 219 files) would improve developer experience.  This would necessitate modifications within the core SDK codebase.\n* **Logging and Monitoring:**  Adding logging capabilities within the SDK files would aid in debugging and monitoring.  This is vital in the unspecified 219 files where the core SDK logic resides.\n* **Improved Testing:**  Expanding the test suite to cover more edge cases and scenarios would increase confidence in the SDK's reliability. This would involve adding more tests to the examples or a dedicated `tests/` directory (if one exists, which is not shown).\n\nThese recommendations focus on improving the user experience, stability, and maintainability of the SDK.  The exact implementation would involve modifying the core SDK and documentation files.  Without access to the complete codebase,  the specific file locations cannot be pinpointed beyond the general folders mentioned above.\n\n\n**System Diagram:**\n```mermaid\ngraph TD\ngroup_yaml[YAML Files]\nfile_1[bug.yaml]\ngroup_yaml --> file_1\nclick file_1 \".github/ISSUE_TEMPLATE/bug.yaml\"\nfile_2[config.yaml]\ngroup_yaml --> file_2\nclick file_2 \".github/ISSUE_TEMPLATE/config.yaml\"\ngroup_yml[YML Files]\nfile_3[main-checks.yml]\ngroup_yml --> file_3\nclick file_3 \".github/workflows/main-checks.yml\"\nfile_4[publish-docs-manually.yml]\ngroup_yml --> file_4\nclick file_4 \".github/workflows/publish-docs-manually.yml\"\ngroup_gitignore[GITIGNORE Files]\nfile_5[.gitignore]\ngroup_gitignore --> file_5\nclick file_5 \".gitignore\"\ngroup_md[MD Files]\nfile_6[CLAUDE.md]\ngroup_md --> file_6\nclick file_6 \"CLAUDE.md\"\nfile_7[CODE_OF_CONDUCT.md]\ngroup_md --> file_7\nclick file_7 \"CODE_OF_CONDUCT.md\"\ngroup_unknown[UNKNOWN Files]\nfile_8[LICENSE]\ngroup_unknown --> file_8\nclick file_8 \"LICENSE\"\ngroup_py[PY Files]\nfile_9[__init__.py]\ngroup_py --> file_9\nclick file_9 \"examples/clients/simple-auth-client/mcp_simple_auth_client/__init__.py\"\nfile_10[main.py]\ngroup_py --> file_10\nclick file_10 \"examples/clients/simple-auth-client/mcp_simple_auth_client/main.py\"\ngroup_toml[TOML Files]\nfile_11[pyproject.toml]\ngroup_toml --> file_11\nclick file_11 \"examples/clients/simple-auth-client/pyproject.toml\"\nfile_12[pyproject.toml]\ngroup_toml --> file_12\nclick file_12 \"examples/clients/simple-chatbot/pyproject.toml\"\ngroup_MD[MD Files]\nfile_13[README.MD]\ngroup_MD --> file_13\nclick file_13 \"examples/clients/simple-chatbot/README.MD\"\ngroup_example[EXAMPLE Files]\nfile_14[.env.example]\ngroup_example --> file_14\nclick file_14 \"examples/clients/simple-chatbot/mcp_simple_chatbot/.env.example\"\ngroup_txt[TXT Files]\nfile_15[requirements.txt]\ngroup_txt --> file_15\nclick file_15 \"examples/clients/simple-chatbot/mcp_simple_chatbot/requirements.txt\"\ngroup_json[JSON Files]\nfile_16[servers_config.json]\ngroup_json --> file_16\nclick file_16 \"examples/clients/simple-chatbot/mcp_simple_chatbot/servers_config.json\"\ngroup_yaml --> group_yml\ngroup_yml --> group_gitignore\ngroup_gitignore --> group_md\ngroup_md --> group_unknown\ngroup_unknown --> group_py\ngroup_py --> group_toml\ngroup_toml --> group_MD\ngroup_MD --> group_example\ngroup_example --> group_txt\ngroup_txt --> group_json\n```\n\nIMPORTANT: Use the relevant conversation history above to maintain context and avoid repeating information. Build upon previous discussions and reference earlier conversations when relevant.\n\nYou now have access to the COMPLETE codebase structure and file contents PLUS context from 5 other repositories in this organization PLUS relevant conversation history.\n\nWhen answering:\n1. **Reference previous conversations** and build upon them\n2. Use patterns from other repos in the organization\n3. Suggest consistency with the org's common tech stack\n4. Reference similar implementations from other repos when relevant\n5. Consider the organization's architectural patterns\n\nWhen suggesting where to add new features:\n1. Follow patterns used across the organization\n2. Identify the exact files that would need to be modified\n3. Specify the exact locations within those files\n4. Provide code examples based on the existing patterns in THIS codebase AND organization patterns\n5. Consider the existing architecture and follow the same patterns used across all repos\n6. **Build upon previous suggestions** and maintain conversation continuity\n\nConsider the conversation history when answering to maintain context and avoid repeating information already provided.\n",
  "response": "Integrating the `modelcontextprotocol-python-sdk` into the FlockShop repository (assuming `jayasaisrikar-flockshop`) depends heavily on FlockShop's current architecture and technology stack.  We lack that information, but we can outline a general integration strategy based on the SDK's capabilities and best practices observed across the organization's repositories.\n\n**Integration Strategy:**\n\nThe `modelcontextprotocol-python-sdk` provides client and server components.  The integration approach depends on whether you want to use the SDK to build new features within FlockShop or integrate FlockShop with an existing MCP server.\n\n**1.  Building New Features with the SDK (Server-Side Integration):**\n\nThis involves using the SDK's server components to create new microservices within FlockShop's architecture.  This is likely the more complex approach.\n\n* **Identify Integration Points:**  Analyze FlockShop's existing API and identify potential areas where MCP functionality would enhance its capabilities.  For instance, integrating with external LLMs for advanced product descriptions, personalized recommendations, or chatbot support.\n\n* **Microservice Design:**  Design new microservices using the `FastMCP` framework (preferred for its ease of use).  These microservices would expose tools and resources via the MCP protocol.  For example, a \"ProductDescription\" tool could generate descriptions, a \"Recommendation\" tool could suggest related products, etc. The `examples/servers/` directory in the SDK provides templates for various server types (simple-prompt, simple-tool, etc.).  These can be adapted as starting points.\n\n* **Dependency Management:**  Add the `modelcontextprotocol-python-sdk` as a dependency in FlockShop's `pyproject.toml` file, likely in a dedicated section for this microservice.\n\n* **Deployment:**  Deploy the new microservices separately from the main FlockShop application.  The deployment strategy should align with FlockShop's existing approach (e.g., Docker, Kubernetes).\n\n* **API Design:** Design consistent APIs, following the patterns observed in `modelcontextprotocol-servers` if applicable.\n\n\n**2. Integrating with an Existing MCP Server (Client-Side Integration):**\n\nThis is a simpler approach, integrating FlockShop with an already-functioning MCP server.\n\n* **Choose a Client:** Select an appropriate client from the SDK (e.g., `stdio_client` for simple interactions, `streamablehttp_client` for streaming interactions, or a WebSocket client if the server supports it).  Refer to the SDK's example clients for implementation patterns.  The `examples/clients/` directory provides numerous examples.\n\n* **Identify Integration Points:**  Determine where in FlockShop the external server's functionality is needed.  For example, you might leverage an existing MCP server's tools to enhance product information or customer service.\n\n* **Dependency Management:** Add the `modelcontextprotocol-python-sdk` as a dependency to FlockShop's `pyproject.toml` file, ensuring any necessary optional dependencies (e.g., `mcp[cli]`, `mcp[ws]`) are also included.\n\n* **API Calls:** Make API calls from FlockShop to the MCP server using the selected client.  Ensure error handling is robust.\n\n\n**Example Integration (FastMCP Server-Side):**\n\nLet's say FlockShop needs a tool to generate product descriptions.  You could add a new microservice:\n\n```python\n# new_microservice.py\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"ProductDescriptionService\")\n\n@mcp.tool()\ndef generate_description(product_name: str, product_features: list[str]) -> str:\n    \"\"\"Generates a product description.\"\"\"\n    # ... implementation using an LLM or other logic ...\n    return f\"This is a description of {product_name} with features: {', '.join(product_features)}\"\n\nmcp.run() # or adapt for your deployment method.\n```\n\nThis would then need to be added to FlockShop's deployment pipeline.  The `pyproject.toml` for this microservice would include `mcp` as a dependency.\n\n**Important Considerations:**\n\n* **Error Handling:** Implement comprehensive error handling to gracefully manage network issues, invalid responses from the MCP server, and other potential problems.  The existing SDK examples demonstrate this.\n* **Authentication:** If the MCP server requires authentication, the FlockShop integration must include the necessary credentials and mechanisms (OAuth, API keys, etc.). The `examples/servers/simple-auth` directory in the SDK shows OAuth 2.0 integration.\n* **Asynchronous Operations:**  If you are using the `streamablehttp_client` or WebSocket client, remember to handle asynchronous operations correctly to avoid blocking the main FlockShop thread.\n\n\nWithout knowing FlockShop's details, this is the most comprehensive plan possible.  To provide more specific guidance, please share details about FlockShop's architecture and existing technology stack.\n",
  "model": "Gemini",
  "timestamp": "2025-07-18T10:54:39.651208"
}